数字
	int float
	+ - * / ** // %
	=
	_
	
字符串
	' '   '' '' 
	/  r''  r'' ''
	''' ''' 
	+
	index
		 +---+---+---+---+---+---+
		 | P | y | t | h | o | n |
		 +---+---+---+---+---+---+
		 0   1   2   3   4   5   6
		-6  -5  -4  -3  -2  -1
		
列表
	index copy？？
		>>> list1 = []
		>>> list2 = list1[:]
		>>> id(list1)
		17386072
		>>> id(list2)
		17879848
		
	+
	
	
	a = [xx,xx,xx,xx,[xx,x,,x,xx,xx]]
	a[-1][-1]

	>>> # Fibonacci series:
	... # the sum of two elements defines the next
	... a, b = 0, 1
	>>> while a < 10:
	...     print(a,end = '')
	...     a, b = b, a+b
	...
	0
	1
	1
	2
	3
	5
	8
	
	method
		list.clear() = del a[:]
		list.pop()不给参数删除最后一个
		
	列表作为堆栈使用 先进后出
	列表作为队列使用 先进先出
	
	列表推导式
		>>> [(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]
		[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]
		而它等价于

		>>>
		>>> combs = []
		>>> for x in [1,2,3]:
		...     for y in [3,1,4]:
		...         if x != y:
		...             combs.append((x, y))
		...
		>>> combs
		[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]
		
	嵌套的列表表达式
		

		matrix=[
			[1,2,3,4],
			[5,6,7,8],
			[9,10,11,12]

		]
		c = [[row[i] for row in matrix] for i in range(4)]
		print(c)

		d = []
		for i in range(4):
			e = []
			for row in matrix:
				e.append(row[i])
			d.append(e[:])
		print(d)
		
		print(list(zip(*matrix)))##快速方法
		
	del
		del list[:]
		del list
		
序列
	元组，列表，range str



元组
	，是核心
	>>> a = ()
	>>> type(a)
	<class 'tuple'>
	>>> a = (1,)
	>>> type(a)
	<class 'tuple'>
	>>> a = (1)
	>>> type(a)
	<class 'int'>
	>>> a = tuple()
	>>> type(a)
	<class 'tuple'>
	>>> a = 1,
	>>> type(a)
	<class 'tuple'>
	丑陋但有效
	
集合
	>>> a = {}
	>>> type(a)
	<class 'dict'>
	>>> a = set()
	>>> type(a)
	<class 'set'>
	
	集合推导式
		>>> a = {x for x in 'abracadabra' if x not in 'abc'}
		>>> a
		{'r', 'd'}
		
字典
	数字和字符串都可以作为健
	
	dict创建
		>>> dict([('sape', 4139), ('guido', 4127), ('jack', 4098)])
		{'sape': 4139, 'guido': 4127, 'jack': 4098}
		只要是序列的满足以上形式都可以创建
		
		d = dict(a=1,b=2,c=3)
		print(d)
		
	字典推导式
		>>> {x: x**2 for x in (2, 4, 6)}
		{2: 4, 4: 16, 6: 36}
		
循环技巧
	zip()
	enumerate()
	
	

		
	
		

流程控制
	if
	elif'
	else
	
	for i in 序列
		>>> for w in words[:]:  # Loop over a slice copy of the entire list.
		...     if len(w) > 6:
		...         words.insert(0, w)
		...
		>>> words
		['defenestrate', 'cat', 'window', 'defenestrate']
			
	range()
	len()

	break continue else
	有break就没else
	
	pass
	
	定义函数
		def xxx(xxx):
			xxxx
			xxxx
			return xxx#有无return的区别
			
	默认参数
	关键字参数
	
	解包参数列表
		def cheeseshop(kind, *arguments, **keywords):
			print("-- Do you have any", kind, "?")
			print("-- I'm sorry, we're all out of", kind)
			for arg in arguments:
				print(arg)
			print("-" * 40)
			for kw in keywords:
				print(kw, ":", keywords[kw])
		它可以像这样调用:

		cheeseshop("Limburger", "It's very runny, sir.",
				   "It's really very, VERY runny, sir.",
				   shopkeeper="Michael Palin",
				   client="John Cleese",
				   sketch="Cheese Shop Sketch")
				   
	lambda
		
	'''abc   标注的第一行没有缩进
		abcd
	'''
	
模块
	__name__
	

	import x
	from xxxx import xx  as xxxxx
	from xxxx import * 
	不可取，可能会覆盖原本定义的变量和函数
	
	if __name__ == "__main__":
		xxxx
	只有做为main文件才能被执行
	
	模块搜索路径
		
		
包
	__init__.py
	
	从包导入*
		__all__ = ['xx', 'xx' ]
	子包导入
		..
		.
		
格式化输出
	格式化字符串文字
		格式化字符串字面值， !a !s
		f'  {a:xxx}  {b!r}   '
		
	.format
		'{}{}'.format()
		位置参数
		关键字参数
		
		[]在格式化中访问字典
		
		
旧式的格式化方法
	'%xxx'%xxx
	
	
读写文件
	 f = open('workfile', 'w')
				文件名		模式
				
	好用的with
	
	with open('workfile') as f:
		read_data = f.read()
		
		
	json
	
	pickle
	


错误和异常
	try:
		 raise xxxxxxError(xxx,xxxx)
		
	except xxxxxError as error :
		xxxxxx
	else:
		xxxxxxx
	finally:
		xxxxxxxxxxx
				
	
			
	
	
		

			
	
	
	
	


	