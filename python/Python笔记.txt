python 如何运行程序
	python的解释器
		介于代码与计算机硬件之间的软件逻辑层

	程序的执行
		过程
			源码 -> 字节码 -> PVM

		字节码编译
			会将源码编译成字节码指令保存在.pyc扩展名的文件

			保存字节码是一种启动速度的优化。
				下一次运行程序时，有.pyc文件且最后保存时间与.py文件相同时执行；
				不然就重新编译。若无法写入字节码，则会在内存中生成，程序执行完成后丢弃。

		python的虚拟机（PVM）
			一旦程序编译成字节码，就发送到PVM上运行，PVM是迭代运行字节码指令的一个大循环。

Python的基础
	idle运行
		三个快捷键
			历史
				alt + N 或者 alt + P 上一段代码或者第一次输入的代码
			补充
				tab 可以补充剩下缺失的关键词

		idle中使用多条语句
			例如 import sys; x = 'runoob';sys.stdout.write(x + '\n')
			关键是在两个语句中插入分号,

	缩进
		不用分号来结束语句

		用缩进来分别代码块
			缩进不同是会报错的！！！！
			缩进不同是会报错的！！！！

	脚本文件运行
		第一行
			#!/usr/bin/env python3
			#！这个被称为shebang 这个是告诉shell使用python解释器执行下面的代码

		添加可执行权限：
			$ chmod +x helloworld.py

		执行脚本文件：
			$ ./helloworld.py

		简易方法
			python3 xx.py
			ipython xx.py

	input()
		参数名 = input（'xxxxxxxxx'）
			input()输入函数返回的是str类型

			返回的值会被赋值到等号前面的参数

			输入的字符串到\n就被系统直接截止

		多行输入
			while 函数和input函数的结合可以实现多行输入

			def  filt():
				name = input('请输入文件名:')
				f = open('%s.txt'%(name),'x')
				print('请输入内容【单独输入‘:w’保存退出】:\n')
				while True:
					content = input()#while函数+input 实现多行输入
					if content != ':w':
						f.write('%s\n'%content)#每次输入换行
					else:
						break
				f.close()
			filt()

	print()
		print 默认是换行的，如果不需要换行需要在最后加上end = “ ”
		或者需要在末尾添加别的符号也可以赋值到end

		多打印几句
			print("xxxxxxx"*2)

	Python的注释
		注释是非常重要的东西，可以方便维护和读懂程序
		单行#（最好空格后写注释）
		多行用''' ''' 或 """ """

	dir()
		不带参数
			返回当前范围内的变量、方法和定义的类型列表

		带参数
			返回参数的属性、方法列表

	关键字
		最好别拿关键字来赋值

		获取关键字
			1、
				help（）
				keywords
			2、
				import keyword
				keyword.kwlist

python数据类型
	变量
		变量的创建过程
			a = 3

			1 创建了一个对象来代表3
				对象是一块内存，来存储它所表示的东西
			2 创建了一个变量a，如果它还没有被创建的话
				变量是对象的指针
			3 将变量与新的对象3相链接
				引用是自动形成的，从变量到对象的指针

		垃圾回收机制
			当一个变量赋予了一个新的对象，之前那个对象占用的空间就会被回收
			（如果它没有被其他变量所引用的话）
			a = 1
			a = "abc"
			a = 42
			以这个为例，在a不断被赋值的时候前一个对象因为没有另外的变量引用，
			所以python会直接回收对象的空间。
			主要是对象有个头部信息是引用计数器（另一个是类型标志符），
			当引用计数器为0时会直接回收。

			可以参考模块gc

		赋值
			python变量命名的的规则和禁忌
				不能以数字开头

				命名变量函数不能用关键词

				变量命名需要规范合法
					最好不用a，x 乱七八糟的命名格式，最好用如str1之类的命名，清楚表明这个变量是干嘛的

				python变量的命名是支持中文命名哦，因为默认使用UEF-8编码

				相同数据结构可以直接赋值
					(role,line_spoken) = each_line.split(':',1) #split(分隔符，分割几次)

			多个变量赋值
				a = b = c = 1
				或者
				a , b , c = 1 , 2 , 3

				假设有 x = 1，y = 2，z = 3，请问如何快速将三个变量的值互相交换？
					x, y, z = z, y, x

	查看类型
		两个函数
			type(变量名) 直接反馈类型
			isinstance(变量名，类型) 判断是否是你输入的类型

	number（数字）
		类型
			int float complex 小数数字 分数 bool

		删除
			del 变量名

		数字类型的转换
			int(x)
				将x转换为一个整数。

				或者将其他进制转换为十进制
					>>> int("100",2)
					4
					>>> int("100",8)
					64
					>>> int("100",10)
					100
					>>> int("100",16)
					256

			bool()
				实际上是int的子类
					1 0  True False

				可以将任何数据转换为True or False

			complex()
				complex(x)
					将x转换到一个复数，实数部分为 x，虚数部分为 0。

				complex(x, y) 将 x 和 y 转换到一个复数，实数部分为 x，
					虚数部分为 y。x 和 y 是数字表达式。


				complex(a,b) = a + bj  复数拿等号前后两种表示方法都行

		进制转换
			bin() 二进制
			oct() 八进制
			hex() 十六进制

		内置的数学函数
			min（）
			max（a,b）
			pow(x,y,z = None)：
				#Equivalent to x**y (with two arguments) or x**y % z (with three arguments)
			abs() 绝对值

		random模块
			一般用法
				import random
				random.randint(x,y)
				#Return random integer in range [a, b], including both end points
				>>> random.choice(["a","b","c"])
						'a'

		模块math
			>>> import math
			>>> math.pi
			3.141592653589793
			>>> math.e
			2.718281828459045
			>>> math.sqrt(144)
			12.0
			>>> math.floor(-2.6)
			-3
			#next-lower integer
			>>> math.trunc(-2.645)
			-2  #保留整数
			>>> math.ceil(1.5)
			2
			>>> math.ceil(1.1)
			2
			#向上取整


		混合类型自动升级
			48+3.14
				不同类型的数作运算python会根据两者类型的复杂度来强制转换为复杂度最大的，这个例子是全部转换为浮点数，输出为浮点数

			复杂度的大小：
				整数 < 浮点数 < 复数
				>>> 1+2j + 1
				(2+2j)

		特殊技巧
			四舍五入法
				浮点数转整数是保留.之前的数
				int(xx.xx+0.55)

			保留多少位（小数点后多少位）
				round(number[, ndigits]) -> number
					>>> round(10.21312312312,3)
					10.21

	序列
		组成
			元组、列表和字符串，range等

		分片索引
			string[x:y:z]
				从x到y-1的元素（不包括y），z是步进
				这东西可以截取是非常牛逼的东西
				其他序列类型都能使用
				负索引 和正索引的对比
				负索引 = 正索引-长度
				index
					 +---+---+---+---+---+---+
					 | P | y | t | h | o | n |
					 +---+---+---+---+---+---+
					 0   1   2   3   4   5   6
					-6  -5  -4  -3  -2  -1

		序列的方法
			转换
				list()		转换成列表
				tuple()		转换成元组
				str()		转换成字符串

			数值
				len()		返回长度
				max() 		返回最大值，字母返回asc码的最大值
				min()		返回最小值，和max()相反
				reversed()  还是那个反转
				sorted（）从小到大排列
				sum(interable,star = 0)  返回一个star + interable 的总和 ，只能数字类型相加。


			两种打包函数
				zip()
					打包两组数据整合   数据长度不同取小的长度  以元组的形式打包[(a,b),(c,d),(e,f)]
					>>> a = [1,2,3,4,5,6,7,8]
					>>> b = [1,2,6,7,5,9,6,2,7]
					>>> list(zip(a,b))
						[(1, 1), (2, 2), (3, 6), (4, 7), (5, 5), (6, 9), (7, 6), (8, 2)]

				enumerate() 把位置和数据一起整合成一个（x，y）x是位置，y是数据
					>>> enumerate(list1)
					<enumerate object at 0x000001C686E8A288>a/b
					>>> list(enumerate(list1))
					[(0, 1), (1, 2), (2, 5), (3, 3), (4, 5), (5, 8), (6, 6)]

				特别的
					enumerate() reversed() zip() 得用list（）才能显示！！！

					这两个产生的数据可以被for x，y in xxxxx所使用

		string
			拼接
				+
				其实其他的序列也是能用拼接的，拼接只能用于相同类型的数据

			三重引号
				""" """长字符串

			格式化函数
				format 格式化函数
					‘{0}{1}’.format('das','das')  位置参数
					'{a}{b}'format(a = 'sd',b = "sdf") 关键字参数
					混合使用位置参数必须在关键字参数之前，不然会报错#在format 函数里
						'{0}{a}'.format('123',a = '464')

					>>> "{{0}}".format("不打印")
					'{0}'
					结果不是“{不打印}”，因为这个时候{0}不代表位置，而是字符串了

					format 函数的骚操作
						>>> "{0:4.2f}".format(a)
						'0.33'

			格式化操作符
				写法  '%d'%(x)
				%c	 格式化字符及其ASCII码
				%s	 格式化字符串
				%d	 格式化整数
				%o	 格式化无符号八进制数
				%x	 格式化无符号十六进制数
				%X	 格式化无符号十六进制数（大写）
				%f	 格式化浮点数字，可指定小数点后的精度
				%e	 用科学计数法格式化浮点数
				%E	 作用同%e，用科学计数法格式化浮点数
				%g	 自动选择%f或者%e，小写e
				%G	 自动选择%f或者%e，大写e

			格式化操作符辅助指令
				-		用做左对齐
				+		在正数前面显示加号( + )
				<sp>	在正数前面显示空格
				#		在八进制数前面显示零('0')，在十六进制前面显示'0x'或者'0X'(取决于用的是'x'还是'X')
				0		显示的数字前面填充'0'把空格换为0
				%		'%%'输出一个单一的'%'
				m.n		m 是显示的最小总宽度,n 是小数点后的位数(如果可用的话)后面必须跟上d之类的对象

				>>> "%d%d"%(64,12312)
				'6412312'

			转义字符
				使用\来进行转义，
					\b 	退格(Backspace)
					\0	空
					\n 	换行
					\v 	纵向制表符
					\t 	横向制表符
					\r 	回车
					\f 	换页
					\other 	其它的字符以普通格式输出

			原始字符串r或R
					 str='c:\now'
					 str='c:\\now'
					 str=r'c:\now\.....\.....\.....\.....\......\....'
					 str=r'c:\now\.....\.....\.....\.....\......\....\'
					 最后不能加\会报错！！！！！
					 实在要加可以拼接

			字符串内建方法
				capitalize()                                 把字符串的第一个字符改为大写
				casefold()                                   把整个字符串的所有字符改为小写
				center(width)                                将字符串居中，并使用空格填充至长度 width 的新字符串
					>>> "fsdaf".center(10)
					'  fsdaf   '
				count(sub[, start[, end]])                   返回 sub 在字符串里边出现的次数，start 和 end 参数表示范围，可选。
				encode(encoding='utf-8', errors='strict')    以 encoding 指定的编码格式对字符串进行编码。
				endswith(sub[, start[, end]])                检查字符串是否以 sub 子字符串结束，如果是返回 True，否则返回 False。start 和 end 参数表示范围，可选。
				expandtabs([tabsize=8])                      把字符串中的 tab 符号转换为空格，如不指定参数，默认的空格数是 tabsize=8。
				find(sub[, start[, end]])                    检测 sub 是否包含在字符串中，如果有则返回索引值，否则返回 -1，start 和 end 参数表示范围，可选。
				index(sub[, start[, end]])                   跟 find 方法一样，不过如果 sub 不在 string 中会产生一个异常。

				isalnum()                                    如果字符串至少有一个字符并且所有字符都是字母或数字则返回 True，否则返回 False。
				isalpha()                                    如果字符串至少有一个字符并且所有字符都是字母则返回 True，否则返回 False。
				isdecimal()                                  如果字符串只包含十进制数字则返回 True，否则返回 False。
				isdigit()                                    如果字符串只包含数字则返回 True，否则返回 False。
				islower()                                    如果字符串中至少包含一个区分大小写的字符，并且这些字符都是小写，则返回 True，否则返回 False。
				isnumeric()                                  如果字符串中只包含数字字符，则返回 True，否则返回 False。
				isspace()                                    如果字符串中只包含空格，则返回 True，否则返回 False。
				istitle()                                    如果字符串是标题化（所有的单词都是以大写开始，其余字母均小写），则返回 True，否则返回 False。
				isupper()                                    如果字符串中至少包含一个区分大小写的字符，并且这些字符都是大写，则返回 True，否则返回 False。
				join(sub)                                    以字符串作为分隔符，插入到 sub 中所有的字符之间。
					>>> "abc".join("123")
					'1abc2abc3'
				lower()                                      转换字符串中所有大写字符为小写。
				upper() 									 转换字符串中的所有小写字符为大写。
				title()										 返回标题化（所有的单词都是以大写开始，其余字母均小写）的字符串。
				ljust(width)                                 返回一个左对齐的字符串，并使用空格填充至长度为 width 的新字符串。
				rjust(width)                                 返回一个右对齐的字符串，并使用空格填充至长度为 width 的新字符串。
				lstrip(str)                                  去掉字符串左边的所有参数中的字符
				strip([chars])								 删除字符串前边和后边所有的空格，chars 参数可以定制删除的字符，可选。
				rstrip(str)                                  从右删除参数中的字符
				partition(sub)                               找到子字符串 sub，把字符串分成一个 3 元组 (pre_sub, sub, fol_sub)，如果字符串中不包含 sub 则返回 ('原字符串', '', '')
				replace(old, new[, count])                   把字符串中的 old 子字符串替换成 new 子字符串，如果 count 指定，则替换不超过 count 次。
				rfind(sub[, start[, end]])                   类似于 find() 方法，不过是从右边开始查找。
				rindex(sub[, start[, end]])                  类似于 index() 方法，不过是从右边开始。
				rpartition(sub)                              类似于 partition() 方法，不过是从右边开始查找。
				split(sep=None, maxsplit=-1)                 不带参数默认是以空格为分隔符切片字符串，如果 maxsplit 参数有设置，则仅分隔 maxsplit个子字符串，返回切片后的子字符串拼接的列表。
				splitlines(([keepends]))                     按照 ' ' 分隔，返回一个包含各行作为元素的列表，如果
				keepends 									 参数指定，则返回前 keepends 行。
				startswith(prefix[, start[, end]])			 检查字符串是否以 prefix 开头，是则返回 True，否则返回 False。start 和 end 参数可以指定范围检查，可选。
				swapcase()									 翻转字符串中的大小写。
				translate(table)							 根据 table 的规则（可以由 str.maketrans('a', 'b')
				定制）转换字符串中的字符。
					>>> "ASDasd".translate(str.maketrans("a","d"))
					'ASDdsd'
				zfill(width)								 返回长度为 width 的字符串，原字符串右对齐，前边用 0 填充。
				http://bbs.fishc.com/thread-38992-1-1.html

			注意
				5+8和‘5’+‘8’运行结果不同

			两个ASCII的函数
				ord()把字符串转换为ASCII码  chr()从ASCII码转换为字符串

		list
			定义
				[ , , , , ,]

			分片
				方法
					list[x:y:z]截取到y之前,不包含y,z是步长
					和string定义是一样的
					步长为零，不能走
					步长为负，反着走

						list1 = [1,32,32,2,5,6,7,8,4]
						>>> list1[::-2]
						[4, 7, 5, 32, 1]

				小问题
					1. 请问 list1[0] 和 list1[0:1] 一样吗？

						不一样，list1[0] 返回第0个元素的值，list1[0:1] 返回一个只含有第0个元素的列表。

					2. 分片是分出新的列表
						可以利用分片完成列表的拷贝 list2 = list1[:]，
						那事实上可不可以直接写成 list2 = list1 更加简洁呢？
						list2 = list1[:] 这是创建一个新列表赋值给list2变量，
						list2 和 list1 就不是一个内存里的值 ， 是不一样的
						而直接list2 = list1 只是给list1 列表重新定义了一个标签而已，
						list1 和 list2 实际上指的是一个内存里的值，是一样的

						>>> id(L1)
						12905128
						>>> id(L1[:])
						48174744

			向列表添加元素
				append( 元素) 在列表最后添加
				如member.append('小甲鱼')
				extend([元素，元素  ]) 在列表最后添加一个列表
				member.extend(['竹林','crazy'])
				insert(x,元素) x是索引值，索引值从零开始

			删除列表元素
				remove( 元素 )  只要知道元素是什么就行，不用知道元素位置
				如果元素在列表中有重复先删除第一个
					member.remove( )

				del  语句
					del member[x] x为元素位置
					del member 删除整个列表

				pop(x)
					x为元素索引值
					删除，并返回删除的元素,只能删除一个元素
					pop() 默认删除最后一个元素

			列表的其他内建方法
				list.count(obj)
				统计某个元素在列表中出现的次数
				list.index(obj[, begin, end])
				从列表中找出某个值第一个匹配项的索引位置
				list.reverse()
				反向列表中元素
				list.sort([func]) reverse = True
				对原列表进行排序
				list.clear()
				清空列表，但是列表变成一个空列表
				list.copy()
				复制列表 类似于 a[:]
				>>> id(L1.copy())
				12901232
				>>> id(L1[:])
				12901232
				>>> L1[:] == L1.copy()

		tuple
			元组就是不能改变元素的列表

			定义
				元组用（，）来定义
					关键是,
					tuple1 = (1) 这是int类型
					tuple1 = (1,) 这才是元组
					>>> tuple1 = 1,2,3,4  这也是个元组  只要用逗号隔开元素就是元组
					>>> tuple1
					(1, 2, 3, 4)

			分片


			添加(实质上是用切片的方式来创造一个新的元组)
				temp = ('小甲鱼', '黑夜','小布丁')
				temp = temp[:2] + ('锡业',) + temp[2:]
				>>> temp
				('小甲鱼', '黑夜', '锡业', '小布丁')

			删除
				del temp
				只能整个删除不能删除元素

			修改
				如果元组元素有可以修改的
					那就可以直接索引修改
					>>> new_courses = ('Linux', ['BigData1','BigData2','BigData3'], 'Vim')
					>>> new_courses[1] ['BigData1', 'BigData2', 'BigData3']
					>>> new_courses[1].append('BigData4')
					>>> new_courses ('Linux', ['BigData1', 'BigData2', 'BigData3', 'BigData4'], 'Vim')

			内置函数
				count(value)
					Return number of occurrences of value.
					>>> a = (3,9,2,4,5)
					>>> a.count(5)
					1
					>>> a.count(10)
					0

				index(value, start=0, stop=9223372036854775807)
					Return first index of value
					Raises ValueError if the value is not present.

			元组的骚操作
				(role,line_spoken) = each_line.split(':',1)

				元组可以直接用于format函数里
					print("Months = {} Days = {}".format(*divmod(days, 30)))

						*提取元组的内容，{}数目最好与元组元素个数一致
						*也可以提取其它可迭代的对象

						divmod(x, y, /)
							Return the tuple (x//y, x%y).

							>>> divmod(15,2)
							(7, 1)
							>>> x, y = divmod(15,2)
							>>> x
							7
							>>> y
							1

	set（集合）
		创建
			num2 = {1,2,3,4,5}#直接创建

			创建一个空集合只能用set创建
				>>> a = {}
				>>> type(a)
				<class 'dict'>
				>>> a = set()
				>>> type(a)
				<class 'set'>

		唯一性
			集合几乎所有的作用就是确保里边包含的元素的唯一性，就像世界上没有两片完全相同的树叶一样，集合内不可能存在两个相同的元素！
			>>> num2 = {1,2,3,4,5,6,7,8,7,6,5,4,3,2,1}
			>>> num2
			{1, 2, 3, 4, 5, 6, 7, 8}	#重复的元素会被删除，只能存在一个

			删除列表重复的元素
			>>> num1 = list(set([1,2,3,4,5,6,7,2,3,4,5,0]))
			>>> num1
			[0, 1, 2, 3, 4, 5, 6, 7]#利用集合的唯一性删除重复元素
			注意 0到前面去了，因为set是无序的，所以list后的顺序可能会改变，所以如果程序关注列表中元素的顺序，需要注意这个细节！

		无序性
			不能试图去索引集合的某个元素
			>>> num2[2]
			Traceback (most recent call last):
			  File "<pyshell#6>", line 1, in <module>
				num2[2]
			TypeError: 'set' object does not support indexing
			不支持索引集合

			因为set和dict都是用散列函数来算出对应内存地址

		集合元素性质
			元素只能是不可变量
			数字，字符串，元组
				想添加集合为元素
				>>> a.add(frozenset(set()))
				>>> a
				{1, frozenset()}
				>>> a.add("")
				>>> a
				{'', 1, frozenset()}
				>>> a.add(4564)
				>>> a
				{'', 1, 4564, frozenset()}

		删除和添加元素
			.add(元素)
			>>> num2.add(6)
			>>> num2
			{1, 2, 3, 4, 5, 6}
			.remove（元素）
			>>> num2.remove(3)
			>>> num2
			{1, 2, 4, 5, 6}

		对集合的常见操作
			>>> # 演示对两个单词中的字母进行集合操作 ...
			>>> a = set('abracadabra')
			>>> b = set('alacazam')
			>>> a # a 去重后的字母
			{'a', 'r', 'b', 'c', 'd'}
			>>> a - b # a 有而 b 没有的字母
			{'r', 'd', 'b'}
			>>> a | b # 存在于 a 或 b 的字母
			{'a', 'c', 'r', 'd', 'b', 'm', 'z', 'l'}
			>>> a & b # a 和 b 都有的字母
			{'a', 'c'}
			>>> a ^ b # 存在于 a 或 b 但不同时存在的字母
			{'r', 'd', 'b', 'm', 'z', 'l'}

		不可变集合
			frozenset(集合)
				创建一个不可集合
					>>> num3 = frozenset([1,2,3,4,5,6,0])
					>>> num3
					frozenset({0, 1, 2, 3, 4, 5, 6})
					>>> num3.add(7)
					Traceback (most recent call last):
					  File "<pyshell#23>", line 1, in <module>
						num3.add(7)
					AttributeError: 'frozenset' object has no attribute 'add'

		集合的内建方法
				集合（s）.方法名					等价符号					方法说明
				s.issubset(t)						s <= t 			子集测试（允许不严格意义上的子集）：s 中所有的元素都是 t 的成员
													s < t 			子集测试（严格意义上）：s != t 而且 s 中所有的元素都是 t 的成员
				s.issuperset(t)						s >= t 			超集测试（允许不严格意义上的超集）：t 中所有的元素都是 s 的成员
													s > t 			超集测试（严格意义上）：s != t 而且 t 中所有的元素都是 s 的成员
				s.union(t)							s | t 			合并操作：s "或" t 中的元素
				s.intersection(t)					s & t 			交集操作：s "与" t 中的元素
				s.difference						s - t 			差分操作：在 s 中存在，在 t 中不存在的元素
				s.symmetric_difference(t)			s ^ t 			对称差分操作：s "或" t 中的元素，但不是 s 和 t 共有的元素
				s.intersection_update(t)			s &= t 			交集修改操作：s 中仅包括 s 和 t 中共有的成员
				s.difference_update(t)				s -= t 			差修改操作：s 中包括仅属于 s 但不属于 t 的成员
				s.symmetric_difference_update(t)	s ^= t 			对称差分修改操作：s 中包括仅属于 s 或仅属于 t 的成员


				s.copy()											返回 s 的拷贝（浅复制）
				s.update							s |= t 			将 t 中的元素添加到 s 中
				s.add(obj)											加操作：将 obj 添加到 s
				s.remove(obj)										删除操作：将 obj 从 s 中删除，如果 s 中不存在 obj，将引发异常
				s.discard(obj)										丢弃操作：将 obj 从 s 中删除，如果 s 中不存在 obj，也没事儿^_^
				s.pop()												弹出操作：移除并返回 s 中的任意一个元素
				s.clear()											清除操作：清除 s 中的所有元素

	Dictionary（字典）
		映射
			字典是映射类型，不是序列

		创建
			一般创建
				name = { ’key‘ : value,}用大括号

			key
				可以是字符串也可以是数字

			特殊创建
				转换创建
					dict(映射类型的参数)
						dict3 = dict((('F',70),('i',105),('s',115),('h',104),('c',67)))
						c = dict(zip(['one', 'two', 'three'], [1, 2, 3]))
						只要是可迭代的满足以上格式的，都可以

				关键字创建
					dict4 = dict(小甲鱼 = '让编程改变世界',苍井空 = '让AV征服所有宅男')#这里key不能打引号

			访问
				name[key] key可以是很多种类的数据

		修改（修改）
			dict4['小甲鱼'] = '所有AV从业者需要通过学习来提高职业技能'#关键字修改

		添加（添加）
			dict4['天才'] = '100'，添加和赋值操作差不多

		删除
			del a["key"]

		内建方法
			.keys() 返回所有的关键字
				>>> name.keys()
				dict_keys(['x', 's', 'sss'])#返回的数据
				>>> for eachkey in dict1.keys():#这里可以体现.keys()返回的结果是一个可迭代的数据
					print(eachkey,end = '，')
					0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,

			.values（） 每一个值，与.keys()结果相似
					>>> for eachvalue in dict1.values():
					print(eachvalue,end = ',')

					赞,赞,赞,赞,赞,赞,赞,赞,赞,赞,赞,赞,赞,赞,赞,赞,赞,赞,赞,赞,赞,赞,赞,赞,赞,赞,赞,赞,赞,赞,赞,赞,

			.items() 每一个项
					>>> for eachitem in dict1.items():
							print(eachitem,end = ',')
					(0, '赞'),(1, '赞'),(2, '赞'),(3, '赞'),(4, '赞'),(5, '赞'),(6, '赞'),(7, '赞'),(8, '赞'),(9, '赞'),(10, '赞'),(11, '赞'),(12, '赞'),(13, '赞'),(14, '赞'),(15, '赞'),(16, '赞'),(17, '赞'),(18, '赞'),(19, '赞'),(20, '赞'),(21, '赞'),(22, '赞'),(23, '赞'),(24, '赞'),(25, '赞'),(26, '赞'),(27, '赞'),(28, '赞'),(29, '赞'),(30, '赞'),(31, '赞'),

			.get(key[,没有该关键字的返回值]) 访问字典
					>>> print(dict1.get(32))
					None#没有就会返回这个
					>>> print(dict1.get(11))
					赞

			.clear() 清空列表
					>>> dict1.clear()
					>>> dict1
					{}
					两种不同清空的方法
						>>> a =  {'姓名':'小甲鱼'}
						>>> b = a
						>>> a.clear()
						>>> a
						{}
						>>> b
						{}

						>>> a =  {'姓名':'小甲鱼'}
						>>> b = a
						>>> a = {}
						>>> a
						{}
						>>> b
						{'姓名': '小甲鱼'}
					推荐用.clear() 因为赋值的方法只是改变a映射的方向，并没有改变字典的值

			.copy() 浅拷贝
				浅拷贝和深拷贝 浅拷贝是申请新内存，深拷贝没有，地址都是一样的
					>>> a = {'哈哈':'123'}
					>>> b = a
					>>> c = a.copy()
					>>> a
					{'哈哈': '123'}
					>>> b
					{'哈哈': '123'}
					>>> c
					{'哈哈': '123'}
					>>> id(a)
					2735285751744
					>>> id(b)
					2735285751744#这是深拷贝
					>>> id(c)
					2735286329992#这是浅拷贝
					>>> b[4] = '45'
					>>> a
					{'哈哈': '123', 4: '45'}#深拷贝时，改变值是能改变之前的对象的
					>>> b
					{'哈哈': '123', 4: '45'}
					>>> c
					{'哈哈': '123'}			#浅拷贝就不会

			.pop(key) 删除一组关键字和值
				>>> a.pop(4) 删除给定key并弹出对应的值
				'45'
				>>> a
				{'哈哈': '123'}

			.popitem()	随机删除一组关键字和值，字典是没有顺序的
				>>> a = {1:'123',2:'456'}
				>>> a.popitem()
				(2, '456')

			.setdefault() 返回key的值，如果没有该key可以自动添加#这个很好用要记住！！！！！！！！！！！！！！！！
				>>> a.setdefault(6,'six')
				'six'#没有就添加值是设置的vlaue
				>>> a.setdefault(1)
				'123'#有就返回value
				>>> a.setdefault(9)
				>>> a #没有设置value，值就为None
				{1: '123', 6: 'six', 9: None}

			.update()	用字典或者映射关系去更新另一个字典
				>>> b = {'小白':'狗'}
				>>> a.update(b)
				>>> a
				{1: '123', 6: 'six', 9: None, '小': '白', '小白': '狗'}

		dict是如何储存
			http://bbs.fishc.com/thread-45016-1-1.html
			1.0 和 1 经过散列函数后变换的数字指纹是一样的（换句话来说就是内存地址是一样的）
			>>> dict1[1] = 1
			>>> dict1
			{'a': 1, 1: 1, 3: 4}
			>>> dict1[1.0] = 2
			>>> dict1
			{'a': 1, 1: 2, 3: 4}

	迭代器
		函数实现
			iter()
				生成迭代器
				__iter__(self)
			next()
				返回迭代对象
				__next__()
			>>> string = "asdfsdfsdf"
			>>> it = iter(string)
			>>> next(it)
			'a'
			>>> next(it)
			's'
			>>> next(it)
			'd'
			>>> next(it)
			'f'
			>>> next(it)
			's'
			>>> next(it)
			'd'
			>>> next(it)
			'f'
			>>> next(it)
			's'
			>>> next(it)
			'd'
			>>> next(it)
			'f'
			>>> next(it)
			Traceback (most recent call last):
			  File "<pyshell#12>", line 1, in <module>
				next(it)
			StopIteration

		魔法方法实现
				>>> class Test:
				... 	def __init__(self, a, b):
				... 		self.a = a
				... 		self.b = b
				... 	def __iter__(self):
				... 		return self
				... 	def __next__(self):
				... 		self.a += 1
				... 		if self.a > self.b:
				... 			raise StopIteration()
				... 		return self.a
				... >>> test = Test(0, 5) # Test 类的实例就是迭代器
				>>> next(test)
				1
				>>> next(test)
				2



		斐波那契数列
			>>> class Fibs:
				def __init__(self, n = 10):
					self.a = 0
					self.b = 1
					self.n = n
				def __iter__(self):
					return self
				def __next__(self):
					self.a,self.b = self.b ,self.a + self.b
					if self.a > self.n:
						raise StopIteration
					return self.a


			>>> a = Fibs()
			>>> for each in a:
				print(each)


			1
			1
			2
			3
			5
			8

		生成器
			生成器也是一种迭代器
				这玩意是可以用for 来迭代的，每次迭代的值就是yield 返回的值

			协同程序就是可以运行的独立函数调用，函数可以暂停或者挂起，并在需要的时候从程序离开或者重新开始
			yield 相当于函数的return 语句，但是普通函数一返回这个函数就结束，生成器不会，只会返回yield后的值再暂停！
				>>> def myGen():
					print("生成器被执行！")
					yield 1
					yield 2
				>>> a = myGen()
				>>> next(a)
				生成器被执行！
				1
				>>> next(a)
				2
				>>> next(a)
				Traceback (most recent call last):
				  File "<pyshell#9>", line 1, in <module>
					next(a)
				StopIteration

	各种推导式
		列表推导式
			a = [i for i in range(100)if not (i%2) and i%3]

		嵌套列推导式
			matrix=[
				[1,2,3,4],
				[5,6,7,8],
				[9,10,11,12]

			]
			c = [[row[i] for row in matrix] for i in range(4)]
			print(c)
			[[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]

		字典推导式
		>>> d = {'a': 1, 'b': 2, 'c': 3}
		>>> {k:v*v for k, v in d.items()}
		{'a': 1, 'b': 4, 'c': 9}

		集合推导式
			c = {i for i in [1,1,2,3,4,5,5,6,7,8,3,2,1]}

		没有字符串推导式没有元组推导式

		生成器推导式
			d = (i for i in range(10))

			作为函数参数可以不加括号直接使用
			f = sum(i for i in range(100) if 1 % 2)

			print(f)

			当然加括号也是能用的
				f = sum((i for i in range(100) if 1 % 2))

Python的操作符
	算数运算符
		+ 加法
		- 减法
		* 乘法
		/ 除法 结果是浮点数
		// floor 除法  把小数去掉，取整！
		% 取余
		** 幂运算 x**y x的y次方
			优先级   前后是一元运算符比前一个比后一个低 如- 3 ** 2 = -9 实际上是-（3 ** 2）
						3 ** -2  = 0.11111111111  实际上是3 ** （-2）

	复合运算符
		+= -= %= *= /= **= //=

	比较（关系）运算符
		> 大于
		<小于
		>=大等
		<=小等
		==等于
		!=不等于

	逻辑运算符
		 or and not 或与非

		优先级
			not > and >or

		短路逻辑
			a and b  如果a 是False 直接返回 a；如果是True 直接返回b

			a or b   如果a 是False 直接返回 b；如果是True 直接返回a

			>>> 1 and 6
			6
			>>> 2 or 9
			2
			>>> 0 and 6
			0
			>>> 0 or 9
			9

			一个有趣的小例子
				>>> a = 100
				>>> b = 200
				>>> a and b == 100
				False
				>>> a and b == 200
				True
				>>> a or b == 100
				100
				>>> a or b == 200
				100

		谁是True谁是False
			只有以下内容会被看作假（注意冒号括号里边啥都没有，连空格都不要有！）：False 、None、 0、 ""、 ''、 ()、 []、 {}

			其他一切被解释为真

			在短路逻辑中，会被当成假不是表示返回值的时候是假的！

			一个小例子
				while '':
					print('进入循环')
				print('退出循环')

	成员运算符
		in
		如果在指定的序列中找到值返回 True，否则返回 False。
		x 在 y 序列中 , 如果 x 在 y 序列中返回 True。

		not in
		如果在指定的序列中没有找到值返回 True，否则返回 False。
		x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。

	赋值（简写）运算符
		+=  a += 1 相当于 a = a + 1 下面如此
		-=
		*=
		/=
		%=
		**=
		//=

	位运算符
		二进制的位运算符号
		& 与运算 双1等1，不然等0
		| 或运算 有1等1，不然等0
		^ 异或运算 两者不同为1，不然等0
		~ 取反运算符 在二进制中把0变1 把1变0
		>>  n >> x   n向右移x位,低位丢弃，高位补齐
		<<  n << y   n向左移y位,高位丢弃，低位补齐

	身份运算符
		is
			测试对象身份（也就是内存地址，严格意义上的相等）,测试引用的指针
			类似的==只是值是否相等，不关心引用的对象是否相等，是不严谨的相等

		not is

	Python运算符的优先级
		** 			指数 (最高优先级)
		~ + - 		按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@)
		* / % // 	乘，除，取模和取整除
		+ - 		加法减法
		>> << 		右移，左移运算符
		& 	位 'AND'
		^ | 		位运算符
		<= < > >= 	比较运算符
		<> == != 	等于运算符
		= %= /= //= -= += *= **= 	赋值运算符
		is is not 	身份运算符
		in not in 	成员运算符
		not or and 	逻辑运算符

		其实是没必要背的，你需要的是用（）来表示谁先
		（）内的优先级最高

循环分支
	分支
		不同结构运行时间对比
			if
			elif
			时间比

			if
			if
			要短

		条件表达式（三元操作符）
			语法
				x if 条件 else y
				x < y  smart = x  否则 smart = y
			smart = x if x < y else y

			>>> a = 1 if 1>0 else 9
			>>> a
			1
			>>> a = 1 if 1<0 else 9
			>>> a
			9


			# if x < y:
				# small = x
				# if z < small:
					# small = z
			# elif y < z:
				# small = y
			# else:
				# small = z
			# 相当于
			# small = x if (x < y and x < z) else (y if y < z else z)

		检测真值的优雅方式是这样的：
			if x:
				pass

			不要像下面这样做：

			if x == True:
				pass

	循环
		while 条件：
			 ture循环操作

		for循环
			格式
				for 目标 in 迭代对象：
					循环体
				Python for循环可以遍历任何序列的项目，如一个列表或者一个字符串。
				必须是一个可迭代的对象，不然会TypeError的错误

				languages = ["C", "C++", "Perl", "Python"]

				for x in  languages:
					print (x)

				结果 C
					 C++
					 Perl
					 Python

			基友range([start,] stop[, step])
				参数说明：
					start: 计数从 start 开始。默认是从 0 开始。例如range（5）等价于range（0， 5）;
					stop: 计数到 stop 结束，但不包括 stop。例如：range（0， 5） 是[0, 1, 2, 3, 4]没有5
					step：步长，默认为1。例如：range（0， 5） 等价于 range(0, 5, 1)

				def power(x, y):
				result = 1
				for i in range(y):
					result *= x

				return result
				print(power(2, 3))

		pass 语句

			Python pass是空语句，是为了保持程序结构的完整性。

			pass 不做任何事情，一般用做占位语句，如下实例
			实例
			>>>while True:
			...     pass  # 等待键盘中断 (Ctrl+C)

		break
			跳出循环
			只能跳出一重循环
			break 任何循环都能跳出来

		continue
			continue	跳出循环体后剩下的语句不执行直接重新开始循环体,
			开始循环体之前先判断是否满足循环条件，满足继续循环，如果不满足跳出循环

		else语句
			要么怎样，要么不怎么样：if else语句

			while（for） else 语句
				也就是说必须把循环完整执行完，不然不会执行else , 中途break的话也是不会执行else语句的

				>>> for i in range(9):
						print(i)
					else:
						print("haha")

				0
				1
				2
				3
				4
				5
				6
				7
				8
				haha

				>>> for i in range(9):
					print(i)
					if i==7:
						break
					else:
						print("haha")

				0
				1
				2
				3
				4
				5
				6
				7

			try else 语句
				没问题才执行else
					>>> try:
						print(1)
					except:
						print(2)
					else:
						print("2222")


					1
					2222

				有问题不执行
					>>> try:
						print(a)
					except:
						print(2)
					else:
						print("2222")


					2

函数
	创建
		def 函数名(参数):
			..................................
			>>> def a():
			print("你好")

			>>> a()
			你好
			使用函数，向上查该函数定义

	return
		如果函数没有设置返回值，Python会返回一个None
			>>> def hello():
				print('64654')


			>>> temp = hello()
			64654
			>>> temp
			>>> print(temp)
			None
			>>> type(temp)
			<class 'NoneType'>

	五种参数
		必选参数
			注意需要按照定义顺序输入参数

			def xx(name,word):
					print(name + '->'+word)
			>>> xx('凯凯','我最牛逼')
					凯凯->我最牛逼
			>>> xx('我最牛逼','凯凯')
					我最牛逼->凯凯
			>>> xx(word = '我最牛逼',name = '凯凯')
					凯凯->我最牛逼

		默认参数
			定义
				>>> def xx(name = 'kaikai',word = '我最牛逼'):
						print(name + '->'+word)

				>>> xx()
						kaikai->我最牛逼
				>>> xx('苍井空')
						苍井空->我最牛逼

			顺序
				第一个是具有默认值的参数后面不能再有必选参数，比如 f(a,b=90,c) 就是错误的。

			必须是不可变类型
				第二个是默认值只被赋值一次，因此如果默认值是任何可变对象时会有所不同，比如列表、字典或大多数类的实例。
				例如，下面的函数在后续调用过程中会累积（前面）传给它的参数:

					>>> def f(a, data=[]):
					...     data.append(a)
					...     return data
					...
					>>> print(f(1))
					[1]
					>>> print(f(2))
					[1, 2]
					>>> print(f(3))
					[1, 2, 3]

					要避免这个问题，你可以像下面这样：

					>>> def f(a, data=None):
					...     if data is None:
					...         data = []
					...     data.append(a)
					...     return data
					...
					>>> print(f(1))
					[1]
					>>> print(f(2))
					[2]

					注意默认参数最好定义在可变参数后面，
					不然可变参数收集的第一个参数就会被赋值到默认参数
					就算按照默认参数、可变参数顺序定义，在使用函数
					默认参数赋值会出现输入错误的bug
					so最好放后面

		可变参数列表
			形式
				>>> def test(*params):#用*这个标识可变参数，参数可以有非常多个 可变参数是元组形式
				print('参数的长度是',len(params))

				print('第二个参数是',params[1])

			收集
				>>> def test(*params,dsp):
						  print('参数的长度是',len(params))
						  print('第二个参数是',params[1])

				>>> test(1,'小甲鱼',5.6,4,5,6,2,dsp = 8)
						参数的长度是 7
						第二个参数是 小甲鱼

		解析包参数列表
			传入数量和形式
				关键字参数允许传入零个或任意多个带参数名的参数，其中参数名可自定义，
				这些关键字参数会在函数内部自动生成一个字典，用来扩展函数的功能

			使用
				function(**kw)
					key必须是str
				或者
				function(key1 = "a", key2 = "b")

			和可变参数的使用
				>>> def connect(ipaddress, *ports, **kw):
					print("IP: ", ipaddress)
					print(ports)
					print(kw)
					for port in ports:
						print("Port: ", port)
					for key, value in kw.items():
						print('{}: {}'.format(key, value))

				>>> connect(i,*p,**kw)
				IP:  192.168.1.1
				(25, 26, 27)
				{'device': 'eth0', 'proto': 'static'}
				Port:  25
				Port:  26
				Port:  27
				device: eth0
				proto: static

				>>> connect(i,p,kw)
				IP:  192.168.1.1
				((25, 26, 27), {'device': 'eth0', 'proto': 'static'})
				{}
				Port:  (25, 26, 27)
				Port:  {'device': 'eth0', 'proto': 'static'}

				需要注意的是两种输入是不同的，第一种是正常标准输入，第二种是把两种参数都当收集参数了

	函数中修改参数值
		Python 中的对象有不可变对象，指的是数值、字符串、元组等，和可变对象，指的是列表、字典等。
		如果是不可变对象作为参数，函数中对该参数的修改只能用等号赋值，实际上是创建了一个新的局部变量。
		如果是可变对象作为参数，函数中的修改会保留。

		def a1(a,b=[]):
	    b.append(a)
	    print(b)
		a1(1)
		a1(2)

		[1]
		[1, 2]


	函数文档
			设置
				>>> def mm():
					'你是最牛逼的人'#这个就是函数文档

			查看
				>>> mm.__doc__#查看文档用.__doc__  记住哦，前后是两个下划线

					'你是最牛逼的人'
				当然用doc来查看文档是不方便的，所以一般用的是help（函数名）来查看

	函数变量的作用域
		局部变量
			在函数中定义的参数、以及变量被称作为局部变量，作用于函数内

		全局变量
			在函数外定义，作用于整个程序
			如果在函数内修改全局变量，Python会自动生成一个一摸一样局部变量，和之前全局变量相互不影响
			最好不要在函数内修改全局变量

		修改全局变量
			一般在函数中引用全局变量是会报错的
				>>> a = 100
				>>> def b(num):
					print("尝试打印全局",a)
					a = 1
					print("尝试去修改全局",a)


				>>> b(a)
				Traceback (most recent call last):
				  File "<pyshell#6>", line 1, in <module>
					b(a)
				  File "<pyshell#5>", line 2, in b
					print("尝试打印全局",a)
				UnboundLocalError: local variable 'a' referenced before assignmen

			但是如果只修改的话
				>>> a = 100
				>>> def b(num):
					#print("尝试打印全局",a)
					a =  1
					print("尝试去修改全局",a)


				>>> b(a)

			尝试去修改全局
				如果在函数内部直接修改全局变量，会自动创建一个局部变量（名字与全局变量名相同），
				但不建议这样做，因为会出现很多意想不到的bug

			如果想在函数中直接修改全局变量是可以用global 关键字
				例如
					def Myfun():
						global court#就是这里，必须先声明，我要改全局变量了！！！
						court = 10
						print("修改后",court)

					court = 1
					print("还未修改",court)
					Myfun()
					print("验证是否修改成功",court)


					还未修改 1
					修改后 10
					验证是否修改成功 1

		尽量不使用全局变量
			a) 代码可读性变差
			b) 代码安全性降低

	高阶函数（Higher-order function）或仿函数（functor）是内部至少含有一个以下步骤的函数：

		使用一个或多个函数作为参数
		返回一个函数作为输出

		Python 里的任何函数都可以作为高阶函数。

		>>> def high(func, value):
		...     return func(value)
		...
		>>> lst = high(dir, int)
		>>> print(lst[-3:])
		['imag', 'numerator', 'real']

	内嵌函数（内部函数）
		概念
			只能在函数（father）内部调用内部函数（son）
				>>> def fun1():
							print('fun1()正在被调用')
								def fun2():
									print('fun2()正在被调用')
							fun2()

		修改外部函数的局部变量
			在嵌套的函数中，如果希望在内部函数修改外部函数的局部变量
			用nonlocal
				def Fun1():
					x = 5
					print(x)
					def Fun2():
							nonlocal x
							x *= x
							print(x)

					Fun2()
					print("验证是否修改成功",x)
				Fun1()

				结果：
					5
					25
					验证是否修改成功 25

		内嵌函数的调用
			嵌套函数只能在被定义的函数中调用

			这样调用时会报错的
				def outside():
					print('I am outside!')
					def inside():
						print('I am inside!')

				inside()

			应该这样调用
				def outside():
					print('I am outside!')
					def inside():
						print('I am inside!')
					inside()
				outside()

			或者这样调用
				def funOut():
					def funIn():
						print('宾果！你成功访问到我啦！')
					return funIn
				funOut()()

				宾果！你成功访问到我啦！

			也可以曲线救国
				go = funOut()
				go()
				宾果！你成功访问到我啦！

		闭包
			函数式编程
			如果在一个内部函数里，对外部作用域但不是在全局作用域的变量进行引用，内部函数就会被定义为闭包

			如果要修改嵌套作用域（enclosing 作用域，外层非全局作用域）中的变量则需要 nonlocal 关键字了
				>>> def fun1():
					x = 5
						def fun2():
							nonlocal x
							x *= x
							return x
					return fun2()
			a = fun2()
				这个是闭包的精髓

	匿名函数
		格式
			Lambda 参数 ：返回值 [可以加if语句什么的]

			lambda x : 2 * x + 1
			相当于
			def ds(x):
				return 2 * x + 1

		调用
			g = lambda x : 2 * x + 1
			g（5）

		一个很瞎逼的例子
			>>> def make_repeat(n):
				return lambda s : s * n

			>>> a = make_repeat(2)
			>>> print(a(8))
			16
			>>> print(a("shi"))
			shishi
			>>>

		可设置条件
			lambda x : x if x%3 == 0 else None#else None 必须跟上，不然会报错，None可以被替换而值
			>>> list(filter(lambda n : not(n%3), range(1, 100)))
				[3, 6, 9, 12, 15, 18, 21, 24, 27, 30, 33, 36, 39, 42, 45, 48, 51, 54, 57, 60, 63, 66, 69, 72, 75, 78, 81, 84, 87, 90, 93, 96, 99]
			>>> list(filter(lambda n : n%3, range(1, 100)))
				[1, 2, 4, 5, 7, 8, 10, 11, 13, 14, 16, 17, 19, 20, 22, 23, 25, 26, 28, 29, 31, 32, 34, 35, 37, 38, 40, 41, 43, 44, 46, 47, 49, 50, 52, 53, 55, 56, 58, 59, 61, 62, 64, 65, 67, 68, 70, 71, 73, 74, 76, 77, 79, 80, 82, 83, 85, 86, 88, 89, 91, 92, 94, 95, 97, 98]
			not（n%3）和n%3  两者类似于一种if语句一样的存在

	filter(function or None , iterable)
			是把非True的内容过滤掉
				意思就是，把迭代对象输入函数，看函数的返回值是否是True，如果是非True就直接过滤，如果是True就保留迭代对象值
			a = [1,2,3,4,5]

		　　list(filter(lambda x:x>2,a))

		　　输出结果为: [3,4,5]

	map（function,[可迭代对象]）
		把所有可迭代对象全部进行function加工，全部加工完成后，全部返回新的可迭代对象
		一般的数据参数
			得用list显示
				>>> a = map(lambda x : x*2 ,range(10))
				>>> list(a)
				[0, 2, 4, 6, 8, 10, 12, 14, 16, 18]

			强大的map()后边是可以接受多个序列作为参数的。
				>>> list(map(lambda x, y : [x, y], [1, 3, 5, 7, 9], [2, 4, 6, 8, 10]))
				[[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]]

		函数对象参数
			def m(x):
				return(x*x)

			def add(x):
				return(x+x)

			func = [m, add]

			for i in range(5):
				value = map(lambda x: x(i), func)

				print(list(value))

			结果
				[0, 0]
				[1, 2]
				[4, 4]
				[9, 6]
				[16, 8]

文件
	打开文件
		open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)
		    'r'       open for reading (default) 										只读，真的只能读文件
			'w'       open for writing, truncating the file first 						覆盖以前写过的文件
			'x'       create a new file and open it for writing							如果文件存在，会报错
			'a'       open for writing, appending to the end of the file if it exists 	续写
			'b'       binary mode														二进制模式打开
			't'       text mode (default)												以文本模式打开
			'+'       open a disk file for updating (reading and writing)				可读写模式（可添加到其他模式中使用）
			'U'       universal newline mode (deprecated) 								通用换行符支持
					  mode U cannot be combined with x', 'w', 'a', or '+'

		编码
			encoding='utf-8'！！！！！！！！！！！！！！！！！！！！！
			>>> f = open('D:\\1.txt')
			<_io.TextIOWrapper name='D:\\1.txt' mode='r' encoding='cp936'>

	读取
		>>> for i in f :
		print(i)#这个也是官方推荐的方式

	文件的内置方法
		文件对象方法
		f.close() 关闭文件，关闭文件是一个很好的习惯

		f.read(size = 1) 读取size个字符，不设置size会从文件指针开始，剩下的全部读出
			>>> f.read()
			'python 面向对象程序语言\nIDLE 是文本交互框\nprint（） 打印函数\n*\n‘i love fishc.com\'是字符串  而5是整形  两者不是一种类型的数据类型\n\\"\n\n23互不兼容\n\n>>> 5+8\n13\n>>> print(5+8)\n13\n31536000'
			>>> f.read()
			''#文件指针在最后了
			文件指针（文件的书签）
		f.tell() 返回文件指针的位置
			>>> f.tell()
			196

		f.seek(offset,from) from = 0 起始，1 指针位置，2 文件尾部 右移offset个字节的偏移
			>>> f.tell()
			196
			>>> f.seek(0,0)
			0
			>>> f.tell()
			0

		对于文件指针应用
			name1 = input('请输入需要比较的头一个文件名：')
			name2 = input('请输入需要比较的另一个文件名：')
			different = []

			f1 = open(name1)
			f2 = open(name2)
			count = 0
			for each_line in f1:
				if each_line != f2.readline():#f2.readline() f2的文件指针指向的行数和f1的行数是相同的
					count += 1
					different.append(count)
				else:
					count += 1
			f1.close()
			f1.close()
			if count ==0:
				print('两个文件相同')
			else:
				print('一共有%d不一样'%len(different))
				for each in different:
					print('第%d行不一样'%each)
			#用different长度表示几个不同，用different的元素来表示第几行不同

		f.readline()
			读取一行文字
			>>> f.readline()
			'python 面向对象程序语言\n'

		f.readlines()
			读取所有行文字

		f.writelines(字符串序列)
			如果是写入文件一定要确保打开模式是a或者w

		f.write(字符串)

		f.truncate（）
			除了截取部分都删除，默认截取当前指针位置，对文件内容进行操作

	locals()
		返回包含当前作用域局部变量的字典。

		if 'f' in locals(): # 如果文件对象变量存在当前局部变量符号表的话，说明打开成功
			f.close()

	with语句
		懒人打开文件大法好

		with open(A) as a, open(B) as b:
			suite

		使用 with 语句固然方便，但如果出现异常的话，文件还会自动正常关闭吗？
			答：with 语句会自动处理文件的打开和关闭，如果中途出现异常，会执行清理代码，然后确保文件自动关闭

异常检测
	try:
		 raise xxxxxxError(xxx,xxxx)

	except xxxxxError as error :
		xxxxxx
	else:
		xxxxxxx
	finally:
		xxxxxxxxxxx

	语句结构
		try:
			检测范围#检测到哪里有错误，那么剩下的语句将不会被执行

		except Exceotion[as reason]:
			可以多个except,也可以except (错误1，错误2)#也一次添加多个错误

			利用多个 except 语句可以分别捕获并处理我们感兴趣的异常

			except: 这个语句后不写任何参数，表示将处理所有 try 代码块中抛出的异常。

		finally:
			出不出错都可以执行的语句

		几个例子
			try:
				f = open('我为什么是个文件.txt')
				f.close()
			except OSError as reason:#错误原因！！！
				print('文件出错了！！\n错误原因是：'+str(reason))#必须强制转换为字符串

			尝试关闭一个不存在的文件是会报错的
			try:
				f = open('My_File.txt') # 当前文件夹中并不存在"My_File.txt"这个文件T_T
				print(f.read())
			except OSError as reason:#as后面的是报错具体信息
				print('出错啦：' + str(reason))
			finally:
			f.close()

			修改方法
				try:
					f = open('My_File.txt') # 当前文件夹中并不存在"My_File.txt"这个文件T_T
					print(f.read())
				except OSError as reason:
					print('出错啦：' + str(reason))
				finally:
					if 'f' in locals(): # 如果文件对象变量存在当前局部变量符号表的话，说明打开成功
						f.close()

	自定义异常
		raise 错误名字[（'可以显示的东西哦！！'）]
			>>> raise OSError('我错了')
			Traceback (most recent call last):
			  File "<pyshell#0>", line 1, in <module>
				raise OSError('我错了')
			OSError: 我错了

			执行raise后,H之后的语句不会被执行

		断言
			assert 条件
				当条件为假的时候会抛出AssertionError的异常
				>>> assert 3 > 4
				Traceback (most recent call last):
				  File "<pyshell#7>", line 1, in <module>
					assert 3 > 4
				AssertionError
				用于程序员自检程序时使用

面向对象和类
	Python 作用域和命名空间
		每次运行至少有三个命名空间
			外  内置命名 3
			中	同级函数 2
			内	局部命名 1

		global 语句用以指明某个特定的变量为全局作用域，并重新绑定它。
			不管在哪里你都能用
		nonlocal 语句用以指明某个特定的变量为封闭作用域，并重新绑定它。
			只能在类似函数的函数里用

		例子
			def scope_test():
				def do_local():
					spam = "local spam"
				def do_nonlocal():
					nonlocal spam
					spam = "nonlocal spam"
				def do_global():
					global spam
					spam = "global spam"
				spam = "test spam"
				do_local()
				print("After local assignment:", spam)
				do_nonlocal()
				print("After nonlocal assignment:", spam)
				do_global()
				print("After global assignment:", spam)

			scope_test()
			print("In global scope:", spam)

		结果
			After local assignment: test spam
			After nonlocal assignment: nonlocal spam
			After global assignment: nonlocal spam
			In global scope: global spam

	类定义
		大写字母开头
		类是为它全部对象给出了统一的定义，它的每个对象是符合这种定义的实体
		class Turtule:
			color = 'green'
			leg = 4
			def go(self):
				print('跑呀跑')
			def leg_num(self):
				print('我有四条腿')

	类对象
		属性引用
			class MyClass:
				"""A simple example class"""
				i = 12345
				def f(self):
					return 'hello world'

			print(MyClass.i,MyClass.f)

		__doc__
			类的简单描述，一般都有这个属性，可以像上面一样被引用

		实例化
			变量名 = 类名([xx])

			>>> class Complex:
			...     def __init__(self, realpart, imagpart):
			...         self.r = realpart
			...         self.i = imagpart
			...
			>>> x = Complex(3.0, -4.5)
			>>> x.r, x.i
			(3.0, -4.5)

		两种魔法方法
			__init__(self)构造函数，生成对象时调用，初始化属性！！！

			def __repr__(self):
					return 'Test: {}'.format(self.name) # 自定义打印格式

	实例对象
		引用属性
			x = MyClass()
			x.i

		引用方法
			x.f()

	方法对象
		class MyClass:
			"""A simple example class"""
			i = 12345
			def f(self):
				return 'hello world'

		x = MyClass()
		x.f#这就是方法对象

	self
		def f(self):
		#实例对象作为函数的第一个参数传给了函数

		x.f() 相当于MyClass.f(x)

		self在使用的时候可以调用实例对象的内部属性
			class Bag:
				def __init__(self):
					self.data = []
				def add(self, x):
					self.data.append(x)
				def addtwice(self, x):
					self.add(x)
					self.add(x)

模块
	命名空间
		>>> import hello
		>>> hello.hi()
		hello word

		这里hello 就是命名空间，不然python不知道调用哪个模块的hi()函数

	导入模块
		import partname

		from 模块名 import 函数
			>>> from hello import hi
			>>> hi()
			hello word
			不建议用这种方法,用这种方法就让命名空间的优势荡然无存

		隐私属性
			曾经我们讲过有办法阻止 from…import * 导入你的“私隐”属性，你还记得是怎么做的吗？
				答：如果你不想模块中的某个属性被 from…import * 导入，那么你可以给你不想导入的属性名称的前边加上一个下划线（_）。
				不过需要注意的是，如果使用 import … 导入整个模块，或者显式地使用 import xx._oo 导入某个属性，那么这个隐藏的方法就不起作用了
			    # test.py
				from a import sayHi
				from b import sayHi

				sayHi()
				会打印“嗨，我是 B 模块~”，因为第二次导入的 b 模块把 a 模块的同名函数 sayHi() 给覆盖了，这就是所谓命名空间的冲突。
				所以，在项目中，特别是大型项目中我们应该避免使用 from…import...，除非你非常明确不会造成命名冲突。


			    # a.py
				from b import y
				def x():
					print('x')

				# b.py
				from a import x
				def y():
					print('y')

				>>>
				Traceback (most recent call last):
				  File "/Users/FishC/Desktop/a.py", line 1, in <module>
					from b import x
				  File "/Users/FishC/Desktop/b.py", line 1, in <module>
					import a
				  File "/Users/FishC/Desktop/a.py", line 1, in <module>
					from b import x
				ImportError: cannot import name 'x'
				这个是循环嵌套导入问题。无论运行 a.py 或 b.py 哪一个文件都会抛出 ImportError 异常。
				这是因为在执行其中某一个文件（a.py）的加载过程中，会创建模块对象并执行对应的字节码。
				但当执行第一个语句的时候需要导入另一个文件（from b import y），因此 CPU 会转而去加载另一个文件（b.py）。
				同理，执行另一个文件的第一个语句（from a import x）恰好也是需要导入之前的文件（a.py）。
				此时，之前的文件处于仅导入第一条语句的阶段，因此其对应的字典中并不存在 x，故抛出“ImportError: cannot import name 'x'”异常

				所以用import就可以解决这个问题咯
				# a.py
				import b

				def x():
				print('x')

				# b.py
				import a

				def y():
					print('y')

				a.x()

		import 模块名 as 新名字
			这种方法是最好的

	模块值的初始化
		在模块内部初始化值只有第一次处理该模块的时候执行
		换句话来说，一个模块多次被import，它只会执行一次初始化

	if __name__ == '__main__'
		__nam__在主程序中是显示__main__
		如果是在模块里是显示模块名字
		也就是说被import后__name__ = 模块名

	模块搜索路径
		'C:\\Users\\kk\\AppData\\Local\\Programs\\Python\\Python36\\lib\\site-packages'
		是推荐放模块的文件夹

		>>> import sys
		>>> sys.path
		['', 'C:\\Users\\kk\\AppData\\Local\\Programs\\Python\\Python36\\Lib\\idlelib', 'C:\\Users\\kk\\AppData\\Local\\Programs\\Python\\Python36\\python36.zip', 'C:\\Users\\kk\\AppData\\Local\\Programs\\Python\\Python36\\DLLs', 'C:\\Users\\kk\\AppData\\Local\\Programs\\Python\\Python36\\lib', 'C:\\Users\\kk\\AppData\\Local\\Programs\\Python\\Python36', 'C:\\Users\\kk\\AppData\\Local\\Programs\\Python\\Python36\\lib\\site-packages']
		>>> sys.path.append("C:\\Users\\kk\\Desktop\\python")#添加路径后，就可以导入模块
		>>> sys.path
		['', 'C:\\Users\\kk\\AppData\\Local\\Programs\\Python\\Python36\\Lib\\idlelib', 'C:\\Users\\kk\\AppData\\Local\\Programs\\Python\\Python36\\python36.zip', 'C:\\Users\\kk\\AppData\\Local\\Programs\\Python\\Python36\\DLLs', 'C:\\Users\\kk\\AppData\\Local\\Programs\\Python\\Python36\\lib', 'C:\\Users\\kk\\AppData\\Local\\Programs\\Python\\Python36', 'C:\\Users\\kk\\AppData\\Local\\Programs\\Python\\Python36\\lib\\site-packages', 'C:\\Users\\kk\\Desktop\\python']

		Python 搜寻模块文件举个例子，比如用户在 Python 中尝试导入 import foobar，那么
			首先，Python 会在内建模块中搜寻 foobar；
			若未找到，则 Python 会在当前工作路径（当前脚本所在路径，或者执行 Python 解释器的路径）中搜寻 foobar；
			若仍未找到，则 Python 会在环境变量 PYTHONPATH 中指示的路径中搜寻 foobar；
			若依旧未能找到，则 Python 会在安装时指定的路径中搜寻 foobar；
			若仍旧失败，则 Python 会报错，提示找不到 foobar 这个模块。

	pyc 文件
		和 LaTeX 中遇到的问题一样：装载大量文本文件是很慢的。
		因此 Python 也采用了类似 LaTeX 的解决方案：
		将模块编译成容易装载的文件，并保存起来（相当于 LaTeX 中的 dump 格式文件 .fmt）。这些编译好并保存起来的文件，
		有后缀名 .pyc。

		当 Python 编译好模块之后，下次载入时，Python 就会读取相应的 .pyc 文件，而不是 .py 文件。
		而装载 .pyc 文件会比装载 .py 文件更快。

		值得一提的是，对于 .pyc，很多人一直有误解。事实上，从运行的角度，装载 .pyc 并不比装载 .py 文件更快。
		此处的加速，仅只在装载模块的过程中起作用。因此 .pyc 中的 C 更多地可以理解为 cache。

	包（package）
		创建一个包
			1 创建一个文件夹，用于存放相关的模块，文件夹的名字就是包的名字
			2 创建一个__init__.py 的模块文件，内容可以为空，告诉python把这个文件夹作为一个包处理
			3 将相关的模块放入文件夹中
		导入模块
			当模块导入 名字是包名.模块名 就可以了

		从包中导入*
			__init__.py 包里含有 __all__ = ["echo", "surround", "reverse"]
			导入全部会从这里定义的名字导入

		子包参考
			from . import echo
			from .. import formats
			from ..filters import equalizer

			.代表当前模块
			..代表父模块
			注意相对导入是基于当前模块导入，如果在__main__中就必须使用绝对导入

	类变量和实例变量
		继承与同一个类的实例对象会从继承对象那里继承类属性
			class Dog:
				kind = 'canine'         # class variable shared by all instances
				def __init__(self, name):
					self.name = name    # instance variable unique to each instance

			>>> d = Dog('Fido')
			>>> e = Dog('Buddy')
			>>> d.kind                  # shared by all dogs
			'canine'
			>>> e.kind                  # shared by all dogs
			'canine'
			>>> d.name                  # unique to d
			'Fido'
			>>> e.name                  # unique to e
			'Buddy'

		但是最好是不要设置类属性，因为使两个实例对象共享同一个属性
			class Dog:
				tricks = []             # mistaken use of a class variable
				def __init__(self, name):
					self.name = name

				def add_trick(self, trick):
					self.tricks.append(trick)

			>>> d = Dog('Fido')
			>>> e = Dog('Buddy')
			>>> d.add_trick('roll over')
			>>> e.add_trick('play dead')
			>>> d.tricks                # unexpectedly shared by all dogs
			['roll over', 'play dead']

		所以类最正确的设计应该使用实例变量，杜绝类属性的出现
			class Dog:
				def __init__(self, name):
					self.name = name
					self.tricks = []    # creates a new empty list for each dog
				def add_trick(self, trick):
					self.tricks.append(trick)

			>>> d = Dog('Fido')
			>>> e = Dog('Buddy')
			>>> d.add_trick('roll over')
			>>> e.add_trick('play dead')
			>>> d.tricks
			['roll over']
			>>> e.tricks
			['play dead']

	继承
		格式
			class DerivedClassName(BaseClassName):
				<statement-1>
				.
				.
				.
				<statement-N>

		一些用于继承的函数
			issubclass(class,classinfo)判断是否是子类
				子类！！！！
				class 是 classinfo 的子类则返回True
				1、一个类被认为是自己的子类
				2、classinfo可以是类对象组成的元祖，只要class与其中任何一个候选类的子类，则返回True
				3、其它的情况会抛出 type error

				>>> class A:
					pass

				>>> class B(A):
					pass

				>>> issubclass(A,B)
				False
				>>> issubclass(B,A)
				True
				>>> issubclass(B,B)
				True
				>>> issubclass(B,object)
				True
				>>> class C:
					pass

				>>> issubclass(B,C)
				False
				>>>

			isinstance(object,classinfo) 判断是否是类点实例对象
				classinfo 可以是元组和issubclass一样
				实例！！！！！
				1、如果第一个参数不是对象，则永远返回False
				2、如果第二个参数不是类或者由类对象组成的元祖，会抛出TypeError异常
				>>> isinstance(C,object)
				True
				>>> b1 = B()
				>>> isinstance(b1,C)
				False
				>>> isinstance(b1,(A,B))
				True

			hasattr(obj,name)
				测试一个对象是否有指定的属性！
				name 必须用“”阔起来
				>>> class C:
					def __init__(self,x = 8):
						self.x = x


				>>> c1 = C()
				>>> hasattr(c1,'x')
				True
				>>> hasattr(c1,x)
				Traceback (most recent call last):
				  File "<pyshell#35>", line 1, in <module>
					hasattr(c1,x)
				NameError: name 'x' is not defined

			getattr(object,name[,default])
				返回对象指定的属性值，如果不存在返回设置的default的，没有设置则抛出异常
				>>> getattr(c1,"x")
				8
				>>> getattr(c1,"y",666)
				666
				>>> getattr(c1,"y","木有")
				'木有'

			setattr(obj,name,value)
				设置指定属性的值，如果不存在则设置一个新属性，并给赋值
				>>> setattr(c1,"y",6)
				>>> getattr(c1,"y")
				6

			delattr(object,name)
				>>> delattr(c1,"y")
				>>> delattr(c1,"y")
				Traceback (most recent call last):
				  File "<pyshell#43>", line 1, in <module>
					delattr(c1,"y")
				AttributeError: y

		多继承
			super()
				可以直接调用父类

				class A():
					def __init__(self):
						print("进入A…")
						print("离开A…")

				class B(A):
					def __init__(self):
						print("进入B…")
						super().__init__()
						print("离开B…")

				class C(A):
					def __init__(self):
						print("进入C…")
						super().__init__()
						print("离开C…")

				class D(B, C):
					def __init__(self):
						print("进入D…")
						super().__init__()
						print("离开D…")

				>>> d = D()
				进入D…
				进入B…
				进入C…
				进入A…
				离开A…
				离开C…
				离开B…
				离开D…

	私有变量
		定义
			再Python 中定义私有变量只需要在变量名或函数名前加上'___'两个下滑线,那么函数变量就会变成私有的了
			>>> class Person:
				__name= '小甲鱼'
			>>> p.name
			Traceback (most recent call last):
			  File "<pyshell#44>", line 1, in <module>
				p.name
			AttributeError: 'Person' object has no attribute 'name'

		内部访问
			>>> class Person:
				__name = '小甲鱼'
				def getName(self):
					return self.__name
			>>> p = Person()
			>>> p.getName()
			'小甲鱼'

		像正常属性一样访问
			对象._类名__变量名#其实加下划线也只是单纯改了名字而已
			>>> p._Person__name
			'小甲鱼'

	组合
		组合就是类的实例化放到一个新类里面，用于几个没有什么继承关系的类把它放在一起，这就是组合
		class Turtle:
			def __init__(self,x):
				self.num = x
		class Fish:
			def __init__(self,x):
				self.num = x
		class Pool:
			def __init__(self,x,y):
				self.turtle = Turtle(x)
				self.fish = Fish(y)
			def print_num(self):
				print("水里有乌龟%d只 小鱼 %d条"%(self.turtle.num,self.fish.num))

	装饰器
		修饰符的作用就是为已经存在的对象添加额外的功能

		一般设置
			>>> from datetime import datetime
			>>> def log(func):
			... 	def decorator(*args, **kwargs):
			... 		print('Function ' + func.__name__ + ' has been called at ' + datetime.now().strftime('%Y-%m-%d %H:%M:%S'))
			... 		return func(*args, **kwargs)
			... 	return decorator

			... >>> @log
			... def add(x, y):
			... 	return x + y
			... >>> add(1, 2)

			Function add has been called at 2017-08-29 13:11:48
			3

		一般设置的弊端
			>>> add.__name__
			'decorator'

		解决方法
			>>> from functools import wraps
			>>> def log(func):
			... 	@wraps(func)
			... 	def decorator(*args, **kwargs):
			... 		print('Function ' + func.__name__ + ' has been called at ' + datetime.now().strftime('%Y-%m-%d %H:%M:%S'))
			... 		return func(*args, **kwargs)
			... 	return decorator
			... >>> @log
			... def add(x, y):
			... 	return x + y

			... >>> add.__name__
			'add'

		函数中嵌入装饰器
			from functools import wraps
			def logit(logfile='out.log'):
				def logging_decorator(func):
					@wraps(func)
					def nfuntion(*args, **kwargs):
						log_string = func.__name__ + 'was called'
						print(log_string)
						with open(logfile, 'a') as opened_file:
							opened_file.write(log_string + '\n')
						return func(*args, **kwargs)
					return nfuntion

				return logging_decorator

			@logit()

			def myfuncl():
				pass

			myfuncl()


			@logit(logfile = "fun2.log")@装饰器实质上就是函数，可以带参数的
			def myfunc2():
				pass

			myfunc2()

		装饰类
			from functools import wraps

			class logit():
				def __init__(self, logfile='out.log'):
					self.logfile = logfile

				def __call__(self, func):
					@wraps(func)

					def wrappend_function(*args, **kwargs):
						log_string = func.__name__ + 'was called'
						print(log_string)

						with open(self.logfile, 'a') as opened_file:
							opened_file.write(log_string + '\n')

						self.notify()
					return wrappend_function

				def notify(self):
					pass

			@logit()
			def myfuncl():
				pass

			myfuncl()

			class email_logit(logit):
				def __init__(self, email = 'admin@myproject.com', *args, **kwargs):
					self.email = email
					super().__init__(*args, **kwargs)

				def notify(self):
					pass
			@email_logit()

			def myfuncl2():
				pass
			myfuncl2()


		python内置的修饰器
			staticmethod
				类中定义的实例方法变成静态方法
			classmethod
				类中定义的实例方法变成类方法
			property
				类中定义的实例方法
					类属性
				@method.setter
				@method.deleter

				@property
				def first_name(self):
					return self._first_name

				# Setter function
				@first_name.setter
				def first_name(self,value):
					if not isinstance(value, str):
						raise TypeError('Expected a string')
					self._first_name = value

				# Deleter function (optional)
				@first_name.deleter
				def first_name(self):
					raise AttributeError("Can't delete attribute")

				>>> cat = Animal()
				# 创建实例
				>>> cat.age = 'h'
				# 赋值一个字符串，
				报错 Traceback (most recent call last): File "<stdin>", line 1, in <module> File "<stdin>", line 10, in age ValueError
				>>> cat.age = 3
				# 赋值数字，成功
				>>> cat.age # 获得属性值 3

魔法方法
	构造方法
		__init__(self,[,...])
			初始化实例属性

			__init__ 返回时None 不能自己设置返回值

		__new__(cls[,...])
			只需了解，不需要会

			要任务时返回一个实例对象，通常是参数 cls 这个类的实例化对象，当然你也可以返回其他对象

			第一被调用的方法
			第一个参数是cls 也就是class，是返回的cls的事例化对象
			如果后边有参数，就会原封不动传给__init__方法
			需要一个事例对象作为返回值，通常class这个类的事例对象
			当然你也可以返回其他类的事例对象

			一般会返回一个对象，也可以自己设定
			这个魔法方法一般是不用写的，但有一种情况是需要写的：继承不可变类型的时候，
			有需要修改的时候一般是不用写的，但有一种情况是需要写的：继承不可变类型的时候，有需要修改的时候


			>>> class CapStr(str):
				def __new__(cls,string):
					string = string.upper()
					return str.__new__(cls,string)


			>>>
			>>> a = CapStr("fsdfasd")
			>>> a
			'FSDFASD'

		__del__(self)
			对象要被销毁的时候会被自动调用

			del x = x.__del__() 这个是不相等的
			而是当垃圾回收机制，当没有任何变量引用这个变量的时候，才会调用该方法

			>>> class C:
				def __init__(self):
					print("我是init方法，我被调用了")
				def __del__(self):
					print("我是del方法")

			>>>
			>>> c1 = C
			>>> c1 = C()
			我是init方法，我被调用了
			>>> c2 = c1
			>>> c3 = c2
			>>> del c3
			>>> del c2
			>>> del c1
			我是del方法 #也就是说，没有任何标签时，垃圾回收机制会自动启用，会调用del方法，所以只有在c1被删除的时候才会打印__del__里的print（）

	操作符
		比较操作符
			__eq__`(self, other)

			定义等于操作符(==)的行为。

			__ne__(self, other)

			定义不等于操作符(!=)的行为。

			__lt__(self, other)

			定义小于操作符(<)的行为。

			__gt__(self, other)

			定义大于操作符(>)的行为。

			__le__(self, other)

			定义小于等于操作符(<)的行为。

			__ge__(self, other)

			定义大于等于操作符(>)的行为。

			class Word(str):
				'''单词类，按照单词长度来定义比较行为'''

				def __new__(cls, word):
					# 注意，我们只能使用 __new__ ，因为str是不可变类型
					# 所以我们必须提前初始化它（在实例创建时）
					if ' ' in word:
						print ("Value contains spaces. Truncating to first space.")
						word = word[:word.index(' ')]
						# Word现在包含第一个空格前的所有字母
					return str.__new__(cls, word)

				def __gt__(self, other):
					return len(self) > len(other)
				def __lt__(self, other):
					return len(self) < len(other)
				def __ge__(self, other):
					return len(self) >= len(other)
				def __le__(self, other):
					return len(self) <= len(other)

		算术运算符对应的魔法方法
			__add__(self, other)			定义加法的行为：+
			__sub__(self, other)			定义减法的行为：-
			__mul__(self, other)			定义乘法的行为：*
			__truediv__(self, other)		定义真除法的行为：/
			__floordiv__(self, other)		定义整数除法的行为：//
			__mod__(self, other)			定义取模算法的行为：% 取余数
			__divmod__(self, other)			定义当被 divmod() 调用时的行为  换句话来说就是求地板除后的余数
			__pow__(self, other[, modulo]) 	定义当被 power() 调用或 ** 运算时的行为 求次方
			__lshift__(self, other)			定义按位左移位的行为：<<
			__rshift__(self, other)			定义按位右移位的行为：>>
			__and__(self, other)			定义按位与操作的行为：&
			__xor__(self, other)			定义按位异或操作的行为：^
			__or__(self, other)				定义按位或操作的行为：|

		反运算
			如果a+b 对象a的add方法不支持或者没有实现，就会实现对象b的add方法，这就是反运算

					举个例子
			>>> class Nint(int):
				def __radd__(self,other):
					return int.__sub__(self,other)


			>>> a = Nint(5)
			>>> b = Nint(3)
			>>> a + b
			8
			>>> 1 + b
			2

			一个主意点
				重写一些注重运算顺序的方法（如减法，除法）时，主意self和other的位置顺序

				>>> class Nint(int):
					def __rsub__(self,other):
						return int.__sub__(self,other)


				>>> a = Nint(5)
				>>> 3 - a
				2
				>>> class Nint(int):
					def __rsub__(self,other):
						return int.__sub__(other,self)


				>>> a = Nint(5)
				>>> 3 - a
				-2



			__radd__(self, other)		（与上方相同，当左操作数不支持相应的操作时被调用）
			__rsub__(self, other)		（与上方相同，当左操作数不支持相应的操作时被调用）
			__rmul__(self, other)		（与上方相同，当左操作数不支持相应的操作时被调用）
			__rtruediv__(self, other)	（与上方相同，当左操作数不支持相应的操作时被调用）
			__rfloordiv__(self, other)	（与上方相同，当左操作数不支持相应的操作时被调用）
			__rmod__(self, other)		（与上方相同，当左操作数不支持相应的操作时被调用）
			__rdivmod__(self, other)	（与上方相同，当左操作数不支持相应的操作时被调用）
			__rpow__(self, other)		（与上方相同，当左操作数不支持相应的操作时被调用）
			__rlshift__(self, other)	（与上方相同，当左操作数不支持相应的操作时被调用）
			__rrshift__(self, other)	（与上方相同，当左操作数不支持相应的操作时被调用）
			__rand__(self, other)		（与上方相同，当左操作数不支持相应的操作时被调用）
			__rxor__(self, other)		（与上方相同，当左操作数不支持相应的操作时被调用）
			__ror__(self, other)		（与上方相同，当左操作数不支持相应的操作时被调用）

		增量赋值运算

			__iadd__(self, other)			定义赋值加法的行为：+=
			__isub__(self, other)			定义赋值减法的行为：-=
			__imul__(self, other)			定义赋值乘法的行为：*=
			__itruediv__(self, other)		定义赋值真除法的行为：/=
			__ifloordiv__(self, other)		定义赋值整数除法的行为：//=
			__imod__(self, other)			定义赋值取模算法的行为：%=
			__ipow__(self, other[, modulo])	定义赋值幂运算的行为：**=
			__ilshift__(self, other)		定义赋值按位左移位的行为：<<=
			__irshift__(self, other)		定义赋值按位右移位的行为：>>=
			__iand__(self, other)			定义赋值按位与操作的行为：&=
			__ixor__(self, other)			定义赋值按位异或操作的行为：^=
			__ior__(self, other)			定义赋值按位或操作的行为：|=

		一元操作符（就是只有一个操作数的意思）
			__pos__(self)	定义正号的行为：+x
			__neg__(self)	定义负号的行为：-x
			__abs__(self)	定义当被 abs() 调用时的行为 取绝对值
			__invert__(self)	定义按位求反的行为：~x

	属性访问
		__getattr__(self,name)
			定义试图获取一个不存在的属性时的行为
		__getattribute__(self,name)
			定义类属性被访问的行为
		__setattr__(self,name,value)
			当一个属性被设置时的行为
		__delattr__(self,name)
			当一个属性被删除时的行为

		>>> class C:

			def __getattr__(self,name):

				print("getattr_")
			def __getattribute__(self,name):
				print("getattrribute_")
				return super().getattribute__(name)

			def __setattr__(self,name,value):
				print("setattr_")
				super().__setattr__(name,value)
			def __delattr__(self,name):
				print("delattr")
				super().__delattr__(name)


		>>> c = C()
		>>> c.x
		getattrribute_
		getattr_#先执行getattribute 再执行 getattr
		>>> c.x  = 1
		setattr_
		>>> del c.x
		delattr

		死循环陷阱
			>>> class Rectangle():
				def __init__(self,long = 0,wide = 0 ):
					self.long = long
					self.wide = wide
				def __setattr__(self,name,value):
					if name == "square":
						self.long,self.wide = value,value
					else:
						self.name = value#无限递归！！！！！这里就是死循环点
				def getArea(self):
					return self.wide  * self.long


			>>> r1  = Rectangle()
			Traceback (most recent call last):
			  File "<pyshell#69>", line 1, in <module>
				r1  = Rectangle()
			  File "<pyshell#68>", line 3, in __init__
				self.long = long
			  File "<pyshell#68>", line 9, in __setattr__
				self.name = value
			  File "<pyshell#68>", line 9, in __setattr__
				self.name = value
			  File "<pyshell#68>", line 9, in __setattr__
				self.name = value
			  [Previous line repeated 987 more times]
			  File "<pyshell#68>", line 6, in __setattr__
				if name == "square":
			RecursionError: maximum recursion depth exceeded in comparison

			解决方法
				方法一
				调用基类的setattr#推荐用这种方法去避免死循环
				super（）.setattr(name,value)

					>>> class Rectangle():
						def __init__(self,long = 0,wide = 0 ):
							self.long = long
							self.wide = wide
						def __setattr__(self,name,value):
							if name == "square":
								self.long,self.wide = value,value
							else:
								super().__setattr__(name,value)
						def getArea(self):
							return self.wide  * self.long


					>>> c = Rectangle(4,5)
					>>> c.getArea()
					20
					>>> c.square =10
					>>> c.getArea()
					100
					>>> c.long
					10
					>>> c.wide
					10
				方法二
				__dict__ : 类的属性（包含一个字典，由类的数据属性组成）
				__dict__
					>>> class Rectangle():
						def __init__(self,long = 0,wide = 0 ):
							self.long = long
							self.wide = wide
						def __setattr__(self,name,value):
							if name == "square":
								self.long,self.wide = value,value
							else:
								self.__dict__[name] = value
						def getArea(self):
							return self.wide  * self.long


					>>> c = Rectangle(4,5)
					>>> c.long
					4
					>>> c.wide
					5
					>>> c.getArea()
					20

	描述符
		将某种特殊类型的类的实例指派给另一个类的属性

		特殊类型
			实现以下方法中一个或者以上

			__get__(self,instance,owner)
			用于访问属性，返回属性的值

			__set__(self,instance,value)
			将在属性分配操作中调用，不返回任何内容（也就是被赋值时被调用）

			__delete__(self,instance)
			控制删除操作，不返回任何内容

			class MyDcriptor:
				def __get__(self,instance,owner):
					print("geting",self,instance,owner)

				def __set__(self,instance,value):
					print("setting",self,instance,value)

				def __delete__(self,instance):
					print("deleting",self,instance)

			class Test:
				x = MyDcriptor()

			下面展示参数具体是个什么东西
			>>> test = Test()
			>>> test.x
			geting <__main__.MyDcriptor object at 0x0000000002EC3518> <__main__.Test object at 0x0000000002EC34A8> <class '__main__.Test'>
			>>> test
			<__main__.Test object at 0x0000000002EC34A8>
			>>> test.x = "x_man"
			setting <__main__.MyDcriptor object at 0x0000000002EC3518> <__main__.Test object at 0x0000000002EC34A8> x_man
			>>> del test.x
			deleting <__main__.MyDcriptor object

			self  = 描述符的实例 instance 拥有者的实例 owner 拥有者的类
			value 赋值的值


		定制自己的描述符
			class MyDcriptor:
				def __init__(self,fget = None,fset = None, fdel= None):
					self.fget = fget
					self.fset = fset
					self.fdel = fdel

				def __get__(self,instance,owner):
					return self.fget(instance)

				def __set__(self,instance,value):
					self.fset(instance,value)

				def __delete__(self,instance):
					self.fdel(instance)

			class C:
				def __init__(self):
					self._x = None

				def getX(self):
					return self._x

				def setX(self,value):
					self._x = value

				def delX(self):
					del self._x

				x = MyDcriptor(getX,setX,delX)

		自己运行程序就知道为什么会是这样的了！

		练习 设置华氏摄氏度和摄氏度

			class Fahrenheit:


				def __get__(self,instance,owner):
					return self.value


				def __set__(self,instance,value):
					self.value = value



			class celsius:
				def __init__(self,value = 0):
					self.value = value

				def __get__(self,instance,owner):
					return self.value

				def __set__(self,instance,value):
					self.value = value
					instance.fah = value * 1.8 +32



			class temperature:
				cel = celsius()
				fah = Fahrenheit()

	定制序列
		容器类型的协议
			__len__(self)					定义当被 len() 调用时的行为（返回容器中元素的个数）
			__getitem__(self, key)			定义获取容器中指定元素的行为，相当于 self[key]
			__setitem__(self, key, value)	定义设置容器中指定元素的行为，相当于 self[key] = value
			__delitem__(self, key)			定义删除容器中指定元素的行为，相当于 del self[key]
			__iter__(self)					定义当迭代容器中的元素的行为
			__reversed__(self)				定义当被 reversed() 调用时的行为
			__contains__(self, item)		定义当使用成员测试运算符（in 或 not in）时的行为

			class FunctionalList:
				'''一个列表的封装类，实现了一些额外的函数式
				方法，例如head, tail, init, last, drop和take。'''

				def __init__(self, values=None):
					if values is None:
						self.values = []
					else:
						self.values = values

				def __len__(self):
					return len(self.values)

				def __getitem__(self, key):
					# 如果键的类型或值不合法，列表会返回异常
					return self.values[key]

				def __setitem__(self, key, value):
					self.values[key] = value

				def __delitem__(self, key):
					del self.values[key]

				def __iter__(self):
					return iter(self.values)

				def __reversed__(self):
					return reversed(self.values)

				def append(self, value):
					self.values.append(value)

				def head(self):
					# 取得第一个元素
					return self.values[0]

				def tail(self):
					# 取得除第一个元素外的所有元素
					return self.valuse[1:]

				def init(self):
					# 取得除最后一个元素外的所有元素
					return self.values[:-1]

				def last(self):
					# 取得最后一个元素
					return self.values[-1]

				def drop(self, n):
					# 取得除前n个元素外的所有元素
					return self.values[n:]

				def take(self, n):
					# 取得前n个元素
					return self.values[:n]

	其它的魔法方法
		http://bbs.fishc.com/forum.php?mod=viewthread&tid=48793&extra=page%3D1%26filter%3Dtypeid%26typeid%3D403












算法
	递归(recursion)
		普通程序员用迭代，天才程序员用递归，但不是说所有迭代和所有东西都用递归，递归只有用在适合的位置上才是正确的

		写递归一定要记住：递归递归，归去来兮，出来混，总是要还的

		设置深度
			递归Python默认100层，但我们可以设置层数
			>>> import sys
			>>> sys.setrecursionlimit(1000000)

		使用递归的两个条件
			1、调用函数自身
			2、设置了自身正确的返回条件

		递归的小技巧
			可以把参数下次调用自身的参数直接写进去
			比如
				def ogl(x,y):
					if y == 0:
						return x
					else:
						return ogl(y,x%y)
		递归不得不使用的地方
			汉诺塔，目录索引（因为你永远不知道这个目录里边是否还有目录），快速排序（二十世纪十大算法之一），树结构的定义等如果使用递归，会事半功倍，否则会导致程序无法实现或相当难以理解。

		实现斐波那契数列
			1 2 3 4 5 6 7  8  9  10 11 12
			1 1 2 3 5 8 13 21 34 55 89 144
			除了头两个月，其余的都等于之前两个月相加
			F（n）=  1  n=1
					 2  n=2
					 F(n-1)+F(n-2),当n>2时

		分治思想
			 一个问题分为两个或者多个小问题，然后分出来的小问题继续分解到最简单的问题

		实现汉诺塔
			def han(x,y,z,n):
				if n == 1:
					print(x,'->',y)
				else:
					return han(y,x,z,n-1)
					print(x,'->',z)
					return han(x,z,y,n-1)





#以下是用过的模块

virtualenv虚拟环境
	安装
		sudo pip3 install virtualenv

	创建
		virtualenv myproject

	创建使用系统全局模块
		virtualenv --system-site-packages myproject

	启动
		source /myproject/bin/activate

	关闭
		deactivate

timeit
	http://bbs.fishc.com/thread-55593-1-1.html
	一个关键点
		stmt 是str

sys模块
	sys.argv
		读取命令行（有多少读多少）
		sys.argv[index]输入命令可以被索引
	sys.exit（）退出

os模块（Operating system)
	当前使用平台：

	os.name  #返回当前使用平台的代表字符，Windows用'nt'表示，Linux用'posix'表示

	当前路径和文件

	os.getcwd()  #返回当前工作目录
	os.listdir(path)  #返回path目录下所有文件列表

	绝对路径

	os.path.abspath(path) #返回path的绝对路径

	系统操作：

	os.system()  #运行shell命令
	>>>os.system('cmd')  #Windows下打开终端
	>>>os.system('ls')  #Linux下查看当前目录所有文件

	查看文件名或目录：

	os.path.split(path)  #将path的目录和文件名分开为元组
	os.path.join(path1,path2,...)  #将path1，怕path2，...进行组合，若path2为绝对路径，则会将path1删除
	os.path.dirname(path)  #返回path中的目录（文件夹部分），结果不包含'\'
	os.path.basename(path)  #返回path中的文件名

	创建目录：

	os.mkdir(path)  #创建path目录（只能创建一级目录，如'F:\XXX\WWW'）,在XXX目录下创建WWW目录
	os.makedirs(path)  #创建多级目录（如'F:\XXX\SSS'），在F盘下创建XXX目录，继续在XXX目录下创建SSS目录

	删除文件或目录：

	os.remove(path)  #删除文件（必须是文件）
	os.rmdir(path)  #删除path目录(只能删除一级目录，如'F:\XXX\SSS'),只删除SSS目录
	os.removedirs(path)  #删除多级目录（如'F:\XXX\SSS'）,必须为空目录，删除SSS、FFF目录

	更改路径：

	os.chdir(path)  #将当前工作目录更改为指定路径path

	查看文件时间：

	os.path.getmtime(path)  #返回文件或目录的最后修改时间，结果为秒数
	os.path.getatime(path)  #返回文件或目录的最后访问时间，结果为秒数
	os.path.getctime(path)  #返回文件或目录得创建时间，结果为秒数

	查看文件大小：

	os.path.getsize(path)  #返回文件的大小，若是目录则返回0

	查看文件：

	os.path.exists(path)  #判断path是否存在，存在返回True,不存在返回False
	os.path.isfile(path)  #判断path是否为文件，是返回True,不是返回False
	os.path.isdir(path)  #判断path是否目录，是返回True，不是返回False

	表现形式参数：

	os.sep  #返回当前操作系统特定的路径分隔符
	os.linesep  #返回当前平台使用的行终止符
	os.extsep  #返回文件名与扩展名的分隔符

	 获取文件和目录：

	os.walk(path)   #递归返回path下的目录（包括path目录）、子目录、文件名的三元组
	返回值需要list() 来显示

	获得shell命令返回值：

	fp=os.popen(cmd)   #打开命令cmd或从命令cmd打开管道，返回值是连接到管道的文件对象
	rlt=fp.read()或 rlt=fp.readlines()  #读取结果

pickle
	pickle的实质就是利用一些算法将你的数据对象“腌制”成二进制文件，存储在磁盘上，当然也可以放在数据库或者通过网络传输到另一台计算机上。

	pickle.dump(from,to) 存放
	pickle.load(from)	读取

	>>> list1 = [12,3,123,2134,234,2,13,5,35,6]
	>>> a = open('pickle.r','xb')#一定要加b  二进制存入！！！！！！！！！！！
	>>> import pickle
	>>> pickle.dump(list1,a)
	>>> a.close()
	>>> a = open('pickle.r','rb')#一定要加b  二进制导出！！！！！！！！！！！
	>>> list2 = pickle.load(a)
	>>> list2
	[12, 3, 123, 2134, 234, 2, 13, 5, 35, 6]

	>>> import pickle
	>>> courses = { 1:'Linux', 2:'Vim', 3:'Git'}
	>>> with open('./courses.data', 'wb') as file: ... pickle.dump(courses, file) ...
	>>> with open('./courses.data', 'rb') as file: ... new_courses = pickle.load(file) ...
	>>> new_courses {1: 'Linux', 2: 'Vim', 3: 'Git'}
	>>> type(new_courses) <class 'dict'>

json
	json.loads()
	json.dumps()
		>>> import json
		>>> courses = { 1:'Linux', 2:'Vim', 3:'Git'}
		>>> json.dumps(courses) '{"1": "Linux", "2": "Vim", "3": "Git"}'
		>>> with open('courses.json', 'w') as file: ... file.write(json.dumps(courses)) ... 38
		>>> with open('courses.json', 'r') as file: ... new_courses = json.loads(file.read()) ...
		>>> new_courses {'1': 'Linux', '2': 'Vim', '3': 'Git'} >>> type(courses) <class 'dict'>

图形用户界面入门：easygui
	easygui.sourceforge.net
	http://bbs.fishc.com/forum.php?mod=viewthread&tid=46069&extra=page%3D1%26filter%3Dtypeid%26typeid%3D403

	导入和使用
		>>> import easygui
		>>>easygui.msgbox('nihao')

		>>>from  easygui import
		>>>msgbox('(｡･∀･)ﾉﾞ嗨')

		>>> import easygui as g
		>>> g.msgbox('你好')
		三种导入方法推荐使用最后一个
	一个框
	p.msgbox('你好','用户', '选择') # msgbox(msg = '内容',title = '标题',ok_button = '按钮的内容',image = None ,root = None)


	选择
		cc
			if p.ccbox('你好','用户',('1','0')) :#ccbox(msg = '', title = '', choices = ('Continue','Cancel'),image = None)
			p.msgbox('你好','用户')#continue
			else:
			p.msgbox('傻逼','用户')# cancel


		自己定义选择项
			choices = ['愿意','不愿意','有钱的时候愿意']#可以选择一个列表作为选择,
			reply = p.choicebox('你愿意付钱吗？？','用户',choices = choices)#赋值给reply,choicesbox(msg , title , choices  )
			print(reply)

		YesNo
			p.ynbox()#ynbox(msg = '',title = '',choices = ('Yes','No'),image = None ) 与上面那个一样

			py = p.buttonbox(choices = ('1','2','3'))# buttonbox(msg = '',title = '',choices = ('','',''),image = None ,root = None)
			print(py)

		Yes0No1
			y = p.indexbox()#indexbox(msg ,title , choices = ('Yes','No'),image = None)第一个按钮返回0，第二个1
			print(y)

		Yes1No0
			p = p.boolbox('这个是不是你的目标？？？',image = '目标.gif')#boolbox(msg,title,choices = ('Yes','No'),image = None)第一个按钮返回1，第二个返回0
			print(p)

		图片只支持gif
			choices = ['愿意','不愿意','有钱的时候愿意']#可以选择一个列表作为选择,再赋值给函数里的choices

		多选项
			f = p.multchoicebox(choices = ['愿意','不愿意','有钱的时候愿意'])#multchoicebox(msg,title,choice = (),**kwargs)
			#这个是可以多选的哈哈
			print(f)

	输入
		输入str
			f = p.enterbox()#enterbox(msg ,title , defult = '' ,strip = True#不要首尾空格赋值False ,image = None , root = None)
			print(f)

		输入int
			f = p.integerbox()#integerbox(msg,title,defult = '',lowerbound = 0, upperbound = 99 ,image = None , root = None,**invalidKeywordguments)

		输入多个值
			field = ['年龄','名字']
			f = p.multenterbox(fields = field)#multenterbox(msg, title , fields = () , values = ())
			print(f)
			#如果用户提供多个简单的输入框，注意一下几点：
			如果用户输入选项值少，返回列表的值用空字符串
			如果用户输入选项值多，则返回列表中的值将截断为选项的数量
			如果用户取消操作，则返回域中列表的值或者None值

	输入密码
		输入一个密码
			f = p.passwordbox('密码')#passwordbox(msg,title,default='',image = None ,root = None)-
			print(f)#这个跟enterbox()差不多，区别是不显示输入的东-
			f = p.multpasswordbox(fields = ('用户名','账号','密码'))#multpasswordbox(msg,title,fields = (),values = ())
			print(f)#最后一个框显示为密码形式

	显示类型
		一般书面字体显示
			p.textbox(text = '发货速度加快立法哈萨克记得发哈可是大家',codebox = 0)#textbox(msg,title,text = '',codebox = 0)

			#textbox()可默认会以比例字体（参数codebox = 1 设置为等宽字体）来显示文本内容（会自动换行）,这个函数适合用于显示一半的书面文字
			text 可以是str 也可以是 tuple 也可以是 list
		等宽字体显示
			p.codebox(text = '发货速度加快立法哈萨克记得发哈可是大家')#codebox(msg,title,text = '')

	目录与文件
		打开文件夹
			f = p.diropenbox()#diropenbox(msg,title,default = None)
			print(f)

		打开文件
			f = p.fileopenbox(filetypes = ['*.py'] )#fileopenbox(msg,title,default = '*' filetypes = None)
			print(f)
			default 是制定的默认参数
			filetypes = ['*',....]
			一定要[]和*  ，
			这个是包含文件掩码的字符串列表
			可以是字符串列表，列表的最后一项字符串是文件类型的描述，例如filetypes = ['*css',['*htm','*html','HTML files']]
		保存文件
			f = p.filesavebox(default = '你好',filetypes = ['*py'])  #filesavebox(msg,title,default = '',filetypes = None)
			print(f)
			default 参数应该包含一个文件名（例如当前需要保存的文件名，当然你也可以设置为空，或者包含一个文件格式掩码的通配符）
			filetypes 设置参考上面
	记住用户设置
		egstore
		http://bbs.fishc.com/forum.php?mod=viewthread&tid=46069&extra=page%3D1%26filter%3Dtypeid%26typeid%3D403
	异常判断
		try:
			print('I Love FishC.com!')
			int('FISHC') # 这里会产生异常
		except:
			p.exceptionbox()

bs4模块
	https://www.crummy.com/software/BeautifulSoup/bs4/doc.zh/index.html#id10
	使用
		from bs4 import BeautifulSoup

	Beautifulsoup对象
		Tag
			生成
				tag = soup.标签名字

			两个属性
				name
					获得标签名字
						tag.name

					改变name
						tag.name = “xxxxxxx”
						如果改变了tag的name,那将影响所有通过当前Beautiful Soup对象生成的HTML文档

				attributes
					属性是什么
						 <b class="boldest">
						 class就是属性，在html中

					获取属性
						tag.attrs或者tag["属性名字"]

					修改属性
						被添加、删除或者修改
						tag["属性名"] = “xxxxx”

						del tag["属性名"]

					多属性值
						根据不同的规则 html或者html5来返回不同的数值
							html5
								返回的多属性值是个列表

							html
								返回的是字符串

							将tag转换成字符串时,多值属性会合并为一个值#这个其实不是很懂
								rel_soup = BeautifulSoup('<p>Back to the <a rel="index">homepage</a></p>')
								rel_soup.a['rel']
								# ['index']
								rel_soup.a['rel'] = ['index', 'contents']
								print(rel_soup.p)
								# <p>Back to the <a rel="index contents">homepage</a></p>

							如果转换的文档是XML格式,那么tag中不包含多值属性
								xml_soup = BeautifulSoup('<p class="body strikeout"></p>', 'xml')
								xml_soup.p['class']
								# u'body strikeout

		NavigableString
			什么是tag的字符串
				<blockquote>No longer bold</blockquote> 你没看错 NO longer bold 就是
				简单来说就是两个标签之间的string

			可被替换，但是不能被编辑
				tag.string.replace_with("No longer bold")
				tag
				# <blockquote>No longer bold</blockquote>

		BeautifulSoup
			 对象并不是真正的HTML或XML的tag,所以它没有name和attribute属性
			 但是它有name属性，可以用soup.name来查看它的名字

		Comment
			文档的注释部分
			Comment 对象是一个特殊类型的 NavigableString 对象

			但是当它出现在HTML文档中时, Comment 对象会使用特殊的格式输出:
				print(soup.b.prettify())
				# <b>
				#  <!--Hey, buddy. Want to buy a used parser?-->
				# </b>
				ps: prettify()是用网页文档的形式输出

			Beautiful Soup中定义的其它类型都可能会出现在XML的文档中: CData , ProcessingInstruction , Declaration , Doctype .与 Comment 对象类似,这些类都是 NavigableString 的子类,只是添加了一些额外的方法的字符串独享.下面是用CDATA来替代注释的例子:
				from bs4 import CData
				cdata = CData("A CDATA block")
				comment.replace_with(cdata)

				print(soup.b.prettify())
				# <b>
				#  <![CDATA[A CDATA block]]>
				# </b>
	遍历文档树
		例子
			html_doc = """
			<html><head><title>The Dormouse's story</title></head>

			<p class="title"><b>The Dormouse's story</b></p>

			<p class="story">Once upon a time there were three little sisters; and their names were
			<a href="http://example.com/elsie" class="sister" id="link1">Elsie</a>,
			<a href="http://example.com/lacie" class="sister" id="link2">Lacie</a> and
			<a href="http://example.com/tillie" class="sister" id="link3">Tillie</a>;
			and they lived at the bottom of a well.</p>

			<p class="story">...</p>
			"""

			from bs4 import BeautifulSoup
			soup = BeautifulSoup(html_doc)

		子节点
			一个Tag可能包含多个字符串或其它的Tag,这些都是这个Tag的子节点
			BeautifulSoup 中的字符串节点是不支持这些属性的，因为字符串没有子节点

		tag
			获取具体标签的内容
				你可以这样
					tag = soup.name1

				也可以这样
					tag = soup.name1.name2
						name1是name2的父亲节点

				如果一个在soup中有多个<a>或者诸如此类的标签
					你想按以上的方式只能获得第一个
					想获得全部的标签信息你只能这样
						soup.find_all('a')

			.contents和 .children
				tag的 .contents 属性可以将tag的子节点以列表的方式输出

					head_tag = soup.head
					head_tag
					# <head><title>The Dormouse's story</title></head>

					head_tag.contents
					[<title>The Dormouse's story</title>]

				因为输出的是列表所以你可以用索引值来索引具体子节点
					比如这样
						text = title_tag.contents[0]

				ps:contents 只包含一层的子节点
					>>> tag = soup.head
					>>> tag
					<head><title>The Dormouse's story</title></head>
					>>> tag.contents
					[<title>The Dormouse's story</title>]
					>>> tag.contents[0].contents
					["The Dormouse's story"]

				字符串没有 .contents 属性,因为字符串没有子节点
					text = title_tag.contents[0]
					text.contents
					# AttributeError: 'NavigableString' object has no attribute 'contents'

				通过tag的 .children 生成器,可以对tag的子节点进行循环:
					for child in title_tag.children:
						print(child)
					ps:children 也是只包含一层的子节点

			.descendants
				升级版的contents
					.descendants 属性可以对所有tag的子孙节点进行递归循环 :
						for child in head_tag.descendants:
							print(child)
							# <title>The Dormouse's story</title>
							# The Dormouse's story

					简单来说descendants可以把你的子子孙孙全部找出来，但是contents 和 children只能找到子一代

			.string
				如果标签只包含一个子节点 NavigableString就可以用.string来查看这个子节点

		父节点
			继续分析文档树,每个tag或字符串都有父节点:被包含在某个tag中

			查看父亲节点
				.parent
					只能查看一层
				.parents
					能查出你所有祖宗

		兄弟节点
			一个例子
			sibling_soup = BeautifulSoup("<a><b>text1</b><c>text2</c></b></a>")
			print(sibling_soup.prettify())
			# <html>
			#  <body>
			#   <a>
			#    <b>
			#     text1
			#    </b>
			#    <c>
			#     text2
			#    </c>
			#   </a>
			#  </body>
			# </html>

			b和c就是兄弟节点
				b是c的”大哥“ 因为它在c之前

			.next_sibling 和 .previous_sibling
				b可以用.next_sibling找它的弟弟
				但是不能用 .previous_sibling找它的哥哥，因为它没哥哥只有弟弟
				同理，c只能用.previous_sibling，不能用.next_sibling
					sibling_soup.b.next_sibling
					# <c>text2</c>

					sibling_soup.c.previous_sibling
					# <b>text1</b>

			但在实际文档中你得找两次兄弟，因为只用一次.next_sibling 或者.previous_sibling只能找到字符串或者空白
				link = soup.a
				link
				# <a class="sister" href="http://example.com/elsie" id="link1">Elsie</a>

				link.next_sibling
				# u',\n'


			.next_siblings 和 .previous_siblings

				通过 .next_siblings 和 .previous_siblings 属性可以对当前节点的兄弟节点迭代输出:

					for sibling in soup.a.next_siblings:
						print(repr(sibling))
						# u',\n'
						# <a class="sister" href="http://example.com/lacie" id="link2">Lacie</a>
						# u' and\n'
						# <a class="sister" href="http://example.com/tillie" id="link3">Tillie</a>
						# u'; and they lived at the bottom of a well.'
						# None

					for sibling in soup.find(id="link3").previous_siblings:
						print(repr(sibling))
						# ' and\n'
						# <a class="sister" href="http://example.com/lacie" id="link2">Lacie</a>
						# u',\n'
						# <a class="sister" href="http://example.com/elsie" id="link1">Elsie</a>
						# u'Once upon a time there were three little sisters; and their names were\n'
						# None

		退回和前进
			解析的过程
				<html><head><title>The Dormouse's story</title></head>
				<p class="title"><b>The Dormouse's story</b></p>

				以这个为例
					是先打开标签html 然后打开标签head 再打开标签title 然后字符串 然后关闭title关闭head 打开p

		.next_element 和 .previous_element
			指向下一个被解析的对象(字符串或tag)和指向前一个被解析的对象

		.next_elements 和 .previous_elements
			html_doc = """
			<html><head><title>The Dormouse's story</title></head>

			<p class="title"><b>The Dormouse's story</b></p>

			<p class="story">Once upon a time there were three little sisters; and their names were
			<a href="http://example.com/elsie" class="sister" id="link1">Elsie</a>,
			<a href="http://example.com/lacie" class="sister" id="link2">Lacie</a> and
			<a href="http://example.com/tillie" class="sister" id="link3">Tillie</a>;
			and they lived at the bottom of a well.</p>

			<p class="story">...</p>"""


			from bs4 import BeautifulSoup
			soup = BeautifulSoup(html_doc,"lxml")


			print(soup.prettify())
			print("---------------------")
			def has_class_but_no_id(tag):
				if tag.has_attr('class') and not tag.has_attr('id'):
					return True
			tag = soup.html

			for i in tag.next_elements:
				print(i)
				#print(repr(i)) #repr() 的功能是显示\n
				print("===================")

	搜寻文档树

并发编程
	multiprocessing  多进程模块
		from multiprocessing import Process
		import os
		#开启一个进程
		 p = Process(target=hello, args=([需要的数据]，))#添加一个子进程
		 p.start() #开始进程
		 p.join()  #等待子进程运行结束后继续执行
		 p.is_alive()#是否还活着
		 os.getpid() #返回当前进程id

		进程间通信
			Pipe
				from multiprocessing import Process, Pipe
				conn1, conn2 = Pipe() 连接
				conn1.send(data) 传出数据
				conn2.recv()	输入数据

				from multiprocessing import Process, Pipe
				conn1, conn2 = Pipe()
				def f1():
					conn1.send('Hello shiyanlou')
				def f2():
					data = conn2.recv()
					print(data)
				def main():
					Process(target=f1).start()
					Process(target=f2).start()

				if __name__ == '__main__':
					main()

			Queue
				from multiprocessing import Process, Queue
				queue = Queue()
				#作为参数输入到每个子进程的函数里
				#queue = Queue(maxsize=10)
				#Queue.empty() 方法可以判断队列中是否为空，是否还有数据可以读取，
				#如果返回为 True 表示已经没有数据了。
				def f1(q):
					q.put('Hello shiyanlou') #向queue输入数据
				def f2(q):
					data = q.get() #获得queue里的数据
					print(data)
				def main():
					Process(target=f1, args=(queue,)).start()
					Process(target=f2, args=(queue,)).start()

				if __name__ == '__main__':
					main()

			进程不同步
				import time from multiprocessing
				import Process, Value
				def func(val):
					for i in range(50):
					time.sleep(0.01)
					val.value += 1

				if __name__ == '__main__':
					# 多进程无法使用全局变量，multiprocessing 提供的 Value 是一个代理器，
					# 可以实现在多进程中共享这个变量
					v = Value('i', 0)
					procs = [Process(target=func, args=(v,)) for i in range(10)]
					for p in procs:
						p.start()
					for p in procs:
						p.join()
				print(v.value)

				进程不同步不会加到500，因为可能会有进程同时进行+1

				解决办法
						Lock()

			进程同步
				 49 from multiprocessing import Process,Lock,Value
				 48 def func(val,lock):
				 49         for i in range(50):
				 50                 time.sleep(0.01)
				 51                 with lock:#上锁，上锁代表在一个进程里对这个值进行操作，其他的进程就无法对这个值进行操作
											  #使用 acquire() 方法获取锁，release() 方法释放锁。
				 52                         val.value += 1
				 53
				 54 def main():
				 55         v = Value("i",0)#第一个参数是代表共享的数据类型，第二个是数据的值，这个就相当于全局变量，因为多进程是无法使用全局变量的
				 56         lock = Lock()
				 57         procs = [Process(target = func, args = (v,lock)) for i in range(10)]
				 58         for p in procs:
				 59                 p.start()
				 60         for p in procs:
				 61                 p.join()
				 62         print(v.value)

			进程池
				from multiprocessing import Pool
				def f(i):
					print(i, end=' ', flush=True)
				def main(): # 初始化一个 3 个进程的进程池
					pool = Pool(processes=3)
					for i in range(30):
				# 调用 apply 方法开始处理任务，传入任务处理函数 f，和参数 i
						pool.apply(f, (i,))
					pool.close()
					pool.join()
				if __name__ == '__main__':
					main()

	threading 多线程
		使用函数来创建多线程
			import threading
			def hello(name):
				# get_ident() 函数获取当前线程 id
				print('child thread: {}'.format(threading.get_ident()))
				print('Hello ' + name)
			def main(): # 初始化一个线程，参数传递和使用 Process 一样
				t = threading.Thread(target=hello, args=('shiyanlou',))
				# 启动线程和等待线程结束，和 Process 的接口一样
				t.start()
				t.join()
				print('main thread: {}'.format(threading.get_ident()))
			if __name__ == '__main__':
				main()

		使用类来创建多线程
			from threading import Thread
			class MyThread(Thread):
				def __init__(self, name='kaikai'):
					super().__init__()
					self.name = name

				def run(self):
					for i in range(2):
						print('hello', self.name)

			if __name__ == '__main__':
				thread_01 = MyThread()
				thread_02 = MyThread('MING')
				thread_01.start()
				thread_02.start()

		一些常用函数
			创建线程
			t = Thread(target = func)

			开始子线程
			t.start()

			一直等到本次线程执行完才执行下一个线程
			t.join()

			判断线程是否在执行状态，在返回Ture，不在九返回False
			t.is_alive()
			t.isAlive()

			设置线程是否随主线程退出而退出，默认为False
			t.daemon = True
			t.daemon = False

			设置线程名
			t.name = 'My-Thread'

		锁
			什么是锁
				有锁的才能执行

			一般上锁
				  1 import threading
				  2
				  3 def job1():
				  4     global n, lock
				  5     with lock:
				  6         for i in range(10):
				  7             n+=1
				  8             print('job1',n)
				  9 def job2():
				 10     global n, lock
				 11     with lock:
				 12         for i in range(10):
				 13             n+=10
				 14             print('job2',n)
				 15 lock  = threading.Lock()
				 16 n = 0
				 17 t1 = threading.Thread(target=job1)
				 18 t2 = threading.Thread(target=job2)
				 19 t1.start()
				 20 t2.start()

			防止死锁
				原因
					同一线程，嵌套获取同把锁，造成死锁。
						解决方法，用Rlock

			重复上锁
				 23 def main():
				 24     n = 0
				 25     lock = threading.RLock()
				 26     with lock:
				 27         for i in range(10):
				 28             n += 1
				 29             with lock:
				 30                 print(n)
				 31 t1 = threading.Thread(target=main)
				 32 t1.start()

		GIL(全局锁)
			什么是GIL呢？ >任何Python线程执行前，必须先获得GIL锁，然后，每执行100条字节码，
			解释器就自动释放GIL锁，让别的线程有机会执行。这个GIL全局锁实际上把所有线程的执行代码都给上了锁，所以，
			多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核。

			解决方法
				用其它解释器，因为gil只存在于cpython中

				用多进程

		线程消息通信机制-任务协调
			queue.Queue	控制线程的执行
				from queue import Queue， LifoQueue, PriorityQueue

				Queue  先入先出
				LifoQueue 后进先出
				PriorityQueue 优先队列

				# maxsize默认为0，不受限
				# 一旦>0，而消息数又达到限制，q.put()也将阻塞
				q = Queue(maxsize=0)

				# 阻塞程序，等待队列消息。
				q.get()

				# 获取消息，设置超时时间
				q.get(timeout=5.0)

				# 发送消息
				q.put()

				# 等待所有的消息都被消费完
				q.join()

				# 以下三个方法，知道就好，代码中不要使用

				# 查询当前队列的消息个数
				q.qsize()

				# 队列消息是否都被消费完，True/False
				q.empty()

				# 检测队列里消息是否已满
				q.full()

			例子
				queue例子(LifoQueue差不多)
					from queue import Queue
					from threading import Thread
					import time

					class Student(Thread):
						def __init__(self, name, queue):
							super().__init__()
							self.name = name
							self.queue = queue

						def run(self):
							while True:
								# 阻塞程序，时刻监听老师，接收消息
								msg = self.queue.get()
								# 一旦发现点到自己名字，就赶紧答到
								if msg == self.name:
									print("{}：到！".format(self.name))


					class Teacher:
						def __init__(self, queue):
							self.queue=queue

						def call(self, student_name):
							print("老师：{}来了没？".format(student_name))
							# 发送消息，要点谁的名
							self.queue.put(student_name)


					queue = Queue()
					teacher = Teacher(queue=queue)
					s1 = Student(name="小明", queue=queue)
					s2 = Student(name="小亮", queue=queue)
					s1.start()
					s2.start()

					print('开始点名~')
					teacher.call('小明')
					time.sleep(1)
					teacher.call('小亮')

				PriorityQueue例子
					from queue import PriorityQueue
					a = ((2,'b'),(4,'d'),(3,'c'),(1,'a'),(5,'e'),(6,'f'))#用第一个数字来排序

					queue = PriorityQueue()
					for i in a:
						print("存入",i)
						queue.put(i)

					for i in a:
						print(queue.get()[1])#别忘了这里有一个索引，没有就是一个完整的元组

		线程中的信息隔离
			什么是信息隔离
				1. 主线程中的变量，不会因为其是全局变量，而被子线程获取到；
				2. 主线程也不能获取到子线程中的变量；
				3. 子线程与子线程之间的变量也不能互相访问。

			如何实现
				from threading import local, Thread, currentThread

				# 定义一个local实例
				local_data = local()
				# 在主线中，存入name这个变量
				local_data.name = 'local_data'


				class MyThread(Thread):
					def run(self):
						print("赋值前-子线程：", currentThread(),local_data.__dict__)
						# 在子线程中存入name这个变量
						local_data.name = self.getName()
						print("赋值后-子线程：",currentThread(), local_data.__dict__)


				if __name__ == '__main__':
					print("开始前-主线程：",local_data.__dict__)

					t1 = MyThread()
					t1.start()
					t1.join()

					t2 = MyThread()
					t2.start()
					t2.join()

					print("结束后-主线程：",local_data.__dict__)

				结果
					开始前-主线程： {'name': 'local_data'}

					赋值前-子线程： <MyThread(Thread-1, started 4832)> {}
					赋值后-子线程： <MyThread(Thread-1, started 4832)> {'name': 'Thread-1'}

					赋值前-子线程： <MyThread(Thread-2, started 5616)> {}
					赋值后-子线程： <MyThread(Thread-2, started 5616)> {'name': 'Thread-2'}

					结束后-主线程： {'name': 'local_data'}

			结论
				local实例可以是全局唯一的，只有一个。
				因为你在给local存入或访问变量时，
				它会根据当前的线程的不同从不同的存储空间存入或获取。

		线程池
			原因
				在使用多线程处理任务时也不是线程越多越好，由于在切换线程的时候，
				需要切换上下文环境，依然会造成cpu的大量开销。

			做法
				import time
				import threading
				from concurrent.futures import ThreadPoolExecutor


				def target():
					for i in range(5):
						print('running thread-{}:{}'.format(threading.get_ident(), i))
						time.sleep(1)

				#: 生成线程池最大线程为5个
				pool = ThreadPoolExecutor(5)

				for i in range(100):
					pool.submit(target) # 往线程中提交，并运行

	生成器过度到协程
		def jumping_range(N):
			index = 0
			while index < N:
				# 通过send()发送的信息将赋值给jump，当使用send的时候，会一直执行到下一个yield
				jump = yield index
				if jump is None:
					jump = 1
				index += jump

		if __name__ == '__main__':
			itr = jumping_range(5)
			print(next(itr))
			print(itr.send(2))
			print(next(itr))
			print(itr.send(-1))

	yield from
		为什么要使用协程
			它的特点有 >
				1. 协程是在单线程里实现任务的切换的
				2. 利用同步的方式去实现异步
				3. 不再需要锁，提高了并发性能

		yield from的用法详解
			yield from + 可迭代对象
				可以把可迭代对象里的元素一个一个yield出来

				# 字符串
				astr='ABC'
				# 列表
				alist=[1,2,3]
				# 字典
				adict={"name":"wangbm","age":18}
				# 生成器
				agen=(i for i in range(4,8))

				def gen(*args, **kw):
					for item in args:
						yield from item

				new_list=gen(astr, alist, adict, agen)
				print(list(new_list))

				['A', 'B', 'C', 1, 2, 3, 'name', 'age', 4, 5, 6, 7]

			生成器的嵌套
				# 子生成器
				def average_gen():
					total = 0
					count = 0
					average = 0
					while True:
						new_num = yield average
						count += 1
						total += new_num
						average = total/count

				# 委托生成器
				def proxy_gen():
					while True:
						yield from average_gen()

				# 调用方
				def main():
					calc_average = proxy_gen()
					next(calc_average)            # 预激下生成器
					print(calc_average.send(10))  # 打印：10.0
					print(calc_average.send(20))  # 打印：15.0
					print(calc_average.send(30))  # 打印：20.0

				if __name__ == '__main__':
					main()

			x = yield from
				委托生成器只是充当一个通道，
				但是它并没有权力对子生成器yield回来的内容做拦截
					# 子生成器
					def average_gen():
						total = 0
						count = 0
						average = 0
						while True:
							new_num = yield average
							if new_num is None:
								break
							count += 1
							total += new_num
							average = total/count

						# 每一次return，都意味着当前协程结束。
						return total,count,average

					# 委托生成器
					def proxy_gen():
						while True:
							# 只有子生成器要结束（return）了，yield from左边的变量才会被赋值，后面的代码才会执行。
							total, count, average = yield from average_gen()
							print("计算完毕！！\n总共传入 {} 个数值， 总和：{}，平均数：{}".format(count, total, average))

					# 调用方
					def main():
						calc_average = proxy_gen()
						next(calc_average)            # 预激协程
						print(calc_average.send(10))  # 打印：10.0
						print(calc_average.send(20))  # 打印：15.0
						print(calc_average.send(30))  # 打印：20.0
						calc_average.send(None)      # 结束协程
						# 如果此处再调用calc_average.send(10)，由于上一协程已经结束，将重开一协程

					if __name__ == '__main__':
						main()

					10.0
					15.0
					20.0
					计算完毕！！
					总共传入 3 个数值， 总和：60，平均数：20.0

		为什么要用yield from
			因为可以帮我们处理各种异常状况

	asyncio
		单任务
			定义/创建协程
				async
					from collections.abc import Coroutine
					async def hello(name):
						print('Hello,', name)

					if __name__ == '__main__':
						# 生成协程对象，并不会运行函数内的代码
						coroutine = hello("World")

						# 检查是否是协程 Coroutine 类型
						print(isinstance(coroutine, Coroutine))  # True

				@asyncio.coroutine
					import asyncio
					from collections.abc import Generator, Coroutine

					'''
					只要在一个生成器函数头部用上 @asyncio.coroutine 装饰器
					就能将这个函数对象，【标记】为协程对象。注意这里是【标记】，划重点。
					实际上，它的本质还是一个生成器。
					标记后，它实际上已经可以当成协程使用。后面会介绍。
					'''

					@asyncio.coroutine
					def hello():
						# 异步调用asyncio.sleep(1):
						yield from asyncio.sleep(1)


					if __name__ == '__main__':
						coroutine = hello()
						print(isinstance(coroutine, Generator))  # True
						print(isinstance(coroutine, Coroutine))  # False

			asyncio的几个概念
				event_loop
					事件循环：程序开启一个无限的循环，
					程序员会把一些函数（协程）注册到事件循环上。
					当满足事件发生的时候，调用相应的协程函数。

				coroutine
					协程：协程对象，指一个使用async关键字定义的函数，
					它的调用不会立即执行函数，而是会返回一个协程对象。
					协程对象需要注册到事件循环，由事件循环调用。

				future
					对象： 代表将来执行或没有执行的任务的结果。
					它和task上没有本质的区别

				task
					任务：一个协程对象就是一个原生可以挂起的函数，
					任务则是对协程进一步封装，其中包含任务的各种状态。
					Task 对象是 Future 的子类，它将 coroutine 和 Future 联系在一起，
					将 coroutine 封装成一个 Future 对象。

				async/await
					关键字：python3.5 用于定义协程的关键字，async定义一个协程，
					await用于挂起阻塞的异步调用接口。其作用在一定程度上类似于yield。

			协程是如何工作的
				流程
					定义/创建协程对象 - 定义事件循环对象容器 - 将协程转为task任务 - 将task任务扔进事件循环对象中触发

					import asyncio

					async def hello(name):
						print('Hello,', name)

					# 定义协程对象，但是协程对象却不执行
					coroutine = hello("World")

					# 定义事件循环对象容器
					loop = asyncio.get_event_loop()


					# 将协程转为task任务
					task = loop.create_task(coroutine)
					# task = asyncio.ensure_future(coroutine)

					# 将task任务扔进事件循环对象中并触发
					loop.run_until_complete(task)

			await于yield
				一定程度上，意思是效果上一样（都能实现暂停的效果），但是功能上却不兼容。

				yield from 后面可接 可迭代对象，也可接future对象/协程对象；
				await 后面必须要接 future对象/协程对象

				asyncio.sleep(n)，这货是asyncio自带的工具函数，他可以模拟IO阻塞，他返回的是一个生成器对象。

			绑定回调函数
				法一 同步编程
					import asyncio
					import time

					async def _sleep(x):
						time.sleep(2)
						return '暂停了{}秒！'.format(x)


					coroutine = _sleep(2)
					loop = asyncio.get_event_loop()

					task = asyncio.ensure_future(coroutine)
					loop.run_until_complete(task)

					# task.result() 可以取得返回结果，也可以用future.result(),但必须创建的是Future对象
					print('返回结果：{}'.format(task.result()))

					返回结果：暂停了2秒！

				法二 async自带的添加回调函数功能
					import time
					import asyncio


					async def _sleep(x):
						time.sleep(2)
						return '暂停了{}秒！'.format(x)

					def callback(future):
						print('这里是回调函数，获取返回结果是：', future.result())

					coroutine = _sleep(2)
					loop = asyncio.get_event_loop()
					task = asyncio.ensure_future(coroutine)

					# 添加回调函数
					task.add_done_callback(callback)

					loop.run_until_complete(task)

					这里是回调函数，获取返回结果是： 暂停了2秒！

		多任务

数据分析
	Numpy
		import numpy as np

		创建
			a1 = np.array([1, 2, 3, 4])
			a2 = np.array([[1.0, 2.5, 3], [0.5, 4, 9]])

		其它创建
			np.arange 类似于 Python 内置的 range，创建一维数组；
			np.ones 创建元素值全部为 1 的数组；
			np.zeros 创建元素值全为 0 的数组；
			np.empty 创建空值多维数组，只分配内存，不填充任何值；
			np.random.random 创建元素值为随机值的多维数组；

			a3 = np.zeros((2, 2))
			a4 = np.empty((3, 3), dtype=np.int64)
			不指定dtype默认float64

		使用
			形状
				a1.shape

			改变形状
				a.reshape(4, 3)

			尺寸(数组元素的个数)
				a2.size

			储存的数据类型
				a1.dtype

			数组最大值/最小值
				a1.max()
				a2.min()

			维度
				a.ndim

		索引
			一维数组的索引
				l[:2] 选择列表中前 2 个元素；
				l[2:4] 选择列表的第 3、4 个元素；
				l[1:5:2] 选择列表的第 2 到第 5个元素，且步长为 2。

			多维数组的索引
				二维
					In [160]: a
					Out[160]:
					array([[ 0,  1,  2,  3],
						   [ 4,  5,  6,  7],
						   [ 8,  9, 10, 11]])

					In [161]: a[0]
					Out[161]: array([0, 1, 2, 3])

					In [164]: a[:, 1]
					Out[164]: array([1, 5, 9])

					In [167]: a[0, 1]
					Out[167]: 1

				降维
					二维变一维

				三维
					In [195]: a
					Out[195]:
					array([[[ 0,  1,  2],
							[ 3,  4,  5],
							[ 6,  7,  8]],

						   [[ 9, 10, 11],
							[12, 13, 14],
							[15, 16, 17]],

						   [[18, 19, 20],
							[21, 22, 23],
							[24, 25, 26]]])

					In [209]: a[:, 1]
					Out[209]:
					array([[ 3,  4,  5],
						   [12, 13, 14],
						   [21, 22, 23]])

		多为数组基础运算
			对元素进行运算
				a += 1
				b *= 2

			多维数组和数字间的运算
				注意：这个只是对应位置的元素相互+-*/
				a + b
				a * b

			逻辑比较运算
				In [115]: a = np.arange(12).reshape(4, 3)

				In [116]: b = a > 5

				In [117]: b
				Out[117]:
				array([[False, False, False],
					   [False, False, False],
					   [ True,  True,  True],
					   [ True,  True,  True]], dtype=bool)

				In [118]: a[b]
				Out[118]: array([ 6,  7,  8,  9, 10, 11])

			多维数组的计算方法
				a.sum 计算多维数组的所有元素的和；
				a.max 最大值计算；
				a.min 最小值计算；
				a.mean 平均值计算；
				a.std 标准差计算；
				a.var 方差计算；

				以上方法都有axis参数，用于指定计算每行或每列的值
				axis = 1 每行
				axis = 0 每列
				没有axis参数指定所有元素

			np自带的通用函数
				np.sqrt 开方运算；
				np.dot 矩阵乘法；
				np.sort 排序；
				np.linalg 模块中包含了一些基本的线性代数计算函数；

	pandas
		from pandas import Series, DataFarme
		import pandas as pd

		创建
			列表创建
				Series([1, 2, 3, 4, 5])
			字典创建
				Series({'a':1})
			np对象创建
				DataFrame(np.random.randn(4, 4))

			定义列名/行名
				df1 = DataFrame(np.arange(9).reshape(3,3), columns=list('ABC'), index=list('abc'))

				In [285]: df1
				Out[285]:
				   A  B  C
				a  0  1  2
				b  3  4  5
				c  6  7  8

		选择元素
			Series
				In [105]: s2
				Out[105]:
				a    1
				b    2
				c    3
				d    4
				e    5
				dtype: int64

				In [106]: s2[0]
				Out[106]: 1

				In [107]: s2['a']
				Out[107]: 1

				In [108]: s2[0:3]
				Out[108]:
				a    1
				b    2
				c    3
				dtype: int64

				In [109]: s2['a':'c']
				Out[109]:
				a    1
				b    2
				c    3
				dtype: int64

				In [134]: s2.iloc[0:3]
				Out[134]:
				a    1
				b    2
				c    3
				dtype: int64

				In [135]: s2.loc['a':'c']
				Out[135]:
				a    1
				b    2
				c    3
				dtype: int64

			DataFrame
				In [207]: df.loc[:, ['B', 'C', 'D']]
				Out[207]:
						  B         C         D
				a -1.095055  0.410799 -0.327141
				b  0.565889  0.087992  1.842047
				c  1.338187 -0.602925  0.414470
				d -1.870531 -1.238206 -0.050025

				df.loc[:,'B':'D']
				df.loc[1:2,1:3]

		缺失和数据自动对齐
			两个表都有的显示，否则NaN
				In [266]: df1
				Out[266]:
				   A  B  C
				a  0  1  2
				b  3  4  5
				c  6  7  8

				In [267]: df2
				Out[267]:
				   A  B   D   E
				b  0  1   2   3
				c  4  5   6   7
				d  8  9  10  11

				In [268]: df1 + df2
				Out[268]:
					  A     B   C   D   E
				a   NaN   NaN NaN NaN NaN
				b   3.0   5.0 NaN NaN NaN
				c  10.0  12.0 NaN NaN NaN
				d   NaN   NaN NaN NaN NaN

				In [275]: df1.add(df2, fill_value=0)
				Out[275]:
					  A     B    C     D     E
				a   0.0   1.0  2.0   NaN   NaN
				b   3.0   5.0  5.0   2.0   3.0
				c  10.0  12.0  8.0   6.0   7.0
				d   8.0   9.0  NaN  10.0  11.0

		常用运算
			df1 = DataFrame(np.arange(9).reshape(3,3), columns=list('ABC'), index=list('abc'))
			In [285]: df1
			Out[285]:
			   A  B  C
			a  0  1  2
			b  3  4  5
			c  6  7  8

			apply
				In [286]: f = lambda x: x.max() - x.min()

				In [287]: df1.apply(f)
				Out[287]:
				A    6
				B    6
				C    6
				dtype: int64

				In [288]: df1.apply(f, axis=1)
				Out[288]:
				a    2
				b    2
				c    2
				dtype: int64

			常用方法
				In [312]: df1.sum()
				Out[312]:
				A     9
				B    12
				C    15
				dtype: int64

				In [313]: df1.mean()
				Out[313]:
				A    3.0
				B    4.0
				C    5.0
				dtype: float64

				In [314]: df1.sum(axis=1)
				Out[314]:
				a     3
				b    12
				c    21
				dtype: int64

				In [315]: df1.describe()
				Out[315]:
						 A    B    C
				count  3.0  3.0  3.0
				mean   3.0  4.0  5.0
				std    3.0  3.0  3.0
				min    0.0  1.0  2.0
				25%    1.5  2.5  3.5
				50%    3.0  4.0  5.0
				75%    4.5  5.5  6.5
				max    6.0  7.0  8.0

				head/tail
					ts.head(5) 方法显示前 5 个元素，而使用 ts.tail(5) 显示了后 5 个元素。

					In [628]: ts.head(5)
					Out[628]:
					2018-01-01 00:00:00    0
					2018-01-01 01:00:00    1
					2018-01-01 02:00:00    2
					2018-01-01 03:00:00    3
					2018-01-01 04:00:00    4
					Freq: H, dtype: int64

					In [637]: ts.tail(5)
					Out[637]:
					2018-01-02 19:00:00    43
					2018-01-02 20:00:00    44
					2018-01-02 21:00:00    45
					2018-01-02 22:00:00    46
					2018-01-02 23:00:00    47
					Freq: H, dtype: int64

			数据合并和分组
				合并
					concat上下拼接
						In [332]: df1 = DataFrame(np.random.randn(3, 3))

						In [333]: df2 = DataFrame(np.random.randn(3, 3), index=[5, 6, 7])

						In [334]: df1
						Out[334]:
								  0         1         2
						0  0.588675 -0.578547  0.209162
						1 -0.785453 -0.525210  0.555500
						2  0.243755  0.630920 -0.188002

						In [335]: df2
						Out[335]:
								  0         1         2
						5 -0.298254 -1.359094  0.765679
						6  1.352959  2.129675  0.410192
						7  0.742227  0.497452 -0.321858

						In [336]: pd.concat([df1, df2])
						Out[336]:
								  0         1         2
						0  0.588675 -0.578547  0.209162
						1 -0.785453 -0.525210  0.555500
						2  0.243755  0.630920 -0.188002
						5 -0.298254 -1.359094  0.765679
						6  1.352959  2.129675  0.410192
						7  0.742227  0.497452 -0.321858

					merge左右拼接
						In [416]: df1 = DataFrame({'user_id': [5348, 13], 'course': [12, 45], 'minutes': [9, 36]})

						In [417]: df2 = DataFrame({'course': [12, 45], 'name': ['Linux 基础入门', '数据分析']})

						In [418]: df1
						Out[418]:
						   course  minutes  user_id
						0      12        9     5348
						1      45       36       13

						In [419]: df2
						Out[419]:
						   course        name
						0      12  Linux 基础入门
						1      45        数据分析

						In [420]: pd.merge(df1, df2)
						Out[420]:
						   course  minutes  user_id        name
						0      12        9     5348  Linux 基础入门
						1      45       36       13        数据分析

				分组
					df['xxxx'] == xxxx
						In [458]: df = DataFrame({'user_id': [5348, 13, 5348], 'course': [12, 45, 23], 'minutes': [9, 36, 45]})

						In [459]: df
						Out[459]:
						   course  minutes  user_id
						0      12        9     5348
						1      45       36       13
						2      23       45     5348

						In [472]: df[df['user_id'] == 5348]
						Out[472]:
						   course  minutes  user_id
						0      12        9     5348
						2      23       45     5348

						In [475]: df[df['user_id'] == 5348]['minutes']
						Out[475]:
						0     9
						2    45
						Name: minutes, dtype: int64

					[['xx','xxxx']] groupby
						In [485]: df[['user_id', 'minutes']]
						Out[485]:
						   user_id  minutes
						0     5348        9
						1       13       36
						2     5348       45

						In [486]: df[['user_id', 'minutes']].groupby('user_id').sum()
						Out[486]:
								 minutes
						user_id
						13            36
						5348          54

			时间序列的处理
				时间戳
					In [2]: pd.Timestamp("2018.1.1")
					Out[2]: Timestamp('2018-01-01 00:00:00')

					In [3]: pd.to_datetime("2018.1.1")
					Out[3]: Timestamp('2018-01-01 00:00:00')

					In [5]: pd.to_datetime(["2018.1.1", "2019.1.1"])
					Out[5]: DatetimeIndex(['2018-01-01', '2019-01-01'], dtype='datetime64[ns]', freq=None)

					In [15]: pd.to_datetime(pd.Series(['2017-1-1', '2017-1-2', '2017-1-3']))
					Out[15]:
					0   2017-01-01
					1   2017-01-02
					2   2017-01-03
					dtype: datetime64[ns]

				时间戳索引
					pd.to_datetime
						In [16]: pd.to_datetime(['2017-1-1', '2017-1-2', '2017-1-3'])
						In [16]: DatetimeIndex(['2017-01-01', '2017-01-02', '2017-01-03'], dtype='datetime64[ns]', freq=None)

						In [17]: pd.to_datetime(pd.DataFrame({'year': [2017, 2017], 'month': [1, 2], 'day': [3, 4], 'hour': [5, 6]}))
						Out[17]:
						0   2017-01-03 05:00:00
						1   2017-02-04 06:00:00
						dtype: datetime64[ns]

						pd.to_datetime(Series/DataFrame)返回的是Series。
						pd.to_datetime(List)返回的是DatetimeIndex。

						忽略无效数据的报错
							# 遇到无效数据报错
							In [17]: pd.to_datetime(['2017-1-1', 'invalid'], errors='raise')
							ValueError: Unknown string format

							# 忽略无效数据
							In [18]: pd.to_datetime(['2017-1-1', 'invalid'], errors='ignore')
							Out[18]: array(['2017-1-1', 'invalid'], dtype=object)

							# 将无效数据显示为 NaT
							In [19]: pd.to_datetime(['2017-1-1', 'invalid'], errors='coerce')
							Out[19]: DatetimeIndex(['2017-01-01', 'NaT'], dtype='datetime64[ns]', freq=None)

					pd.date_range()
						pandas.date_range(start=None, end=None, periods=None, freq=’D’, tz=None, normalize=False,
							name=None, closed=None, **kwargs)

							常用参数的含义如下：

								start= ：设置起始时间
								end=：设置截至时间
								periods= ：设置时间区间，若 None 则需要设置单独设置起止和截至时间。
								freq= ：设置间隔周期。
								tz=：设置时区。

							其中，freq= 参数是非常关键的参数，我们可以设置的周期有：

								freq='s': 秒
								freq='min' : 分钟
								freq='H': 小时
								freq='D': 天
								freq='w': 周
								freq='m': 月
								freq='BM': 每个月最后一天
								freq='W'：每周的星期日

						生成
							# 从 2017-1-1 开始，以 1s 为间隔，向后推 10 次
							In [23]: pd.date_range('2017-1-1',periods=10,freq='s')
							Out[23]:
							DatetimeIndex(['2017-01-01 00:00:00', '2017-01-01 00:00:01',
										   '2017-01-01 00:00:02', '2017-01-01 00:00:03',
										   '2017-01-01 00:00:04', '2017-01-01 00:00:05',
										   '2017-01-01 00:00:06', '2017-01-01 00:00:07',
										   '2017-01-01 00:00:08', '2017-01-01 00:00:09'],
										  dtype='datetime64[ns]', freq='S')

							# 从 2017-1-1 开始，以 1H20min 为间隔，向后推 10 次
							In [24]: pd.date_range('1/1/2017', periods=10, freq='1H20min')
							Out[24]:
							DatetimeIndex(['2017-01-01 00:00:00', '2017-01-01 01:20:00',
										   '2017-01-01 02:40:00', '2017-01-01 04:00:00',
										   '2017-01-01 05:20:00', '2017-01-01 06:40:00',
										   '2017-01-01 08:00:00', '2017-01-01 09:20:00',
										   '2017-01-01 10:40:00', '2017-01-01 12:00:00'],
										  dtype='datetime64[ns]', freq='80T')

						操作
							In [32]: a
							Out[32]:
							DatetimeIndex(['2017-01-01 00:00:00', '2017-01-02 01:00:00',
										   '2017-01-03 02:00:00', '2017-01-04 03:00:00',
										   '2017-01-05 04:00:00', '2017-01-06 05:00:00',
										   '2017-01-07 06:00:00', '2017-01-08 07:00:00',
										   '2017-01-09 08:00:00', '2017-01-10 09:00:00'],
										  dtype='datetime64[ns]', freq='25H')

							# 选取索引为 1 的时间戳
							In [33]: a[1]
							Out[33]: Timestamp('2017-01-02 01:00:00', freq='25H')

							# 对索引从 0 到 4 的时间进行切片
							In [34]: a[:5]
							Out[34]:
							DatetimeIndex(['2017-01-01 00:00:00', '2017-01-02 01:00:00',
										   '2017-01-03 02:00:00', '2017-01-04 03:00:00',
										   '2017-01-05 04:00:00'],
										  dtype='datetime64[ns]', freq='25H')

				DateOffset偏移
					In [1]: import pandas as pd
					In [2]: from pandas import offsets

					In [3]: a = pd.date_range('2017-1-1',periods=10,freq='1D1H')

					In [4]: a
					Out[4]:
					DatetimeIndex(['2017-01-01 00:00:00', '2017-01-02 01:00:00',
								   '2017-01-03 02:00:00', '2017-01-04 03:00:00',
								   '2017-01-05 04:00:00', '2017-01-06 05:00:00',
								   '2017-01-07 06:00:00', '2017-01-08 07:00:00',
								   '2017-01-09 08:00:00', '2017-01-10 09:00:00'],
								  dtype='datetime64[ns]', freq='25H')

					# 使用 DateOffset 对象让 a 依次增加 1 个月 + 1 天 + 1 小时
					In [5]: a + offsets.DateOffset(months=1, days=1, hours=1)
					Out[5]:
					DatetimeIndex(['2017-02-02 01:00:00', '2017-02-03 02:00:00',
								   '2017-02-04 03:00:00', '2017-02-05 04:00:00',
								   '2017-02-06 05:00:00', '2017-02-07 06:00:00',
								   '2017-02-08 07:00:00', '2017-02-09 08:00:00',
								   '2017-02-10 09:00:00', '2017-02-11 10:00:00'],
								  dtype='datetime64[ns]', freq='D')

					# 使用 DateOffset 对象让 a 向后偏移 2 周

					In [6]: a + 2*offsets.Week()
					Out[6]:
					DatetimeIndex(['2017-01-15 00:00:00', '2017-01-16 01:00:00',
								   '2017-01-17 02:00:00', '2017-01-18 03:00:00',
								   '2017-01-19 04:00:00', '2017-01-20 05:00:00',
								   '2017-01-21 06:00:00', '2017-01-22 07:00:00',
								   '2017-01-23 08:00:00', '2017-01-24 09:00:00'],
								  dtype='datetime64[ns]', freq='25H')

				Period时间间隔
					pd.Period
						# 1 年跨度
						In [2]: pd.Period('2017')
						Out[2]: Period('2017', 'A-DEC')

						# 1 个月跨度
						In [3]: pd.Period('2017-1')
						Out[3]: Period('2017-01', 'M')

						# 1 天跨度
						In [4]: pd.Period('2017-1-1')
						Out[4]: Period('2017-01-01', 'D')

						# 1 小时跨度
						In [8]: pd.Period('2017-1-1 12')
						Out[8]: Period('2017-01-01 12:00', 'H')

						# 1 分钟跨度
						In [5]: pd.Period('2017-1-1 12:00')
						Out[5]: Period('2017-01-01 12:00', 'T')

						# 1 秒跨度
						In [6]: pd.Period('2017-1-1 12:05:00')
						Out[6]: Period('2017-01-01 12:05:00', 'S')

					pandas.period_range()
						In [9]: pd.period_range('2017-1','2018-1',freq='M')
						Out[9]:
						PeriodIndex(['2017-01', '2017-02', '2017-03', '2017-04', '2017-05', '2017-06',
									 '2017-07', '2017-08', '2017-09', '2017-10', '2017-11', '2017-12',
									 '2018-01'],
									dtype='period[M]', freq='M')

					区别
						In [15]: pd.Period('2017-1-1')
						Out[15]: Period('2017-01-01', 'D')

						In [16]: pd.Timestamp('2017-1-1')
						Out[16]: Timestamp('2017-01-01 00:00:00')

				时序数据检索
					In [1]: import numpy as np

					In [2]: import pandas as pd

					# 生成时间戳索引
					In [3]: i = pd.date_range('2017-1-1', periods=20, freq='M')

					# 生成随机数据并添加时间戳作为索引
					In [4]: data = pd.Series(np.random.randn(len(i)), index = i)

					# 查看数据
					In [5]: data
					Out[5]:
					2017-01-31   -1.233579
					2017-02-28    0.494723
					2017-03-31   -2.160592
					2017-04-30    0.517173
					2017-05-31   -1.984762
					2017-06-30    0.655989
					2017-07-31    0.919411
					2017-08-31    0.114805
					2017-09-30   -0.080374
					2017-10-31    1.360448
					2017-11-30   -0.417094
					2017-12-31    0.555434
					2018-01-31    1.659271
					2018-02-28   -0.514907
					2018-03-31    0.330979
					2018-04-30   -0.707362
					2018-05-31   -0.724524
					2018-06-30    0.362518
					2018-07-31    0.157280
					2018-08-31   -0.724665
					Freq: M, dtype: float64

					# 检索 2017 年的所有数据
					In [12]: data['2017']
					Out[12]:
					2017-01-31   -1.233579
					2017-02-28    0.494723
					2017-03-31   -2.160592
					2017-04-30    0.517173
					2017-05-31   -1.984762
					2017-06-30    0.655989
					2017-07-31    0.919411
					2017-08-31    0.114805
					2017-09-30   -0.080374
					2017-10-31    1.360448
					2017-11-30   -0.417094
					2017-12-31    0.555434
					Freq: M, dtype: float64

					# 检索 2017 年 7 月到 2018 年 3 月之间的所有数据
					In [13]: data['2017-07':'2018-03']
					Out[13]:
					2017-07-31    0.919411
					2017-08-31    0.114805
					2017-09-30   -0.080374
					2017-10-31    1.360448
					2017-11-30   -0.417094
					2017-12-31    0.555434
					2018-01-31    1.659271
					2018-02-28   -0.514907
					2018-03-31    0.330979
					Freq: M, dtype: float64

					# 使用 loc 方法检索 2017 年 1 月的所有数据
					In [14]: data.loc['2017-01']
					Out[14]:
					2017-01-31   -1.233579
					Freq: M, dtype: float64

					# 使用 truncate 方法检索 2017-3-1 到 2018-4-2 期间的数据
					In [17]: data.truncate(before='2017-3-1',after='2018-4-2')
					Out[17]:
					2017-03-31   -2.160592
					2017-04-30    0.517173
					2017-05-31   -1.984762
					2017-06-30    0.655989
					2017-07-31    0.919411
					2017-08-31    0.114805
					2017-09-30   -0.080374
					2017-10-31    1.360448
					2017-11-30   -0.417094
					2017-12-31    0.555434
					2018-01-31    1.659271
					2018-02-28   -0.514907
					2018-03-31    0.330979
					Freq: M, dtype: float64

				时序数据偏移
					In [1]: import numpy as np

					In [2]: import pandas as pd

					# 生成时间戳索引
					In [3]: i = pd.date_range('2017-1-1', periods=5, freq='M')

					# 生成随机数据并添加时间戳作为索引
					In [4]: data = pd.Series(np.random.randn(len(i)), index = i)

					# 查看数据
					In [5]: data
					Out[5]:
					2017-01-31    0.830480
					2017-02-28    0.348324
					2017-03-31   -0.622078
					2017-04-30   -1.192675
					2017-05-31    0.441947
					Freq: M, dtype: float64

					# 将索引向前位移 3 个单位，也就是数据向后位移 3 个单位，缺失数据 Pandas 会用 NaN 自动填充
					In [8]: data.shift(3)
					Out[8]:
					2017-01-31         NaN
					2017-02-28         NaN
					2017-03-31         NaN
					2017-04-30    0.830480
					2017-05-31    0.348324
					Freq: M, dtype: float64

					# 将索引向后位移 3 个单位，也就是数据向前位移 3 个单位
					In [9]: data.shift(-3)
					Out[9]:
					2017-01-31   -1.192675
					2017-02-28    0.441947
					2017-03-31         NaN
					2017-04-30         NaN
					2017-05-31         NaN
					Freq: M, dtype: float64

					# 将索引的时间向后移动 3 天
					In [10]: data.shift(3,freq='D')
					Out[10]:
					2017-02-03    0.830480
					2017-03-03    0.348324
					2017-04-03   -0.622078
					2017-05-03   -1.192675
					2017-06-03    0.441947
					dtype: float64

				时序数据重采样
					In [1]: import pandas as pd

					In [2]: import numpy as np

					In [3]: i = pd.date_range('2017-1-1', periods=20, freq='D')

					In [4]: data = pd.Series(np.random.randn(len(i)), index = i)

					In [5]: data
					Out[5]:
					2017-01-01    0.384984
					2017-01-02    0.341555
					2017-01-03   -0.100246
					2017-01-04   -0.660066
					2017-01-05    0.007575
					2017-01-06    2.402068
					2017-01-07   -0.365657
					2017-01-08   -0.853025
					2017-01-09    0.588139
					2017-01-10    0.047322
					2017-01-11    0.213384
					2017-01-12    1.056038
					2017-01-13   -1.588518
					2017-01-14    0.076655
					2017-01-15    1.467056
					2017-01-16   -1.877541
					2017-01-17    0.003218
					2017-01-18   -0.811914
					2017-01-19    0.143571
					2017-01-20    0.837088
					Freq: D, dtype: float64

					# 按照 2 天进行降采样，并选取对应 2 天的最大值作为新数据
					In [9]: data.resample('2D').max()
					Out[9]:
					2017-01-01    0.384984
					2017-01-03   -0.100246
					2017-01-05    2.402068
					2017-01-07   -0.365657
					2017-01-09    0.588139
					2017-01-11    1.056038
					2017-01-13    0.076655
					2017-01-15    1.467056
					2017-01-17    0.003218
					2017-01-19    0.837088
					Freq: 2D, dtype: float64

					# 按照 2 天进行降采样，并将对应 2 天数据的原值、最大值、最小值、以及临近值列出
					In [10]: data.resample('2D').ohlc()
					Out[10]:
									open      high       low     close
					2017-01-01  0.384984  0.384984  0.341555  0.341555
					2017-01-03 -0.100246 -0.100246 -0.660066 -0.660066
					2017-01-05  0.007575  2.402068  0.007575  2.402068
					2017-01-07 -0.365657 -0.365657 -0.853025 -0.853025
					2017-01-09  0.588139  0.588139  0.047322  0.047322
					2017-01-11  0.213384  1.056038  0.213384  1.056038
					2017-01-13 -1.588518  0.076655 -1.588518  0.076655
					2017-01-15  1.467056  1.467056 -1.877541 -1.877541
					2017-01-17  0.003218  0.003218 -0.811914 -0.811914
					2017-01-19  0.143571  0.837088  0.143571  0.837088

					# 时间频率从天提升到小时，并使用相同的数据对新增加行填充
					In [11]: data.resample('H').ffill()
					Out[11]:
					2017-01-01 00:00:00    0.384984
					2017-01-01 01:00:00    0.384984
					2017-01-01 02:00:00    0.384984
					2017-01-01 03:00:00    0.384984
					2017-01-01 04:00:00    0.384984

											 ...

					2017-01-19 21:00:00    0.143571
					2017-01-19 22:00:00    0.143571
					2017-01-19 23:00:00    0.143571
					2017-01-20 00:00:00    0.837088
					Freq: H, Length: 457, dtype: float64


					# 时间频率从天提升到小时，不对新增加行填充
					In [12]: data.resample('H').asfreq()
					Out[12]:
					2017-01-01 00:00:00    0.384984
					2017-01-01 01:00:00         NaN
					2017-01-01 02:00:00         NaN

											 ...

					2017-01-19 23:00:00         NaN
					2017-01-20 00:00:00    0.837088
					Freq: H, Length: 457, dtype: float64

					# 时间频率从天提升到小时，只对新增加前 3 行填充
					In [13]: data.resample('H').ffill(limit=3)
					Out[13]:
					2017-01-01 00:00:00    0.384984
					2017-01-01 01:00:00    0.384984
					2017-01-01 02:00:00    0.384984
					2017-01-01 03:00:00    0.384984
					2017-01-01 04:00:00         NaN
					2017-01-01 05:00:00         NaN

											 ...

					2017-01-19 21:00:00         NaN
					2017-01-19 22:00:00         NaN
					2017-01-19 23:00:00         NaN
					2017-01-20 00:00:00    0.837088
					Freq: H, Length: 457, dtype: float64

		绘图
			In [82]: import matplotlib.pyplot as plt

			In [83]: import numpy as np

			In [84]: import pandas as pd

			In [85]: from pandas import Series, DataFrame

			In [79]: s = Series(np.random.randn(10).cumsum(), index=np.arange(0, 100, 10))

			In [80]: s.plot()
			Out[80]: <matplotlib.axes._subplots.AxesSubplot at 0x117e3e588>

			In [81]: plt.show()

			In [86]: df = pd.DataFrame(np.random.rand(5,4), columns=['A', 'B', 'C', 'D'])

			In [87]: df.boxplot()
			Out[87]: <matplotlib.axes._subplots.AxesSubplot at 0x115c2f5f8>

			In [88]: plt.show()

	matplotib
		matplotlib对象
			matplotlib 中主要的绘图对象列表如下：
				Figure 对象，可以想象为一张画布；
				Axes 对象，字面理解为坐标轴（因为每一个 Axes 都有一套 X Y轴坐标系，绘制图形时基于此坐标系绘制。) 也可以认为是子图，在一个 Figure 对象中可以包含多个 Axes 对象，也就是说一张画布可以包含多个子图；
				Line2D 对象，代表线条；
				Text 对象，代表了文字，比如一张子图需要标题，就可以使用一个 Text 对象；

		创建画布
			fig = plt.figure()

		创建子图
			ax1 = plt.add_subplot(2,2,1)

		查看Figure/axes
			plt.gcf() 和 plt.gca()

		显示图形
			fig.show()
			只能显示一次

		子图设置
			fig = plt.figure()
			ax = fig.add_subplot(1,1,1)

			# 设置标题
			ax.set_title("Axes Example")

			# 设置刻度
			major_ticks = np.arange(0, 101, 20)
			minor_ticks = np.arange(0, 101, 5)

			ax.set_xticks(major_ticks)
			ax.set_xticks(minor_ticks, minor=True)  #minnor=True 表示设置更小的刻度
			ax.set_yticks(major_ticks)
			ax.set_yticks(minor_ticks, minor=True)

			# 设置 X, Y 轴 标签
			ax.set_xlabel("X axis")
			ax.set_ylabel("Y axis")

			# 设置网格
			ax.grid(which='minor', alpha=0.2)#which=‘mjnor’表示显示小刻度的网格
			ax.grid(which='major', alpha=0.5)

			# 添加文字
			ax.text(42.5, 50, "shiyanlou")#添加文字到坐标中心

		绘制曲线
			import numpy as np
			import matplotlib.pyplot as plt

			x = np.linspace(0, 1,100)
			fig = plt.figure()
			ax = fig.add_subplot(1,1,1)
			ax.set_title("shiyanlou")

			ax.plot(x, x ** (1/8), 'b--', label=r'$y = x^{1/8}$')
			ax.plot(x, x ** 8, 'r--', label=r'$y = x^{8}$')

			ax.plot(x, x ** (1/2), 'r.', label=r'$y = x^{1/2}$')
			ax.plot(x, x ** 2, 'b.', label=r'$y = x^{2}$')

			ax.plot(x, x, 'g-', label=r'$y = x$')

			ax.legend()#显示label里的参数作为图例
			ax.axis([0, 1, 0, 1])#这hi是xy坐标范围

		绘制常用图形
			线形图
				In [1]: import matplotlib.pyplot as plt
				import numpy as
				In [2]: import numpy as np

				In [3]: fig = plt.figure()

				In [4]: ax = fig.add_subplot(1,1,1)

				In [5]: x = np.arange(100)

				In [6]: ax.plot(x,2*x+x**2)
				Out[6]: [<matplotlib.lines.Line2D at 0x7fffd3a41ef0>]

				In [7]: fig.show()


			直方图
				import numpy as np
				import matplotlib.pyplot as plt

				fig = plt.figure()
				ax = fig.add_subplot(1,1,1)

				data = np.random.normal(0, 20, 1000)
				bins = np.arange(-100, 100, 5)
				ax.hist(data, bins=bins)
				fig.show()

			散点图
				import numpy as np
				import matplotlib.pyplot as plt

				fig = plt.figure()
				ax = fig.add_subplot(1,1,1)

				x = np.arange(1, 101)
				y = 20 + 3 * x + np.random.normal(0, 60, 100)
				ax.scatter(x, y)
				fig.show()

			箱线图
				import numpy as np
				import matplotlib.pyplot as plt

				fig = plt.figure()
				ax = fig.add_subplot(1,1,1)

				# 产生 50 个小于 100 的随机数
				spread = np.random.rand(50) * 100
				# 产生 25 个值为 50 的数据
				center = np.ones(25) * 50
				# 异常值
				outlier_high = np.random.rand(10) * 100 + 100
				outlier_low = np.random.rand(10) * -100
				data = np.concatenate((spread, center, outlier_high, outlier_low), 0)
				ax.boxplot(data)
				fig.show()

datetime
	date
		>>> from datetime import date, datetime, timedelta

		日期时间的获取：

		# 获取当前日期
		>>> date.today()
		datetime.date(2017, 8, 30)

		# 获得格林威治时间，即伦敦时间，比北京时间慢 8 小时
		>>> datetime.utcnow()
		datetime.datetime(2017, 8, 30, 6, 15, 15, 931110)

		# 获得本地时间，即北京时间
		>>> t = datetime.now()
		>>> t
		datetime.datetime(2017, 8, 30, 14, 15, 56, 887176)
		>>> t.day
		30
		>>> t.year
		2017
		>>> t.minute
		17

	datetime
		# 用 strftime 方法将 datetime 数据类型转换为字符串 >
		>> datetime.strftime(t, '%Y-%m-%d %H:%M:%S') '2017-08-30 14:17:56'
		# 用 striptime 方法将字符串转换为 datetime 数据类型
		>>> datetime.strptime('2017-10-01 00:00:00', '%Y-%m-%d %H:%M:%S')
		datetime.datetime(2017, 10, 1, 0, 0)
	timedelta
		>>> t datetime.datetime(2017, 8, 30, 14, 17, 56, 887176)
		# 所有参数均为可选参数，且默认都是 0，参数值可以是整数、浮点数、正数或负数
		>>> t + timedelta(weeks=1, days=-3, hours=3, minutes=-10)
		datetime.datetime(2017, 9, 3, 17, 7, 56, 887176)

base64
	import base64
	>>> base64.b64encode(b'Hello, shiyanlou!')
	b'SGVsbG8sIHNoaXlhbmxvdSE='
	>>> base64.b64decode(b'SGVsbG8sIHNoaXlhbmxvdSE=')
	b'Hello, shiyanlou!'

collections
	https://eastlakeside.gitbooks.io/interpy-zh/content/collections/collections.html

getopts
	#!/usr/bin/env python3.5
	import urllib.request
	import getopt
	import sys
	opts,args = getopt.getopt(sys.argv[1:],'-h-f:-v',['help','filename=','version'])
	for opt_name,opt_value in opts:
		if opt_name in ('-h','--help'):
			print("[*] Help info")
			exit()
		if opt_name in ('-v','--version'):
			print("[*] Version is 0.01 ")
			exit()
		if opt_name in ('-f','--filename'):
			fileName = opt_value
			print("[*] Filename is ",fileName)
	# do something
		exit()

	root@Kali:~/python# python3.5 test.py --filename=test
	[*] Filename is test
	root@Kali:~/python# python3.5 test.py --filename=
	[*] Filename is
	root@Kali:~/python# python3.5 test.py --help
	[*] Help info root
	@Kali:~/python# python3.5 test.py --version
	[*] Version is 0.01
	root@Kali:~/python# python3.5 test.py -v
	[*] Version is 0.01
	root@Kali:~/python# python3.5 test.py -f test
	[*] Filename is test

	设置时：
		短参数需要值时要加:,如-f:
		长参数需要值时要加=,如--filename=

	opts和args
		opts 为分析出的格式信息。args 为不属于格式信息的剩余的命令行参数。
		opts 是一个两元组的列表。每个元素为：( 选项串, 附加参数) 。如果没有附加参数则为空串''

configparser
	配置文件的内容
		[DEFAULT]
		ServerAliveInterval = 45
		Compression = yes
		CompressionLevel = 9
		ForwardX11 = yes

		[bitbucket.org]
		User = hg

		[topsecret.server.com]
		Port = 50022
		ForwardX11 = no

	使用configparser
		import configparser
		>>> config = configparser.ConfigParser()
		>>> config.sections()
		[]
		>>> config.read('example.ini')#读取
		['example.ini']
		>>> config.sections()#【】内的值
		['bitbucket.org', 'topsecret.server.com']
		>>> 'bitbucket.org' in config #是否是config【】里的值，只能识别到这一层
		True
		>>> 'bytebong.com' in config
		False
		>>> config['bitbucket.org']['User']#可以像字典一样引用
		'hg'
		>>> config['DEFAULT']['Compression']
		'yes'

		>>> topsecret = config['topsecret.server.com']
		>>> topsecret['ForwardX11']
		'no'
		>>> topsecret['Port']
		'50022'
		>>> for key in config['bitbucket.org']:  #也可以像字典一样被迭代，也可以迭代出【】里的值
		...     print(key)
		user
		compressionlevel
		serveraliveinterval
		compression
		forwardx11
		>>> config['bitbucket.org']['ForwardX11']
		'yes'
		>>> config['bitbucket.org']['User'] = 'hg' #这个值必须是字符串
		>>> config['topsecret.server.com'] = {}#
		>>> with open('example.ini', 'w') as configfile:
				config.write(configfile)#向文件写数据

	最里面的值必须是字符串，所以要存其它的值得转换

SQLAIchemy(ORM)
	它是什么
		是一种ORM工具
		orm是对象关系映射，有了ORM就不用编写sql语句，这样就可以在python中访问mysql数据库。
		说白了就是一个中介机构一样

	环境的配置
		virtualenv
			这是一个隔离的虚拟环境

			$ cd ~/Code
			$ sudo pip install virtualenv
			$ virtualenv -p /usr/bin/python3.5 env
			$ source env/bin/activate
			$ pip install sqlalchemy ipython mysqlclient $ deactivate

	连接数据库
		In [1]: from sqlalchemy import create_engine
		In [2]: engine = create_engine('mysql://root:@localhost/shiyanlou')

		服务器的地址格式
			mysql://<user>:<password>@<host>/<db_name>

	与数据库数据表映射（对象关系映射）
		不管映射有的还是创建一个新的首先都得先创建一个Base的基类
			In [12]: from sqlalchemy.ext.declarative import declarative_base
			In [13]: Base = declarative_base()

		连接已有的数据库表
			不需要添加外键的表格

				In [19]: from sqlalchemy import Column, Integer, String
				In [20]: class User(Base):
				...: __tablename__ = 'user'
				...: id = Column(Integer, primary_key=True)
				...: name = Column(String)
				...: email = Column(String)
				...: def __repr__(self):
				...: return "<User(name=%s)>" % self.name
				In [19]: from sqlalchemy import Column, Integer, String

				导入表格数据的类型，用什么导入什么

				表里面的内容定义的类型，就不用写大小了

				In [90]: Base.metadata.create_all(engine)

			__repr__ 会在直接调用实例对象的时候被调用

			__table__ 记录了表的信息
				In [27]: User.__table__
				Out[27]: Table('user', MetaData(bind=None), Column('id', Integer(), table=<user>, primary_key=True, nullable=False), Column('name', String(), table=<user>), Column('email', String(), table=<user>), schema=None)

			需要外键连接的表格
				In [80]: from sqlalchemy.orm import relationship
				In [81]: from sqlalchemy import ForeignKey
				In [84]: class Course(Base):
				...: __tablename__ = 'course'
				...: id = Column(Integer, primary_key=True)
				...: name = Column(String)
				...: teacher_id = Column(Integer, ForeignKey('user.id'))
				...: teacher = relationship('User')
				...: def __repr__(self):
				...: return '<Course(name=%s)>' % self.name
				In [90]: Base.metadata.create_all(engine)

				...: teacher = relationship('User')
					代表创建一个teacher属性
					然后可以在Course的实例中使用course.teacher 来查看teacher_id = user.id 的数据

		创建一个数据库表
			In [89]: class Lab(Base):
			...: __tablename__ = 'lab'
			...: id = Column(Integer, primary_key=True)
			...: name = Column(String(64))
			...: course_id = Column(Integer, ForeignKey('course.id'))
			...: course = relationship('Course', backref='labs') .
			..: def __repr__(self):
			...: return '<Lab(name=%s)>' % self.name

			最后记得写

			In [90]: Base.metadata.create_all(engine)
			这样才创建成功

			...: course = relationship('Course', backref='labs') .
				在lab中创建一个course属性,labs 是Course的实例属性 然后可以course.labs来查看 course_id = course.id的数据

				course 是 Lab 实例的属性
				后面的 labs 是 Course 实例的属性
				这俩属性就是查询接口

		对表格进行操作
			首先得创建一个Session
				In [30]: from sqlalchemy.orm import sessionmaker
				In [31]: Session = sessionmaker(bind=engine)
				In [32]: session = Session()

			创建
				In [37]: course = session.query(Course).first()
				In [38]: lab1 = Lab(name='ORM 基础', course_id=course.id)
				In [39]: lab2 = Lab(name='关系数据库', course=course)
				In [41]: session.add(lab1)
				In [42]: session.add(lab2)
				In [43]: session.commit()
				In [44]: course.labs
				Out[44]: [<Lab(name=关系数据库)>, <Lab(name=ORM 基础)>]

			修改
				In [58]: course.name
				Out[58]: 'Python 基础'
				In [59]: lab1.course
				Out[59]: <Course(name=Python 基础)>
				In [60]: course.name = 'Python 数据分析'
				In [61]: session.add(course)
				In [62]: session.commit()
				In [63]: lab1.course
				Out[63]: <Course(name=Python 数据分析)>
				In [64]: session.query(Course).all()
				Out[64]: [<Course(name=Python 数据分析)>]

			删除
				In [65]: session.delete(lab1)
				In [66]: session.commit()
				In [67]: course.labs
				Out[67]: [<Lab(name=关系数据库)>]

	1:1 和 M:M的关系建立
	1：1
	class UserInfo(Base):
		__tablename__ = 'userinfo'
		user_id = Column(Integer, ForeignKey('user.id'), primary_key=True)
		addr = Column(String(512))
		use = relationship("User", backref= "info")
		def __repr__(self):
			return '<UserInfo (name=%s)>' % self.addr

openPyxl
	create a workbook
		create a file on the filesystem to get started with openpyxl.
			>>> from openpyxl import Workbook
			>>> wb = Workbook()

		A workbook is always created with at least one worksheet
		You can get it
			ws = wb.active

		You can also create new worksheets
			>>> ws1 = wb.create_sheet("Mysheet") # insert at the end (default)
			# or
			>>> ws2 = wb.create_sheet("Mysheet", 0) # insert at first position

		Sheets are given a name automatically when they are created. They are numbered in sequence (Sheet, Sheet1, Sheet2, …)
		You can change this name at any time
			ws.title = "New Title"

		Once you gave a worksheet a name, you can get it as a key of the workbook:
			>>> ws3 = wb["New Title"]

		You can review the names of all worksheets of the workbook
			>>> print(wb.sheetnames)
			['Sheet2', 'New Title', 'Sheet1']

		You can loop through worksheets
			>>> for sheet in wb:
			...     print(sheet.title)

		You can create copies os worksheets within a single workbook:
			>>> source = wb.active
			>>> target = wb.copy_worksheet(source)

	playing with data
		accessing one cell
			use keys of the worksheet
				>>> c = ws['A4']

			Values can be directly assigned
				>>> ws['A4'] = 4

			This provides access to cells using row and column notation:
				>>> d = ws.cell(row=4, column=2, value=10)

		accessing many cell






爬虫
	python怎么访问互联网
		url
			统一资源定位符
			组成
				1、协议
					如http httos ftp file
				2、存放资源的服务器的域名系统或者ip地址（有时候包含端口号，如http的端口号默认80）
				3、资源的具体地址，如目录或文件名等

			URI 是统一资源标识符（Universal Resource Identifier），URL 是统一资源定位符（Universal Resource Locator）。用一句话概括它们的区别：URI 是用字符串来标识某一互联网资源，而 URL 则是表示资源的地址（我们说某个网站的网址就是 URL），因此 URI 属于父类，而 URL 属于 URI 的子类。

		User-Agent
			普通浏览器会通过该内容向访问网站提供你所使用的浏览器类型、操作系统、浏览器内核等信息的标识

		关于json
			JSON 是一种轻量级的数据交换格式，说白了这里就是用字符串把 Python 的数据结构封装起来，便与存储和使用

		编码问题解决方案总结
			http://bbs.fishc.com/forum.php?mod=viewthread&tid=56452&highlight=%B1%E0%C2%EB

	隐藏
		解决header
			添加请求头

			这只是一种初级的隐藏方法，如果爬虫在单位时间里访问网页次数过多，也是会背服务器认为是非法访问的

		解决访问过于频繁

			延迟
				用time模块实现延迟
				import time
				while True :
					爬虫代码
					#关键的来了
					time.sleep(5)
					#我睡了五秒

			代理
				把需要访问的网址发给代理，然后代理把网址的所有东西都给返回过来

	cookie
		服务器通过判断你提交的 cookie 来确定访问是否来自”熟人“。
		简单来说 cookie 可以分成两类：
		一类是即时过期的 cookies，称为“会话” cookies，当浏览器关闭时（这里是 python 的请求程序）自动清除
		另一类是有期限的 cookies，由浏览器进行存储，并在下一次请求该网站时自动附带（如果没过期或清理的话）

	HTTP 有好几种方法（GET，POST，PUT，HEAD，DELETE，OPTIONS，CONNECT）
		使用 get_method() 方法获取 Request 对象具体使用哪种方法访问服务器

	遇到的问题
	url有中文怎么破
		进行中文编码
			url = "https://baike.baidu.com/item/"
			zh = p.quote(word)
			url = url+"%s"%zh
		或者
			word = input("请输入关键词：")
			keyword = urllib.parse.urlencode({"word":word})
			response = urllib.request.urlopen("http://baike.baidu.com/search/word?%s" % keyword)

遇到的一些问题总结
	挑战4的一些问题
		代码：
			class A:
				def __init__(self):
				self.a1 = 1;

			class B:
				def __init__(self):
				self.b1 = a.a1

			def function():
				a = A()
				return B()

			function()

		解释：
			这段代码会报出未定义a的错误
			解决这个错误的办法是在定义这个函数之前实例化A

		解决方法：
			class A:
				def __init__(self):
				self.a1 = 1;

			class B:
				def __init__(self):
				self.b1 = a.a1
			a = A()
			def function():
				a = A()
				return B()

			function()

	挑战8
		mdb.hanhan.update_one({'id': self.category_id },
				{"$set":{'tag':a["tag"].append(tag_name) }})

		append()的返回值是None 所以不能直接传列表.append(xxxx) 这样是传空

	挑战10
		{'$sort':{'score':-1,'submit_time',1}}
		会导致排序的时候，有时候是按score排列然后再sub，也有时候是先sub再score

		字典需要顺序，所使用SON来建立一个有顺序的字典，就可不会有优先级的问题了
		from bson.son import SON
		{'$sort':SON([('score',-1),('submit_time',1)])}


	关于pip与pip3
		shiyanlou:shiyanlou/ $ pip --version; pip3 --version
		pip 18.0 from /usr/local/lib/python2.7/dist-packages/pip (python 2.7)
		pip 9.0.1 from /usr/local/lib/python3.5/dist-packages (python 3.5)
