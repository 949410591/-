第二章
	shell
		shell就是一个程序，接受键盘输入的命令，然后把命令传递给操作系统去执行。
	
	终端仿真器
		和shell交互

	命令历史
		方向上键

	鼠标和光标
		鼠标左键选定某些文本，就相当与拷贝
		鼠标中键就是粘贴
		这里需要注意的是ctrl + c/ctrl + v起不了拷贝粘贴的作用
	
	一些小命令
		date 
			显示系统当前时间和日期
		
		cal
			默认显示当前月份的日历
		
		df
			查看磁盘剩余空间的数量
		
		free
			显示空闲内存数量
		
		exit
			终止一个终端会话
	
	幕后控制台
		终端仿真器没有运行，系统也会在后台运行几个终端会话
		可以通过 Ctrl-Alt-F1 到 Ctrl-Alt-F6 访问
		返回图形桌面，按下 Alt-F7
		
第三章				
	文件树
		我们平常在windows看到的文件层次结构是倒文件树结构，即最上面的是文件的根
	
	当前目录
		pwd 
	
	列出文件内容
		ls [路径]
	
	更改当前工作目录
		cd [路径]

		绝对路径
			/xx/xx   用符号“/” 从根开始的路径
			
		相对路径
			../xx/x/x 或 ./xx/xxx/xx用符号“..”和'.'
			相对于当前目录 .. 父目录  . 工作目录（当前目录）
			如果cd是这样写
				cd ./bin
				你是可以省略‘./’ 直接cd bin,而且绝大多数情况下都可以省略这个，这是隐含输入。
		
		有用的快捷键
			快捷键 			运行结果
			cd 			更改工作目录到你的家目录。
			cd - 			更改工作目录到先前的工作目录。
			cd ~user_name 	更改工作目录到用户家目录。例如, cd ~bob 会更改工作目录到用户“bob”的家目录
					直接cd ~ 是去当前用户的家目录
			
	文件名重要规则
		'.'是隐藏文件 得ls -a查看
		文件名和命令名是区分大小写的
		linux不用扩展名来决定内容和用途
		linux支持长文件名，标点符号只能用下划线_ 和 . 但最好别用空格 用下划线代替

第四章
	ls
		ls 
			直接列出当前目录文件
		
		ls + 路径 
			可以列出路径下的文件名
			如ls /usr
		
		ls列出多个指定目录下的内容
			ls ~ /usr  /home/me   
			两个路径用空格隔开  用户家目录（用字符“~”代表）
		
		选项和参数
'			command -options arguments
				这是大多数命令的输入格式

			选项 	长选项 				描述
			-a 		--all 				列出所有文件，甚至包括文件名以圆点开头的默认会被隐藏的隐藏文件。
			-d 		--directory 		仅显示目录名，而不显示目录下的内容列表。 
										把这个选项与 -l 选项结合使用，
										可以看到所指定目录的详细信息，而不是目录中的内容。
			-F 		--classify 			这个选项会在每个所列出的名字后面加上一个指示符。例如，如果名字是 目录名，
										则会加上一个'/'字符。
			-h 		--human-readable 	当以长格式列出时，以人们可读的格式，而不是以字节数来显示文件的大小。
			-l 							以长格式显示结果。
			-r 		--reverse 			以相反的顺序来显示结果。通常，ls 命令的输出结果按照字母升序排列。
			-S 							命令输出结果按照文件大小来排序。
			-t 							按照修改时间来排序。
		
		深入研究长格式输出 
			-rw-r--r-- 1 root root 3576296 2007-04-03 11:05 Experience ubuntu.ogg
			
			字段 				含义
			-rw-r--r-- 			对于文件的访问权限。第一个字符指明文件类型。在不同类型之间， 
								开头的“－”说明是一个普通文件，“d”表明是一个目录。
								其后三个字符是文件所有者的 访问权限，再其后的三个字符是文件所属组中成员的访问权限，
								最后三个字符是其他所 有人的访问权限。这个字段的完整含义将在第十章讨论。
			1 					文件的硬链接数目。参考随后讨论的关于链接的内容。
			root 				文件所有者的用户名。
			root 				文件所属用户组的名字。
			32059 				以字节数表示的文件大小。
			2007-04-03 11:05 	上次修改文件的时间和日期。
			oo-cd-cover.odf 	文件名。
				
	file
		展示详细文件信息
		file filename	
	
	less
		浏览文件内容
		
		less filename
		
		less 命令
			命令 			行为
			Page UP or b 		向上翻滚一页
			Page Down or space 	向下翻滚一页
			UP Arrow 			向上翻滚一行
			Down Arrow 		向下翻滚一行
			G 			移动到最后一行
			1G or g 			移动到开头一行
			/charaters 		向前查找指定的字符串
			n 			向前查找下一个出现的字符串，这个字符串是之前所指定查找的
			h 			显示帮助屏幕
			q 			退出 less 程序
			
	Linux 系统中的目录 
		目录			评论
		/ 				根目录，万物起源。
		/bin 			包含系统启动和运行所必须的二进制程序。
		/boot 			包含 Linux 内核、初始 RAM 磁盘映像（用于启动时所需的驱动）和 启动加载程序。

						有趣的文件：

							/boot/grub/grub.conf or menu.lst， 被用来配置启动加载程序。
							/boot/vmlinuz，Linux 内核。

		/dev 			这是一个包含设备结点的特殊目录。“一切都是文件”，也适用于设备。 在这个目录里，内核维护着所有设备的列表。
		/etc 			这个目录包含所有系统层面的配置文件。它也包含一系列的 shell 脚本， 在系统启动时，这些脚本会开启每个系统服务。这个目录中的任何文件应该是可读的文本文件。

						有趣的文件：虽然/etc 目录中的任何文件都有趣，但这里只列出了一些我一直喜欢的文件：

							/etc/crontab， 定义自动运行的任务。
							/etc/fstab，包含存储设备的列表，以及与他们相关的挂载点。
							/etc/passwd，包含用户帐号列表。

		/home 			在通常的配置环境下，系统会在/home 下，给每个用户分配一个目录。普通用户只能 在自己的目录下写文件。这个限制保护系统免受错误的用户活动破坏。
		/lib 			包含核心系统程序所使用的共享库文件。这些文件与 Windows 中的动态链接库相似。
		/lost+found 	每个使用 Linux 文件系统的格式化分区或设备，例如 ext3文件系统， 都会有这个目录。当部分恢复一个损坏的文件系统时，会用到这个目录。这个目录应该是空的，除非文件系统 真正的损坏了。
		/media 			在现在的 Linux 系统中，/media 目录会包含可移动介质的挂载点， 例如 USB 驱动器，CD-ROMs 等等。这些介质连接到计算机之后，会自动地挂载到这个目录结点下。
		/mnt 			在早些的 Linux 系统中，/mnt 目录包含可移动介质的挂载点。
		/opt 			这个/opt 目录被用来安装“可选的”软件。这个主要用来存储可能 安装在系统中的商业软件产品。
		/proc 			这个/proc 目录很特殊。从存储在硬盘上的文件的意义上说，它不是真正的文件系统。 相反，它是一个由 Linux 内核维护的虚拟文件系统。它所包含的文件是内核的窥视孔。这些文件是可读的， 它们会告诉你内核是怎样监管计算机的。
		/root 			root 帐户的家目录。
		/sbin 			这个目录包含“系统”二进制文件。它们是完成重大系统任务的程序，通常为超级用户保留。
		/tmp 			这个/tmp 目录，是用来存储由各种程序创建的临时文件的地方。一些配置导致系统每次 重新启动时，都会清空这个目录。
		/usr 			在 Linux 系统中，/usr 目录可能是最大的一个。它包含普通用户所需要的所有程序和文件。
		/usr/bin 		/usr/bin 目录包含系统安装的可执行程序。通常，这个目录会包含许多程序。
		/usr/lib 		包含由/usr/bin 目录中的程序所用的共享库。
		/usr/local 		这个/usr/local 目录，是非系统发行版自带程序的安装目录。 通常，由源码编译的程序会安装在/usr/local/bin 目录下。新安装的 Linux 系统中会存在这个目录， 并且在管理员安装程序之前，这个目录是空的。
		/usr/sbin 		包含许多系统管理程序。
		/usr/share 		/usr/share 目录包含许多由/usr/bin 目录中的程序使用的共享数据。 其中包括像默认的配置文件、图标、桌面背景、音频文件等等。
		/usr/share/doc 	大多数安装在系统中的软件包会包含一些文档。在/usr/share/doc 目录下， 我们可以找到按照软件包分类的文档。
		/var 			除了/tmp 和/home 目录之外，相对来说，目前我们看到的目录是静态的，这是说， 它们的内容不会改变。/var 目录存放的是动态文件。各种数据库，假脱机文件， 用户邮件等等，都位于在这里。
		/var/log 		这个/var/log 目录包含日志文件、各种系统活动的记录。这些文件非常重要，并且 应该时时监测它们。其中最重要的一个文件是/var/log/messages。注意，为了系统安全，在一些系统中， 你必须是超级用户才能查看这些日志文件。
	
第五章
	命令
		
	通配符
		通配符 			意义
		* 				匹配任意多个字符（包括零个或一个）
		? 				匹配任意一个字符（不包括零个）
		[characters] 	匹配任意一个属于字符集中的字符
		[!(^)characters] 	匹配任意一个不是字符集中的字符
		[[:class:]] 	匹配任意一个属于指定字符类中的字符
			普遍使用的字符类 
			字符类 		意义
			[:alnum:] 	匹配任意一个字母或数字
			[:alpha:] 	匹配任意一个字母
			[:digit:] 	匹配任意一个数字
			[:lower:] 	匹配任意一个小写字母
			[:upper:] 	匹配任意一个大写字母
		[c1-c2] 				匹配 c1-c2 中的任意单一字符 如：[0-9] [a-z] ps:尽量不使用这个
		{string1,string2,...} 	匹配 string1 或 string2 (或更多)其一字符串
		{c1..c2} 				匹配 c1-c2 中全部字符 如{1..10}
	
	mkdir  创建目录
		mkdir directory...
		注意表示法: 在描述一个命令时（如上所示），当有三个圆点跟在一个命令的参数后面， 这意味着那个参数可以重复
		比如可以创建一个或者多个
			mkdir dir1
			mkdir dir1 dir2 dir3
			
	cp	复制文件和目录
		复制文件或者目录到文件或者目录
			cp item1 item2
		复制多个项目到另一个目录下
			cp item... directory
		选项
			选项 				意义
			-a, --archive 		复制文件和目录，以及它们的属性，包括所有权和权限。 通常，复本具有用户所操作文件的默认属性。
			-i, --interactive 	在重写已存在文件之前，提示用户确认。如果这个选项不指定， cp 命令会默认重写文件。
			-r, --recursive 	递归地复制目录及目录中的内容。当复制目录时， 需要这个选项（或者-a 选项）。
			-u, --update 		当把文件从一个目录复制到另一个目录时，仅复制 目标目录中不存在的文件，或者是文件内容新于目标目录中已经存在的文件。
			-v, --verbose 		显示翔实的命令操作信息
				
	mv	移动和重命名文件
		mv item1 item2
		mv dir1 dir2
			如果目录 dir2 不存在，创建目录 dir2，并且移动目录 dir1 的内容到 目录 dir2 中，
			同时删除目录 dir1。如果目录 dir2 存在，移动目录 dir1（及它的内容）到目录 dir2。
		文件移动
			mv item... directory
		选项
			选项 				意义
			-i --interactive 	在重写一个已经存在的文件之前，提示用户确认信息。 如果不指定这个选项，mv 命令会默认重写文件内容。
			-u --update 		当把文件从一个目录移动另一个目录时，只是移动不存在的文件， 或者文件内容新于目标目录相对应文件的内容。
			-v --verbose 		当操作 mv 命令时，显示翔实的操作信息。
		
	rm	移除文件或者目录
		选项 				意义
		-i, --interactive 	在删除已存在的文件前，提示用户确认信息。 如果不指定这个选项，rm 会默默地删除文件
		-r, --recursive 	递归地删除文件，这意味着，如果要删除一个目录，而此目录 又包含子目录，0那么子目录也会被删除。要删除一个目录，必须指定这个选项。
		-f, --force 		忽视不存在的文件，不显示提示信息。这选项覆盖了“--interactive”选项。
		-v, --verbose 		在执行 rm 命令时，显示翔实的操作信息。
		小贴士。 
				当你使用带有通配符的rm命令时（除了仔细检查输入的内容外）， 
				先用 ls 命令来测试通配符。这会让你看到将要被删除的文件是什么。然后按下上箭头按键，
				重新调用 刚刚执行的命令，用 rm 替换 ls。
				
	ln
		硬链接
			ln file link
			
			一个硬链接不能关联它所在文件系统之外的文件。这是说一个链接不能关联 与链接本身不在同一个磁盘分区上的文件。

			一个硬链接不能关联一个目录。
			
			ls -li
			12353538 -rw-r--r-- 4 me  me 1650  2008-01-10  16:33  fun-hard
			第一段数字是索引点节号

		符号链接
			ln -s item link
	
			对于符号链接，有一点值得记住，执行的大多数文件操作是针对链接的对象，而不是链接本身。
			而 rm 命令是个特例。当你删除链接的时候，删除链接本身，而不是链接的对象。	
			只删除文件，符号链接会变成坏链接，ls显示中会用不同颜色展示坏链接

			lrwxrwxrwx 1 me  me    6 2008-01-15 15:17 fun-sym -> ../fun
				6是指符号链接的路径长度是6
			
			文件管理器  同时按下 Ctrl+Shift 按键会创建一个链接

第六章
	什么是命令
		是一个可执行程序，就像我们所看到的位于目录/usr/bin 中的文件一样。 这一类程序可以是用诸如 C 和 C++语言写成的程序编译的二进制文件, 也可以是由诸如shell，perl，python，ruby等等脚本语言写成的程序 。

		是一个内建于 shell 自身的命令。bash 支持若干命令，内部叫做 shell 内部命令 (builtins)。例如，cd 命令，就是一个 shell 内部命令。

		是一个 shell 函数。这些是小规模的 shell 脚本，它们混合到环境变量中。 在后续的章节里，我们将讨论配置环境变量以及书写 shell 函数。但是现在， 仅仅意识到它们的存在就可以了。

		是一个命令别名。我们可以定义自己的命令，建立在其它命令之上。

	type
		识别命令
		type command
		
	which 
		可执行程序位置
		不包括内建命令和命令别名，别名是真正的可执行程序的替代物
		
	help 
		得到 shell 内建命令的帮助文档

	[command] --help  显示用法信息
		[me@linuxbox ~]$ mkdir --help
		Usage: mkdir [OPTION] DIRECTORY...
		Create ...
		
	man	手册查询
		man [num] commend
		
		章节 	内容
		1 		用户命令
		2 		程序接口内核系统调用
		3 		C 库函数程序接口
		4 		特殊文件，比如说设备结点和驱动程序
		5 		文件格式
		6 		游戏娱乐，如屏幕保护程序
		7 		其他方面
		8 		系统管理员命令
		
	apropos 关键字查询
		apropos [key]
			kk@kk-VirtualBox:~$ apropos apt-get	
			apt-get (8)          - APT package handling utility - - command-line interface
		输出结果每行的第一个字段是手册页的名字，
		第二个字段展示章节。注意，man 命令加上”-k”选项， 和 apropos 完成一样的功能。
		
	info	显示程序 Info 条目
		info 文件包含超级链接，它可以让你从一个结点跳到另一个结点。
		一个超级链接可通过 它开头的星号来辨别出来，把光标放在它上面并按下 enter 键，就可以激活它。
		
		命令 				行为
		? 					显示命令帮助
		PgUp or Backspace 	显示上一页
		PgDn or Space 		显示下一页
		n 					下一个 - 显示下一个结点
		p 					上一个 - 显示上一个结点
		u 					Up - 显示当前所显示结点的父结点，通常是个菜单
		Enter 				激活光标位置下的超级链接
		q 					退出
	
		到目前为止，我们所讨论的大多数命令行程序，属于 GNU 项目”coreutils”包，所以输入：
			info coreutils
		将会显示一个包含超级链接的手册页，这些超级链接指向包含在 coreutils 包中的各个程序。

	whatis
		显示非常简洁的命令说明
		
	alias	创建命令
		可以把多个命令放在同一行上，命令之间 用”;”分开。
			command1; command2; command3...
		一个shell命令
			先构想一个名字
				查询名字是否被使用
					test command_name
				创建命令
					alias name='string'
				查询创建命令
					type foo
				删除
					unalias command_name
		查看所有别名
			直接输入alias
					
第七章
	标准输入、输出和错误
		输入输出错误在本质上都是文件
			标准输入文件 stdin，默认情况下，连接键盘
			标准输出文件 stdout 默认连接屏幕
			标准错误文件 stderr 默认连接屏幕
			
	标准输出重定向
		> 
		ls -l /usr/bin > ls-output.txt
		
		当我们使用 “>” 重定向符来重定向输出结果时，目标文件总是从开头被重写。
		如果我们需要清空一个文件内容（或者创建一个 新的空文件），可以使用这样的技巧：
			[me@linuxbox ~]$ > ls-output.txt
		
		>>
			将导致输出结果添加到文件内容之后。如果文件不存在，文件会 被创建，就如使用了”>”操作符。
	
	标准错误重定向
		没有专用的重定向符，shell把输入输出错误分别称为文件描述符0、1和2
		so
			ls -l /bin/usr 2> ls-error.txt
			可以重定向错误
	
	重定向标准输出和错误到同一个文件
			ls -l /bin/usr &> ls-output.txt
	
	处理不需要的输出
		不想要一个命令的输出结果，只想把它们扔掉。
		这种情况 尤其适用于错误和状态信息。
		系统通过重定向输出结果到一个叫做”/dev/null”的特殊文件， 为我们提供了解决问题的方法。
		这个文件是系统设备，叫做位存储桶，它可以 接受输入，并且对输入不做任何处理。
			ls -l /bin/usr 2> /dev/null
	
	标准输入重定向
		cat
			读取一个或多个文件，然后复制它们到标准输出，就像这样:
				cat [file]
			它也可以用来把文件连接在一起
				cat movie.mpeg.0* > movie.mpeg
			创建简短的文本文件
				cat > lazy_dog.txt
			我们知道 cat 怎样接受标准输入，除了文件名参数，让我们试着重定向标准输入：
				[me@linuxbox ~]$ cat < lazy_dog.txt
	
	管道线
		一个命令的标准输出可以通过管道送至另一个命令的标准输入
		也就是前一个命令的输出成为下一个命令的输入
		
		command1 | command2

	过滤器	
		sort	
			我们改变输出数据，从而产生一个 有序列表。
			sort将文件的每一行作为一个单位，相互比较，比较原则是从首字符向后，
			依次按ASCII码值进行比较，最后将他们按升序输出。
			参数
				-u 	去除重复行
				-r 	降序显示
				-n  按照数值排序
		
		uniq	报道或忽略重复行
			默认情况下，从数据列表中删除任何重复行	
			-c 在输出行前面加上每行在输入文件中出现的次数。
			-d 仅显示重复行。
			-u 仅显示不重复的行。
		
		wc
			命令用来计算数字。利用wc指令我们可以计算文件的Byte数、字数或是列数
			-c或--bytes或——chars：只显示Bytes数；
			-l或——lines：只显示列数；
			-w或——words：只显示字数。
			1653    3305    29419
			行数    单词数  字节数
			
		grep
			是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。 
			-i 忽略大小写
			-v 只打印不匹配行

		head/tail	打印文件开头部分/结尾部分
			command -n [number] file
			默认十行
			
			一般
			tail -n 5 ls-output.txt
			
			管道线
			ls /usr/bin | tail -n 5
			
			tail -f 可以实时检测文件内容
		
		tee	从 Stdin 读取数据，并同时输出到 Stdout 和文件
			管道监视器
			如 ls /usr/bin | tee ls.txt | grep zip
				有没有作用一样
				在 grep 过滤管道线的内容之前，来捕捉整个目录列表到文件 ls.txt
	
第八章
	echo 显示一行文本
	
	（字符）展开
		echo *
			当回车键被按下时，shell 在命令被执行前在命令行上自动展开任何符合条件的字符， 
			所以 echo 命令的实际参数并不是”*“，而是它展开后的结果。
		
	路径展开
		通配符所依赖的工作机制叫做路径名展开
	
	隐藏文件路径名展开
		ls -A .[!.]?*
	
	波浪线展开
		kk@kk-VirtualBox:~$ echo ~kk
		/home/kk
		kk@kk-VirtualBox:~$ echo ~
		/home/kk
	
	算术表达式展开
		$((expression))
		（以上括号中的）表达式是指算术表达式，它由数值和算术操作符组成。
			[me@linuxbox ~]$ echo $((2 + 2))
			4
	
		算术操作符 
			操作符 	说明
			+ 		加
			- 		减
			* 		乘
			/ 		除（但是记住，因为展开只是支持整数除法，所以结果是整数。）
			% 		取余，只是简单的意味着，“余数”
			** 		取幂
		
		在算术表达式中空格并不重要，并且表达式可以嵌套
			[me@linuxbox ~]$ echo $(($((5**2)) * 3))
			75
			
		这是一个使用除法和取余操作符的例子。注意整数除法的结果：
			[me@linuxbox ~]$ echo Five divided by two equals $((5/2))
			Five divided by two equals 2
			[me@linuxbox ~]$ echo with $((5%2)) left over.
			with 1 left over.
		
	花括号展开
		{string1，string2,...}
		{1..2}
		{A..N}
		
		最常见的应用是，创建一系列的文件或目录列表。
			[me@linuxbox ~]$ mkdir Pics
			[me@linuxbox ~]$ cd Pics
			[me@linuxbox Pics]$ mkdir {2007..2009}-0{1..9} {2007..2009}-{10..12}
			[me@linuxbox Pics]$ ls
			2007-01 2007-07 2008-01 2008-07 2009-01 2009-07
			2007-02 2007-08 2008-02 2008-08 2009-02 2009-08
			2007-03 2007-09 2008-03 2008-09 2009-03 2009-09
			2007-04 2007-10 2008-04 2008-10 2009-04 2009-10
			2007-05 2007-11 2008-05 2008-11 2009-05 2009-11
			2007-06 2007-12 2008-06 2008-12 2009-06 2009-12
			
	参数展开
		准确来说是变量名展开
			[me@linuxbox ~]$ echo $USER
			me
			
			[me@linuxbox ~]$ printenv | less
	
	命令替换
		命令替换允许我们把一个命令的输出作为一个展开模式来使用
			file $(ls /usr/bin/* | grep zip)
			commend $(commend) 把括号内的命令输出作为括号外的命令输入
	
	引用
		shell 提供了一种 叫做引用的机制，来有选择地禁止不需要的展开。
		举个例子
			[me@linuxbox ~]$ echo this is a    test
			this is a test
			会删除多余的空格
		
			[me@linuxbox ~]$ echo The total is $100.00
			The total is 00.00
			$1 1是无意义的参数名会用空格代替
		
		双引号
			如果你把文本放在双引号中， shell 使用的特殊字符，都失去它们的特殊含义，被当作普通字符来看待。 
			有几个例外： $，\ (反斜杠），和 `（倒引号）。
			在双引号中，参数展开、算术表达式展开和命令替换仍然有效
			
		单词分割机制
			在默认情况下，单词分割机制会在单词中寻找空格，制表符，和换行符，并把它们看作 单词之间的界定符。
			这意味着无引用的空格，制表符和换行符都不是文本的一部分， 它们只作为分隔符使用。
			
			一个很有趣的例子
				[me@linuxbox ~]$ echo $(cal)
				February 2008 Su Mo Tu We Th Fr Sa 1 2 3 4 5 6 7 8 9 10 11 12 13 14
				15 16 17 18 19 20 21 22 23 24 25 26 27 28 29
				
				kk@kk-VirtualBox:~$ echo "$(cal)"
					  七月 2018         
				日 一 二 三 四 五 六  
				 1  2  3  4  5  6  7  
				 8  9 10 11 12 13 14  
				15 16 17 18 19 20 21  
				22 23 24 25 26 27 28  
				29 30 31 
		
		单引号
			如果需要禁止所有的展开，我们要使用单引号。以下例子是无引用，双引号，和单引号的比较结果：
			[me@linuxbox ~]$ echo text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER
			text /home/me/ls-output.txt a b foo 4 me
			[me@linuxbox ~]$ echo "text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER"
			text ~/*.txt   {a,b} foo 4 me
			[me@linuxbox ~]$ echo 'text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER'
			text ~/*.txt  {a,b} $(echo foo) $((2+2)) $USER
		
		转义字符
			有时候我们只想引用单个字符。我们可以在字符之前加上一个反斜杠，在这里叫做转义字符。
			经常在双引号中使用转义字符，来有选择地阻止展开。
			
			[me@linuxbox ~]$ echo "The balance for user $USER is: \$5.00"
			The balance for user me is: $5.00
			
			反斜杠转义的字符被当作普通字符来看待
			
		反斜杠转义字符序列
			转义序列 	含义
			\a 			响铃（”警告”－导致计算机嘟嘟响）
			\b 			退格符
			\n 			新的一行。在类 Unix 系统中，产生换行。
			\r 			回车符
			\t 			制表符
			
	拓展阅读

		Bash 手册页有主要段落是关于展开和引用的，它们以更正式的方式介绍了这些题目。

		Bash 参考手册也包含章节，介绍展开和引用：

		http://www.gnu.org/software/bash/manual/bashref.html

第九章
	移动光标
		按键 	行动
		Ctrl-a 	移动光标到行首。
		Ctrl-e 	移动光标到行尾。
		Ctrl-f 	光标前移一个字符；和右箭头作用一样。
		Ctrl-b 	光标后移一个字符；和左箭头作用一样。
		Alt-f 	光标前移一个字。
		Alt-b 	光标后移一个字。
		Ctrl-l 	清空屏幕，移动光标到左上角。clear 命令完成同样的工作。
	
	修改文本
		按键 	行动
		Ctrl-d 	删除光标位置的字符。
		Ctrl-t 	光标位置的字符和光标前面的字符互换位置。
		Alt-t 	光标位置的字和其前面的字互换位置。
		Alt-l 	把从光标位置到字尾的字符转换成小写字母。
		Alt-u 	把从光标位置到字尾的字符转换成大写字母。
	
	剪切和粘贴文本
		按键 			行动
		Ctrl-k 			剪切从光标位置到行尾的文本。
		Ctrl-u 			剪切从光标位置到行首的文本。
		Alt-d 			剪切从光标位置到词尾的文本。
		Alt-Backspace 	剪切从光标位置到词头的文本。如果光标在一个单词的开头，剪切前一个单词。
		Ctrl-y 			把剪切环中的文本粘贴到光标位置。
	
	自动补全
		tab				
		按键	行动
		Alt-?	显示可能的自动补全列表。在大多数系统中，你也可以完成这个通过按 两次 tab 键，这会更容易些。
		Alt-*	插入所有可能的自动补全。当你想要使用多个可能的匹配项时，这个很有帮助。
	
	搜索历史命令（不完整）
		已经被执行过的文件都被保存在家目录的.bash_history 
		history
			查看历史命令列表
			kk@kk-VirtualBox:~$ history | grep set
			30  set | less
			39  history | grep set
			
		数字代表历史列表中的行号，可以用！30来调用行号所代表的命令
		
		按键	行为
		Ctrl-p	移动到上一个历史条目。类似于上箭头按键。
		Ctrl-n	移动到下一个历史条目。类似于下箭头按键。
		Alt-<	移动到历史列表开头。
		Alt->	移动到历史列表结尾，即当前命令行。
		Ctrl-r	反向递增搜索。从当前命令行开始，向上递增搜索。
		Alt-p	反向搜索，不是递增顺序。输入要查找的字符串，然后按下 Enter，执行搜索。
		Alt-n	向前搜索，非递增顺序。
		Ctrl-o	执行历史列表中的当前项，并移到下一个。如果你想要执行历史列表中一系列的命令，这很方便
		
	历史命令展开
		序列		行为
		!!			重复最后一次执行的命令。可能按下上箭头按键和 enter 键更容易些。
		!number		重复历史列表中第 number 行的命令。
		!string		重复最近历史列表中，以这个字符串开头的命令。
		!?string	重复最近历史列表中，包含这个字符串的命令。
	
	拓展阅读
		Wikipedia 上有一篇关于计算机终端的好文章：

		http://en.wikipedia.org/wiki/Computer_terminal

第十章
	传统的unix系统支持多任务也支持多用户系统，这意味着多个用户可以在同一时间使用同一台计算机。
	除了在本机上直接使用键盘鼠标操控，也可以远程通过ssh（安全的shell）登陆并操作这台电脑。
	
	拥有者、组成员和其他人
		用户帐户 定义在/etc/passwd 文件里面，
		用户组定义在/etc/group 文件里面。
		当用户帐户和用户组创建以后， 
		这些文件随着文件/etc/shadow 的变动而修改，文件/etc/shadow 包含了关于用户密码的信息。	
	
	读取、写入和执行
		-rw-rw-r-- 1 me   me   0 2008-03-06 14:52 foo.txt
		
		第一个表示文件类型
		
		属性 	文件类型
		- 		一个普通文件
		d 		一个目录
		l 		一个符号链接。注意对于符号链接文件，剩余的文件属性总是"rwxrwxrwx"，而且都是 虚拟值。
				真正的文件属性是指符号链接所指向的文件的属性。
		c 		一个字符设备文件。这种文件类型是指按照字节流来处理数据的设备。 比如说终端机或者调制解调器
		b 		一个块设备文件。这种文件类型是指按照数据块来处理数据的设备，例如一个硬盘或者 CD-ROM 盘。
		
		剩下九个字符叫做文件模式，代表着文件所有者、文件组所有者和其他人的读、写和执行权限
		
		属性 	文件 								目录
		r 		允许打开并读取文件内容。 			允许列出目录中的内容，前提是目录必须设置了可执行属性（x）。
		w 		允许写入文件内容或截断文件。	
				但是不允许对文件进行重命名或删除，
				重命名或删除是由目录的属性决定的。 	允许在目录下新建、删除或重命名文件，前提是目录必须设置了可执行属性（x）。
		x 		允许将文件作为程序来执行，			允许进入目录，例如：cd directory 。
				使用脚本语言编写的程序必须
				设置为可读才能被执行。
				
		权限属性示例
		文件属性 		含义
		-rwx------ 		一个普通文件，对文件所有者来说可读、可写、可执行。其他人无法访问。
		-rw------- 		一个普通文件，对文件所有者来说可读可写。其他人无法访问。
		-rw-r--r-- 		一个普通文件，对文件所有者来说可读可写，文件所有者的组成员可以读该文件，其他所有人都可以读该文件。
		-rwxr-xr-x 		一个普通文件，对文件所有者来说可读、可写、可执行。也可以被其他的所有人读取和执行。
		-rw-rw---- 		一个普通文件，对文件所有者以及文件所有者的组成员来说可读可写。
		lrwxrwxrwx 		一个符号链接，符号链接的权限都是虚拟的，真实的权限应该以符号链接指向的文件为准。
		drwxrwx--- 		一个目录，文件所有者以及文件所有者的组成员可以访问该目录，并且可以在该目录下新建、重命名、删除文件。
		drwxr-x--- 		一个目录，文件所有者可以访问该目录，并且可以在该目录下新建、重命名、删除文件，文件所有者的组成员可以访问该目录，但是不能新建、重命名、删除文件。	
		
	chmod － 更改文件模式
		八进制数字表示法修改文件模式
		
			Octal 	Binary 	File Mode		 
			0 		000 	---	0 + 0 + 0 
			1 		001 	--x	0 + 0 + 1
			2 		010 	-w-	0 + 2 + 0
			3 		011 	-wx	0 + 2 + 1
			4 		100 	r--	4 + 0 + 0
			5 		101 	r-x	4 + 0 + 1
			6 		110 	rw-	4 + 2 +0
			7 		111 	rwx	4 + 2 + 1
			
			这里的数字代表的是二的几次方
		
		符号表示法修改文件模式
			chmod 命令符号表示法
				u 	"user"的简写，意思是文件或目录的所有者。
				g 	用户组。
				o 	"others"的简写，意思是其他所有的人。
				a 	"all"的简写，是"u", "g"和“o”三者的联合。
	
	借助 GUI 来设置文件模式
	
	umask － 设置默认权限
		当创建一个文件时，umask 命令控制着文件的默认权限。
			用补码的方式来确定默认权限
			000 000 000 000
			上面数字有一个1对应一种权限的删除
			
			Original file mode 	--- rw- rw- rw-
			Mask 				000 000 010 010
			Result 				--- rw- r-- r--
			
	一些特殊权限
		实际上来说文件应该是4位的文件模式，只是平常是出于隐藏状态
		setuid位（八进制4000）	对于文件
			当应用到一个可执行文件时，它把有效用户 ID 从真正的用户（实际运行程序的用户）设置成程序所有者的 ID。
			这个程序运行时具有超级用户的特权，这样程序就可以 访问普通用户禁止访问的文件和目录。
		setgid位（八进制2000） 针对文件或目录
			把有效用户组 ID 从真正的 用户组 ID 更改为文件所有者的组 ID。
			如果设置了一个目录的 setgid 位，
			则目录中新创建的文件 具有这个目录用户组的所有权，
			而不是文件创建者所属用户组的所有权。
		第三个是 sticky 位（八进制1000） 针对文件或目录
			它可能把一个可执行文件 标志为“不可交换的”。
			如果一个目录设置了 sticky 位， 那么它能阻止用户删除或重命名文件，
			除非用户是这个目录的所有者，或者是文件所有者，或是 超级用户。
	
	更改身份
		su － 以其他用户身份和组 ID 运行一个 shell
			su [-[l]] [user]
				su <user> 	切换用户user,不改变环境变量
				su -[l] <user>	切换用户，同时环境变量也会跟着改变为目标用户的环境变量
			退出
				输入 exit 回车或 ctrl + d
		
		以这样的方式使用 su 命令，也可以只执行单个命令，而不是启动一个新的可交互的 shell：
			su -c 'command'
		
		sudo － 以另一个用户身份执行命令
			sudo 可以使用本用户密码以管理员身份直接执行命令
				

				
			
		