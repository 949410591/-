第二章
	shell
		shell就是一个程序，接受键盘输入的命令，然后把命令传递给操作系统去执行。

	终端仿真器
		和shell交互

	命令历史
		方向上键

	鼠标和光标
		鼠标左键选定某些文本，就相当与拷贝
		鼠标中键就是粘贴
		这里需要注意的是ctrl + c/ctrl + v起不了拷贝粘贴的作用

	一些小命令
		date
			显示系统当前时间和日期

		cal
			默认显示当前月份的日历

		df
			查看磁盘剩余空间的数量

		free
			显示空闲内存数量

		exit
			终止一个终端会话

	幕后控制台
		终端仿真器没有运行，系统也会在后台运行几个终端会话
		可以通过 Ctrl-Alt-F1 到 Ctrl-Alt-F6 访问
		返回图形桌面，按下 Alt-F7

第三章
	文件树
		我们平常在windows看到的文件层次结构是倒文件树结构，即最上面的是文件的根

	当前目录
		pwd

	列出文件内容
		ls [路径]

	更改当前工作目录
		cd [路径]

		绝对路径
			/xx/xx   用符号“/” 从根开始的路径

		相对路径
			../xx/x/x 或 ./xx/xxx/xx用符号“..”和'.'
			相对于当前目录 .. 父目录  . 工作目录（当前目录）
			如果cd是这样写
				cd ./bin
				你是可以省略‘./’ 直接cd bin,而且绝大多数情况下都可以省略这个，这是隐含输入。

		有用的快捷键
			快捷键 			运行结果
			cd 			更改工作目录到你的家目录。
			cd - 			更改工作目录到先前的工作目录。
			cd ~user_name 	更改工作目录到用户家目录。例如, cd ~bob 会更改工作目录到用户“bob”的家目录
					直接cd ~ 是去当前用户的家目录

	文件名重要规则
		'.'是隐藏文件 得ls -a查看
		文件名和命令名是区分大小写的
		linux不用扩展名来决定内容和用途
		linux支持长文件名，标点符号只能用下划线_ 和 . 但最好别用空格 用下划线代替

第四章
	ls
		ls
			直接列出当前目录文件

		ls + 路径
			可以列出路径下的文件名
			如ls /usr

		ls列出多个指定目录下的内容
			ls ~ /usr  /home/me
			两个路径用空格隔开  用户家目录（用字符“~”代表）

		选项和参数

					command -options arguments
				这是大多数命令的输入格式

			选项 	长选项 				描述
			-a 		--all 				列出所有文件，甚至包括文件名以圆点开头的默认会被隐藏的隐藏文件。
			-d 		--directory 		仅显示目录名，而不显示目录下的内容列表。
										把这个选项与 -l 选项结合使用，
										可以看到所指定目录的详细信息，而不是目录中的内容。
			-F 		--classify 			这个选项会在每个所列出的名字后面加上一个指示符。例如，如果名字是 目录名，
										则会加上一个'/'字符。
			-h 		--human-readable 	当以长格式列出时，以人们可读的格式，而不是以字节数来显示文件的大小。
			-l 							以长格式显示结果。
			-r 		--reverse 			以相反的顺序来显示结果。通常，ls 命令的输出结果按照字母升序排列。
			-S 							命令输出结果按照文件大小来排序。
			-t 							按照修改时间来排序。

		深入研究长格式输出
			-rw-r--r-- 1 root root 3576296 2007-04-03 11:05 Experience ubuntu.ogg

			字段 				含义
			-rw-r--r-- 			对于文件的访问权限。第一个字符指明文件类型。在不同类型之间，
								开头的“－”说明是一个普通文件，“d”表明是一个目录。
								其后三个字符是文件所有者的 访问权限，再其后的三个字符是文件所属组中成员的访问权限，
								最后三个字符是其他所 有人的访问权限。这个字段的完整含义将在第十章讨论。
			1 					文件的硬链接数目。参考随后讨论的关于链接的内容。
			root 				文件所有者的用户名。
			root 				文件所属用户组的名字。
			32059 				以字节数表示的文件大小。
			2007-04-03 11:05 	上次修改文件的时间和日期。
			oo-cd-cover.odf 	文件名。

	file
		展示详细文件信息
		file filename

	less
		浏览文件内容

		less filename

		less 命令
			命令 			行为
			Page UP or b 		向上翻滚一页
			Page Down or space 	向下翻滚一页
			UP Arrow 			向上翻滚一行
			Down Arrow 		向下翻滚一行
			G 			移动到最后一行
			1G or g 			移动到开头一行
			/charaters 		向前查找指定的字符串
			n 			向前查找下一个出现的字符串，这个字符串是之前所指定查找的
			h 			显示帮助屏幕
			q 			退出 less 程序

	Linux 系统中的目录
		目录			评论
		/ 				根目录，万物起源。
		/bin 			包含系统启动和运行所必须的二进制程序。
		/boot 			包含 Linux 内核、初始 RAM 磁盘映像（用于启动时所需的驱动）和 启动加载程序。

						有趣的文件：

							/boot/grub/grub.conf or menu.lst， 被用来配置启动加载程序。
							/boot/vmlinuz，Linux 内核。

		/dev 			这是一个包含设备结点的特殊目录。“一切都是文件”，也适用于设备。 在这个目录里，内核维护着所有设备的列表。
		/etc 			这个目录包含所有系统层面的配置文件。它也包含一系列的 shell 脚本， 在系统启动时，这些脚本会开启每个系统服务。这个目录中的任何文件应该是可读的文本文件。

						有趣的文件：虽然/etc 目录中的任何文件都有趣，但这里只列出了一些我一直喜欢的文件：

							/etc/crontab， 定义自动运行的任务。
							/etc/fstab，包含存储设备的列表，以及与他们相关的挂载点。
							/etc/passwd，包含用户帐号列表。

		/home 			在通常的配置环境下，系统会在/home 下，给每个用户分配一个目录。普通用户只能 在自己的目录下写文件。这个限制保护系统免受错误的用户活动破坏。
		/lib 			包含核心系统程序所使用的共享库文件。这些文件与 Windows 中的动态链接库相似。
		/lost+found 	每个使用 Linux 文件系统的格式化分区或设备，例如 ext3文件系统， 都会有这个目录。当部分恢复一个损坏的文件系统时，会用到这个目录。这个目录应该是空的，除非文件系统 真正的损坏了。
		/media 			在现在的 Linux 系统中，/media 目录会包含可移动介质的挂载点， 例如 USB 驱动器，CD-ROMs 等等。这些介质连接到计算机之后，会自动地挂载到这个目录结点下。
		/mnt 			在早些的 Linux 系统中，/mnt 目录包含可移动介质的挂载点。
		/opt 			这个/opt 目录被用来安装“可选的”软件。这个主要用来存储可能 安装在系统中的商业软件产品。
		/proc 			这个/proc 目录很特殊。从存储在硬盘上的文件的意义上说，它不是真正的文件系统。 相反，它是一个由 Linux 内核维护的虚拟文件系统。它所包含的文件是内核的窥视孔。这些文件是可读的， 它们会告诉你内核是怎样监管计算机的。
		/root 			root 帐户的家目录。
		/sbin 			这个目录包含“系统”二进制文件。它们是完成重大系统任务的程序，通常为超级用户保留。
		/tmp 			这个/tmp 目录，是用来存储由各种程序创建的临时文件的地方。一些配置导致系统每次 重新启动时，都会清空这个目录。
		/usr 			在 Linux 系统中，/usr 目录可能是最大的一个。它包含普通用户所需要的所有程序和文件。
		/usr/bin 		/usr/bin 目录包含系统安装的可执行程序。通常，这个目录会包含许多程序。
		/usr/lib 		包含由/usr/bin 目录中的程序所用的共享库。
		/usr/local 		这个/usr/local 目录，是非系统发行版自带程序的安装目录。 通常，由源码编译的程序会安装在/usr/local/bin 目录下。新安装的 Linux 系统中会存在这个目录， 并且在管理员安装程序之前，这个目录是空的。
		/usr/sbin 		包含许多系统管理程序。
		/usr/share 		/usr/share 目录包含许多由/usr/bin 目录中的程序使用的共享数据。 其中包括像默认的配置文件、图标、桌面背景、音频文件等等。
		/usr/share/doc 	大多数安装在系统中的软件包会包含一些文档。在/usr/share/doc 目录下， 我们可以找到按照软件包分类的文档。
		/var 			除了/tmp 和/home 目录之外，相对来说，目前我们看到的目录是静态的，这是说， 它们的内容不会改变。/var 目录存放的是动态文件。各种数据库，假脱机文件， 用户邮件等等，都位于在这里。
		/var/log 		这个/var/log 目录包含日志文件、各种系统活动的记录。这些文件非常重要，并且 应该时时监测它们。其中最重要的一个文件是/var/log/messages。注意，为了系统安全，在一些系统中， 你必须是超级用户才能查看这些日志文件。

第五章
	命令

	通配符
		通配符 			意义
		* 				匹配任意多个字符（包括零个或一个）
		? 				匹配任意一个字符（不包括零个）
		[characters] 	匹配任意一个属于字符集中的字符
		[!(^)characters] 	匹配任意一个不是字符集中的字符
		[[:class:]] 	匹配任意一个属于指定字符类中的字符
			普遍使用的字符类
			字符类 		意义
			[:alnum:] 	匹配任意一个字母或数字
			[:alpha:] 	匹配任意一个字母
			[:digit:] 	匹配任意一个数字
			[:lower:] 	匹配任意一个小写字母
			[:upper:] 	匹配任意一个大写字母
			[c1-c2] 				匹配 c1-c2 中的任意单一字符 如：[0-9] [a-z] ps:尽量不使用这个


	mkdir  创建目录
		mkdir directory...
		注意表示法: 在描述一个命令时（如上所示），当有三个圆点跟在一个命令的参数后面， 这意味着那个参数可以重复
		比如可以创建一个或者多个
			mkdir dir1
			mkdir dir1 dir2 dir3

	cp	复制文件和目录
		复制文件或者目录到文件或者目录
			cp item1 item2
		复制多个项目到另一个目录下
			cp item... directory
		选项
			选项 				意义
			-a, --archive 		复制文件和目录，以及它们的属性，包括所有权和权限。 通常，复本具有用户所操作文件的默认属性。
			-i, --interactive 	在重写已存在文件之前，提示用户确认。如果这个选项不指定， cp 命令会默认重写文件。
			-r, --recursive 	递归地复制目录及目录中的内容。当复制目录时， 需要这个选项（或者-a 选项）。
			-u, --update 		当把文件从一个目录复制到另一个目录时，仅复制 目标目录中不存在的文件，或者是文件内容新于目标目录中已经存在的文件。
			-v, --verbose 		显示翔实的命令操作信息

	mv	移动和重命名文件
		mv item1 item2
		mv dir1 dir2
			如果目录 dir2 不存在，创建目录 dir2，并且移动目录 dir1 的内容到 目录 dir2 中，
			同时删除目录 dir1。如果目录 dir2 存在，移动目录 dir1（及它的内容）到目录 dir2。
		文件移动
			mv item... directory
		选项
			选项 				意义
			-i --interactive 	在重写一个已经存在的文件之前，提示用户确认信息。 如果不指定这个选项，mv 命令会默认重写文件内容。
			-u --update 		当把文件从一个目录移动另一个目录时，只是移动不存在的文件， 或者文件内容新于目标目录相对应文件的内容。
			-v --verbose 		当操作 mv 命令时，显示翔实的操作信息。

	rm	移除文件或者目录
		选项 				意义
		-i, --interactive 	在删除已存在的文件前，提示用户确认信息。 如果不指定这个选项，rm 会默默地删除文件
		-r, --recursive 	递归地删除文件，这意味着，如果要删除一个目录，而此目录 又包含子目录，0那么子目录也会被删除。要删除一个目录，必须指定这个选项。
		-f, --force 		忽视不存在的文件，不显示提示信息。这选项覆盖了“--interactive”选项。
		-v, --verbose 		在执行 rm 命令时，显示翔实的操作信息。
		小贴士。
				当你使用带有通配符的rm命令时（除了仔细检查输入的内容外），
				先用 ls 命令来测试通配符。这会让你看到将要被删除的文件是什么。然后按下上箭头按键，
				重新调用 刚刚执行的命令，用 rm 替换 ls。

	ln
		硬链接
			ln file link

			一个硬链接不能关联它所在文件系统之外的文件。这是说一个链接不能关联 与链接本身不在同一个磁盘分区上的文件。

			一个硬链接不能关联一个目录。

			ls -li
			12353538 -rw-r--r-- 4 me  me 1650  2008-01-10  16:33  fun-hard
			第一段数字是索引点节号

		符号链接
			ln -s item link

			对于符号链接，有一点值得记住，执行的大多数文件操作是针对链接的对象，而不是链接本身。
			而 rm 命令是个特例。当你删除链接的时候，删除链接本身，而不是链接的对象。
			只删除文件，符号链接会变成坏链接，ls显示中会用不同颜色展示坏链接

			lrwxrwxrwx 1 me  me    6 2008-01-15 15:17 fun-sym -> ../fun
				6是指符号链接的路径长度是6

			文件管理器  同时按下 Ctrl+Shift 按键会创建一个链接

第六章
	什么是命令
		是一个可执行程序，就像我们所看到的位于目录/usr/bin 中的文件一样。 这一类程序可以是用诸如 C 和 C++语言写成的程序编译的二进制文件, 也可以是由诸如shell，perl，python，ruby等等脚本语言写成的程序 。

		是一个内建于 shell 自身的命令。bash 支持若干命令，内部叫做 shell 内部命令 (builtins)。例如，cd 命令，就是一个 shell 内部命令。

		是一个 shell 函数。这些是小规模的 shell 脚本，它们混合到环境变量中。 在后续的章节里，我们将讨论配置环境变量以及书写 shell 函数。但是现在， 仅仅意识到它们的存在就可以了。

		是一个命令别名。我们可以定义自己的命令，建立在其它命令之上。

	type
		识别命令
		type command

	which
		可执行程序位置
		不包括内建命令和命令别名，别名是真正的可执行程序的替代物

	help
		得到 shell 内建命令的帮助文档

	[command] --help  显示用法信息
		[me@linuxbox ~]$ mkdir --help
		Usage: mkdir [OPTION] DIRECTORY...
		Create ...

	man	手册查询
		man [num] commend

		章节 	内容
		1 		用户命令
		2 		程序接口内核系统调用
		3 		C 库函数程序接口
		4 		特殊文件，比如说设备结点和驱动程序
		5 		文件格式
		6 		游戏娱乐，如屏幕保护程序
		7 		其他方面
		8 		系统管理员命令

	apropos 关键字查询
		apropos [key]
			kk@kk-VirtualBox:~$ apropos apt-get
			apt-get (8)          - APT package handling utility - - command-line interface
		输出结果每行的第一个字段是手册页的名字，
		第二个字段展示章节。注意，man 命令加上”-k”选项， 和 apropos 完成一样的功能。

	info	显示程序 Info 条目
		info 文件包含超级链接，它可以让你从一个结点跳到另一个结点。
		一个超级链接可通过 它开头的星号来辨别出来，把光标放在它上面并按下 enter 键，就可以激活它。

		命令 				行为
		? 					显示命令帮助
		PgUp or Backspace 	显示上一页
		PgDn or Space 		显示下一页
		n 					下一个 - 显示下一个结点
		p 					上一个 - 显示上一个结点
		u 					Up - 显示当前所显示结点的父结点，通常是个菜单
		Enter 				激活光标位置下的超级链接
		q 					退出

		到目前为止，我们所讨论的大多数命令行程序，属于 GNU 项目”coreutils”包，所以输入：
			info coreutils
		将会显示一个包含超级链接的手册页，这些超级链接指向包含在 coreutils 包中的各个程序。

	whatis
		显示非常简洁的命令说明

	alias	创建命令
		可以把多个命令放在同一行上，命令之间 用”;”分开。
			command1; command2; command3...
		一个shell命令
			先构想一个名字
				查询名字是否被使用
					test command_name
				创建命令
					alias name='string'
				查询创建命令
					type foo
				删除
					unalias command_name
		查看所有别名
			直接输入alias

第七章
	标准输入、输出和错误
		输入输出错误在本质上都是文件
			标准输入文件 stdin，默认情况下，连接键盘
			标准输出文件 stdout 默认连接屏幕
			标准错误文件 stderr 默认连接屏幕

	标准输出重定向
		>
		ls -l /usr/bin > ls-output.txt

		当我们使用 “>” 重定向符来重定向输出结果时，目标文件总是从开头被重写。
		如果我们需要清空一个文件内容（或者创建一个 新的空文件），可以使用这样的技巧：
			[me@linuxbox ~]$ > ls-output.txt

		>>
			将导致输出结果添加到文件内容之后。如果文件不存在，文件会 被创建，就如使用了”>”操作符。

	标准错误重定向
		没有专用的重定向符，shell把输入输出错误分别称为文件描述符0、1和2
		so
			ls -l /bin/usr 2> ls-error.txt
			可以重定向错误

	重定向标准输出和错误到同一个文件
			ls -l /bin/usr &> ls-output.txt

	处理不需要的输出
		不想要一个命令的输出结果，只想把它们扔掉。
		这种情况 尤其适用于错误和状态信息。
		系统通过重定向输出结果到一个叫做”/dev/null”的特殊文件， 为我们提供了解决问题的方法。
		这个文件是系统设备，叫做位存储桶，它可以 接受输入，并且对输入不做任何处理。
			ls -l /bin/usr 2> /dev/null

	标准输入重定向
		cat
			读取一个或多个文件，然后复制它们到标准输出，就像这样:
				cat [file]
			它也可以用来把文件连接在一起
				cat movie.mpeg.0* > movie.mpeg
			创建简短的文本文件
				cat > lazy_dog.txt
			我们知道 cat 怎样接受标准输入，除了文件名参数，让我们试着重定向标准输入：
				[me@linuxbox ~]$ cat < lazy_dog.txt

	管道线
		一个命令的标准输出可以通过管道送至另一个命令的标准输入
		也就是前一个命令的输出成为下一个命令的输入

		command1 | command2

	过滤器
		sort
			我们改变输出数据，从而产生一个 有序列表。
			sort将文件的每一行作为一个单位，相互比较，比较原则是从首字符向后，
			依次按ASCII码值进行比较，最后将他们按升序输出。
			参数
				-u 	去除重复行
				-r 	降序显示
				-n  按照数值排序

		uniq	报道或忽略重复行
			默认情况下，从数据列表中删除任何重复行
			-c 在输出行前面加上每行在输入文件中出现的次数。
			-d 仅显示重复行。
			-u 仅显示不重复的行。

		wc
			命令用来计算数字。利用wc指令我们可以计算文件的Byte数、字数或是列数
			-c或--bytes或——chars：只显示Bytes数；
			-l或——lines：只显示列数；
			-w或——words：只显示字数。
			1653    3305    29419
			行数    单词数  字节数

		grep
			是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。
			-i 忽略大小写
			-v 只打印不匹配行

		head/tail	打印文件开头部分/结尾部分
			command -n [number] file
			默认十行

			一般
			tail -n 5 ls-output.txt

			管道线
			ls /usr/bin | tail -n 5

			tail -f 可以实时检测文件内容

		tee	从 Stdin 读取数据，并同时输出到 Stdout 和文件
			管道监视器
			如 ls /usr/bin | tee ls.txt | grep zip
				有没有作用一样
				在 grep 过滤管道线的内容之前，来捕捉整个目录列表到文件 ls.txt

第八章
	echo 显示一行文本

	（字符）展开
		echo *
			当回车键被按下时，shell 在命令被执行前在命令行上自动展开任何符合条件的字符，
			所以 echo 命令的实际参数并不是”*“，而是它展开后的结果。

	路径展开
		通配符所依赖的工作机制叫做路径名展开
		ls /usr/*
		ls -A
			可以显示以跟正确的隐藏文件清单

	波浪线展开
		~ + username 是用户文件夹
		~ 是当前用户的家目录
		kk@kk-VirtualBox:~$ echo ~kk
		/home/kk
		kk@kk-VirtualBox:~$ echo ~
		/home/kk

	算术表达式展开
		$((expression))
		（以上括号中的）表达式是指算术表达式，它由数值和算术操作符组成。
			[me@linuxbox ~]$ echo $((2 + 2))
			4

		算术操作符
			操作符 	说明
			+ 		加
			- 		减
			* 		乘
			/ 		除（但是记住，因为展开只是支持整数除法，所以结果是整数。）
			% 		取余，只是简单的意味着，“余数”
			** 		取幂

		在算术表达式中空格并不重要，并且表达式可以嵌套
			[me@linuxbox ~]$ echo $(($((5**2)) * 3))
			75

		这是一个使用除法和取余操作符的例子。注意整数除法的结果：
			[me@linuxbox ~]$ echo Five divided by two equals $((5/2))
			Five divided by two equals 2
			[me@linuxbox ~]$ echo with $((5%2)) left over.
			with 1 left over.

	花括号展开
		{string1，string2,...}
		{1..2}
		{A..N}

		最常见的应用是，创建一系列的文件或目录列表。
			[me@linuxbox ~]$ mkdir Pics
			[me@linuxbox ~]$ cd Pics
			[me@linuxbox Pics]$ mkdir {2007..2009}-0{1..9} {2007..2009}-{10..12}
			[me@linuxbox Pics]$ ls
			2007-01 2007-07 2008-01 2008-07 2009-01 2009-07
			2007-02 2007-08 2008-02 2008-08 2009-02 2009-08
			2007-03 2007-09 2008-03 2008-09 2009-03 2009-09
			2007-04 2007-10 2008-04 2008-10 2009-04 2009-10
			2007-05 2007-11 2008-05 2008-11 2009-05 2009-11
			2007-06 2007-12 2008-06 2008-12 2009-06 2009-12

	参数展开
		准确来说是变量名展开
			[me@linuxbox ~]$ echo $USER
			me

			查看所有变量名
			[me@linuxbox ~]$ printenv | less

	命令替换
		命令替换允许我们把一个命令的输出作为一个展开模式来使用
			file $(ls /usr/bin/* | grep zip)
			commend $(commend) 把括号内的命令输出作为括号外的命令输入

	引用
		shell 提供了一种 叫做引用的机制，来有选择地禁止不需要的展开。
		举个例子
			[me@linuxbox ~]$ echo this is a    test
			this is a test
			会删除多余的空格

			[me@linuxbox ~]$ echo The total is $100.00
			The total is 00.00
			$1 1是无意义的参数名会用空格代替

		双引号
			如果你把文本放在双引号中， shell 使用的特殊字符，都失去它们的特殊含义，被当作普通字符来看待。
			有几个例外： $，\ (反斜杠），和 `（倒引号）。
			在双括号中只有波浪线展开不能用，其它展开都能用。
			还有的是单词分隔在双引号中是可以使用的

		单词分割机制
			在默认情况下，单词分割机制会在单词中寻找空格，制表符，和换行符，并把它们看作 单词之间的界定符。
			这意味着无引用的空格，制表符和换行符都不是文本的一部分， 它们只作为分隔符使用。

		单引号
			如果需要禁止所有的展开，我们要使用单引号。以下例子是无引用，双引号，和单引号的比较结果：
			[me@linuxbox ~]$ echo text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER
			text /home/me/ls-output.txt a b foo 4 me
			[me@linuxbox ~]$ echo "text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER"
			text ~/*.txt   {a,b} foo 4 me
			[me@linuxbox ~]$ echo 'text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER'
			text ~/*.txt  {a,b} $(echo foo) $((2+2)) $USER

		转义字符
			有时候我们只想引用单个字符。我们可以在字符之前加上一个反斜杠，在这里叫做转义字符。
			经常在双引号中使用转义字符，来有选择地阻止展开。

			[me@linuxbox ~]$ echo "The balance for user $USER is: \$5.00"
			The balance for user me is: $5.00

			反斜杠转义的字符被当作普通字符来看待

		反斜杠转义字符序列
			转义序列 	含义
			\a 			响铃（”警告”－导致计算机嘟嘟响）
			\b 			退格符
			\n 			新的一行。在类 Unix 系统中，产生换行。
			\r 			回车符
			\t 			制表符

		 echo $'\a' 能使用转义字符

第九章
	移动光标
		按键 	行动
		Ctrl-a 	移动光标到行首。
		Ctrl-e 	移动光标到行尾。
		Ctrl-f 	光标前移一个字符；和右箭头作用一样。
		Ctrl-b 	光标后移一个字符；和左箭头作用一样。
		Alt-f 	光标前移一个字。
		Alt-b 	光标后移一个字。
		Ctrl-l 	清空屏幕，移动光标到左上角。clear 命令完成同样的工作。

	修改文本
		按键 	行动
		Ctrl-d 	删除光标位置的字符。
		Ctrl-t 	光标位置的字符和光标前面的字符互换位置。
		Alt-t 	光标位置的字和其前面的字互换位置。
		Alt-l 	把从光标位置到字尾的字符转换成小写字母。
		Alt-u 	把从光标位置到字尾的字符转换成大写字母。

	剪切和粘贴文本
		按键 			行动
		Ctrl-k 			剪切从光标位置到行尾的文本。
		Ctrl-u 			剪切从光标位置到行首的文本。
		Alt-d 			剪切从光标位置到词尾的文本。
		Alt-Backspace 	剪切从光标位置到词头的文本。如果光标在一个单词的开头，剪切前一个单词。
		Ctrl-y 			把剪切环中的文本粘贴到光标位置。

	自动补全
		tab
		按键	行动
		Alt-?	显示可能的自动补全列表。在大多数系统中，你也可以完成这个通过按 两次 tab 键，这会更容易些。 alt + shift + ?
		Alt-*	插入所有可能的自动补全。当你想要使用多个可能的匹配项时，这个很有帮助。	alt + shift + *

	搜索历史命令（不完整）
		已经被执行过的文件都被保存在家目录的.bash_history
		history
			查看历史命令列表
			kk@kk-VirtualBox:~$ history | grep set
			30  set | less
			39  history | grep set

		数字代表历史列表中的行号，可以用!30来调用行号所代表的命令

		按键	行为
		Ctrl-p	移动到上一个历史条目。类似于上箭头按键。
		Ctrl-n	移动到下一个历史条目。类似于下箭头按键。
		Alt-<	移动到历史列表开头。
		Alt->	移动到历史列表结尾，即当前命令行。
		Ctrl-r	反向递增搜索。从当前命令行开始，向上递增搜索。
		Alt-p	反向搜索，不是递增顺序。输入要查找的字符串，然后按下 Enter，执行搜索。
		Alt-n	向前搜索，非递增顺序。
		Ctrl-o	执行历史列表中的当前项，并移到下一个。如果你想要执行历史列表中一系列的命令，这很方便

	历史命令展开
		序列		行为
		!!			重复最后一次执行的命令。可能按下上箭头按键和 enter 键更容易些。
		!number		重复历史列表中第 number 行的命令。
		!string		重复最近历史列表中，以这个字符串开头的命令。
		!?string	重复最近历史列表中，包含这个字符串的命令。

	拓展阅读
		Wikipedia 上有一篇关于计算机终端的好文章：

		http://en.wikipedia.org/wiki/Computer_terminal

第十章
	传统的unix系统支持多任务也支持多用户系统，这意味着多个用户可以在同一时间使用同一台计算机。
	除了在本机上直接使用键盘鼠标操控，也可以远程通过ssh（安全的shell）登陆并操作这台电脑。

	拥有者、组成员和其他人
		用户帐户 定义在/etc/passwd 文件里面，
		用户组定义在/etc/group 文件里面。
		当用户帐户和用户组创建以后，
		这些文件随着文件/etc/shadow 的变动而修改，文件/etc/shadow 包含了关于用户密码的信息。

	读取、写入和执行
		-rw-rw-r-- 1 me   me   0 2008-03-06 14:52 foo.txt

		第一个表示文件类型

		属性 	文件类型
		- 		一个普通文件
		d 		一个目录
		l 		一个符号链接。注意对于符号链接文件，剩余的文件属性总是"rwxrwxrwx"，而且都是 虚拟值。
				真正的文件属性是指符号链接所指向的文件的属性。
		c 		一个字符设备文件。这种文件类型是指按照字节流来处理数据的设备。 比如说终端机或者调制解调器
		b 		一个块设备文件。这种文件类型是指按照数据块来处理数据的设备，例如一个硬盘或者 CD-ROM 盘。

		剩下九个字符叫做文件模式，代表着文件所有者、文件组所有者和其他人的读、写和执行权限

		属性 	文件                             	目录
		r 		允许打开并读取文件内容。            允许列出目录中的内容，前提是目录必须设置了可执行属性（x）。
		w 		允许写入文件内容或截断文件。
				  但是不允许对文件进行重命名或删除，
				  重命名或删除是由目录的属性决定的。 	允许在目录下新建、删除或重命名文件，前提是目录必须设置了可执行属性（x）。
		x 		允许将文件作为程序来执行，		       允许进入目录，例如：cd directory 。
				  使用脚本语言编写的程序必须
				  设置为可读才能被执行。

		权限属性示例
		文件属性 		含义
		-rwx------ 		一个普通文件，对文件所有者来说可读、可写、可执行。其他人无法访问。
		-rw------- 		一个普通文件，对文件所有者来说可读可写。其他人无法访问。
		-rw-r--r-- 		一个普通文件，对文件所有者来说可读可写，文件所有者的组成员可以读该文件，其他所有人都可以读该文件。
		-rwxr-xr-x 		一个普通文件，对文件所有者来说可读、可写、可执行。也可以被其他的所有人读取和执行。
		-rw-rw---- 		一个普通文件，对文件所有者以及文件所有者的组成员来说可读可写。
		lrwxrwxrwx 		一个符号链接，符号链接的权限都是虚拟的，真实的权限应该以符号链接指向的文件为准。
		drwxrwx--- 		一个目录，文件所有者以及文件所有者的组成员可以访问该目录，并且可以在该目录下新建、重命名、删除文件。
		drwxr-x--- 		一个目录，文件所有者可以访问该目录，并且可以在该目录下新建、重命名、删除文件，文件所有者的组成员可以访问该目录，但是不能新建、重命名、删除文件。

	chmod － 更改文件模式
		八进制数字表示法修改文件模式

			Octal 	Binary 	File Mode
					0 		000 	---	0 + 0 + 0
					1 		001 	--x	0 + 0 + 1
					2 		010 	-w-	0 + 2 + 0
					3 		011 	-wx	0 + 2 + 1
					4 		100 	r--	4 + 0 + 0
					5 		101 	r-x	4 + 0 + 1
					6 		110 	rw-	4 + 2 +0
					7 		111 	rwx	4 + 2 + 1
					chmod 111 1.txt

			符号表示法修改文件模式
				chmod 命令符号表示法
					u 	"user"的简写，意思是文件或目录的所有者。
					g 	用户组。
					o 	"others"的简写，意思是其他所有的人。
					a 	"all"的简写，是"u", "g"和“o”三者的联合。

				chmod u=x 1.txt
				chmod uo+x 1.txt
				chmod u-x 1.txt

	借助 GUI 来设置文件模式

	umask － 设置默认权限
		当创建一个文件时，umask 命令控制着文件的默认权限。
			用补码的方式来确定默认权限
			000 000 000 000
			上面数字有一个1对应一种权限的删除

			Original file mode 	--- rw- rw- rw-
			Mask 				000 000 010 010
			Result 				--- rw- r-- r--

	一些特殊权限
		实际上来说文件应该是4位的文件模式，只是平常是出于隐藏状态
		setuid位（八进制4000）	对于文件
			当应用到一个可执行文件时，它把有效用户 ID 从真正的用户（实际运行程序的用户）设置成程序所有者的 ID。
			这个程序运行时具有超级用户的特权，这样程序就可以 访问普通用户禁止访问的文件和目录。
		setgid位（八进制2000） 针对文件或目录
			把有效用户组 ID 从真正的 用户组 ID 更改为文件所有者的组 ID。
			如果设置了一个目录的 setgid 位，
			则目录中新创建的文件 具有这个目录用户组的所有权，
			而不是文件创建者所属用户组的所有权。
		第三个是 sticky 位（八进制1000） 针对文件或目录
			它可能把一个可执行文件 标志为“不可交换的”。
			如果一个目录设置了 sticky 位， 那么它能阻止用户删除或重命名文件，
			除非用户是这个目录的所有者，或者是文件所有者，或是 超级用户。

	更改身份
		su － 以其他用户身份和组 ID 运行一个 shell
			su [-[l]] [user]
				su <user> 	切换用户user,不改变环境变量
				su -[l] <user>	切换用户，同时环境变量也会跟着改变为目标用户的环境变量
			退出
				输入 exit 回车或 ctrl + d

		以这样的方式使用 su 命令，也可以只执行单个命令，而不是启动一个新的可交互的 shell：
			su -c 'command'

		sudo － 以另一个用户身份执行命令
			sudo 可以使用本用户密码以管理员身份直接执行命令

第十一章
	进程是怎么工作的
		系统启动时，会将自己的活动初始化为进程，然后运行init程序（在/etc）。
		许多系统服务以守护程序进行，守护程序没有用户接口。
		这样我们没有登录系统也会自己执行些例行事物

		一个程序发动另一个程序被表述为父进程产生一个子进程

		每个进程都有一个pid来表示，init的pid永远是1

	ps 查看进程
		kk@kk-VirtualBox:~$ ps
		  PID TTY          TIME CMD
		 1625 pts/0    00:00:00 bash
		 1635 pts/0    00:00:00 ps
		 只是列出当前终端相关的进程，
		 TTY进程控制终端，
		 TIME进程所消耗的CPU时间数量

		 kk@kk-VirtualBox:~$ ps x
		   PID TTY      STAT   TIME COMMAND
		  1030 ?        Ss     0:00 /lib/systemd/systemd --user
		  1031 ?        S      0:00 (sd-pam)
		  1044 ?        SLl    0:00 /usr/bin/gnome-keyring-daemon --daemonize --login
		  1048 tty1     Ssl+   0:00 /usr/lib/gdm3/gdm-x-session --run-script env GNOME_SH
			。。。。。。
			ps x 展示所有进程
			TTY有？是指没有控制终端
			STAT是指进程的当前状态
			状态	含义
			R	    运行中。这意味着，进程正在运行或准备运行。
			S	    正在睡眠。进程没有运行，而是，正在等待一个事件，
			      比如说，一个按键或者网络分组。
			D	    不可中断睡眠。进程正在等待 I/O，比方说，一个磁盘驱动器的 I/O。
			T	    已停止. 已经指示进程停止运行。稍后介绍更多。
			Z	    一个死进程或“僵尸”进程。这是一个已经终止的子进程，
						但是它的父进程还没有清空它。 （父进程没有把子进程从进程表中删除）
			<	    一个高优先级进程。这可能会授予一个进程更多重要的资源，
						给它更多的 CPU 时间。 进程的这种属性叫做 niceness。
						具有高优先级的进程据说是不好的（less nice）， 因为它占用了比较多的 CPU 时间，
						这样就给其它进程留下很少时间。
			N	    低优先级进程。 一个低优先级进程（一个“nice”进程）只有当其它高优先级进程被服务了之后，
						才会得到处理器时间。

		kk@kk-VirtualBox:~$ ps aux
			USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
			root         1  0.7  0.4 159852  9188 ?        Ss   16:48   0:03 /sbin/init spla
			root         2  0.0  0.0      0     0 ?        S    16:48   0:00 [kthreadd]
			root         3  0.0  0.0      0     0 ?        I<   16:48   0:00 [rcu_gp]
			root         4  0.0  0.0      0     0 ?        I<   16:48   0:00 [rcu_par_gp]
			root         6  0.0  0.0      0     0 ?        I<   16:48   0:00 [kworker/0:0H-k
			root         8  0.0  0.0      0     0 ?        I<   16:48   0:00 [mm_percpu_wq]
			root         9  0.0  0.0      0     0 ?        S    16:48   0:00 [ksoftirqd/0]
			root        10  0.0  0.0      0     0 ?        I    16:48   0:00 [rcu_sched]
			root        11  0.0  0.0      0     0 ?        S    16:48   0:00 [migration/0]
			root        12  0.0  0.0      0     0 ?        S    16:48   0:00 [idle_inject/0]
			root        13  0.0  0.0      0     0 ?        I    16:48   0:00 [kworker/0:1-cg
			root        14  0.0  0.0      0     0 ?        S    16:48   0:00 [cpuhp/0]
			。。。。。。

			BSD 风格的 ps 命令列标题
			标题	含义
			USER	用户 ID. 进程的所有者。
			%CPU	以百分比表示的 CPU 使用率
			%MEM	以百分比表示的内存使用率
			VSZ	  虚拟内存大小
			RSS	  进程占用的物理内存的大小，以千字节为单位。
			START	进程启动的时间。若它的值超过24小时，则用天表示。

	top 动态查看进程
		top - 14:59:20 up 6:30, 2 users, load average: 0.07, 0.02, 0.00
		Tasks: 109 total,   1 running,  106 sleeping,    0 stopped,    2 zombie
		Cpu(s): 0.7%us, 1.0%sy, 0.0%ni, 98.3%id, 0.0%wa, 0.0%hi, 0.0%si
		Mem:   319496k total,   314860k used,   4636k free,   19392k buff
		Swap:  875500k total,   149128k used,   726372k free,  114676k cach

		 PID  USER       PR   NI   VIRT   RES   SHR  S %CPU  %MEM   TIME+    COMMAND
		6244  me         39   19  31752  3124  2188  S  6.3   1.0   16:24.42 trackerd
		....

		top 命令信息字段
		行号	字段	    意义
		1	    top     	程序名。
	      	14:59:20	当前时间。
		up    6:30	    这是正常运行时间。它是计算机从上次启动到现在所运行的时间。
		                在这个例子里，系统已经运行了六个半小时。
		2     users	    有两个用户登录系统。
		      load
				  average:	加载平均值是指，等待运行的进程数目，也就是说，
					          处于可以运行状态并共享 CPU 的进程个数。
										这里展示了三个数值，每个数值对应不同的时间段。
										第一个是最后60秒的平均值， 下一个是前5分钟的平均值，
										最后一个是前15分钟的平均值。若平均值低于1.0，
										则指示计算机 工作不忙碌。

		2	    Tasks:  	总结了进程数目和这些进程的各种状态。
		3   	Cpu(s):	  这一行描述了 CPU 正在进行的活动的特性。
	       	0.7%us	  0.7% 的 CPU 被用于用户进程。这意味着进程在内核之外。
      		1.0%sy  	1.0%的 CPU 时间被用于系统（内核）进程。
	      	0.0%ni   	0.0%的 CPU 时间被用于"nice"（低优先级）进程。
	      	98.3%id	  98.3%的 CPU 时间是空闲的。
	      	0.0%wa	  0.0%的 CPU 时间来等待 I/O。
	  4   	Mem:	    展示物理内存的使用情况。
		5	    Swap:	    展示交换分区（虚拟内存）的使用情况。



	控制进程
		实例程序
			xlogo
		中断进程
			ctrl + c
		程序后台执行
			kk@kk-VirtualBox:~$ xlogo &
			[1] 1874
			任务号+PID

			jobs
				列出终端中启动的任务
				kk@kk-VirtualBox:~$ jobs
				[1]+  运行中               xlogo &

		进程返回前台
			后台运行的程序对一切来自键盘的输入都免疫，不能用ctrl + c来中断它
			kk@kk-VirtualBox:~$ fg %1
			xlogo
			用fg + %[任务序号]，就可以返回前台
			再用ctrl + c 就可以中断

		停止一个进程
			ctrl + z 可以停止一个前台进程
			kk@kk-VirtualBox:~$ xlogo
			^Z
			[1]+  已停止               xlogo

			可以使用fg 来移到前台
			也可以使用bg移到后台运行
				kk@kk-VirtualBox:~$ bg %1
				[1]+ xlogo &

	singnal
		kill 给进程发送信号
			kill + pdi/%[任务序号]可以直接终止程序

			kk@kk-VirtualBox:~$ jobs
			kk@kk-VirtualBox:~$ xlogo &
			[1] 1957
			kk@kk-VirtualBox:~$ kill %1
			kk@kk-VirtualBox:~$ jobs
			[1]+  已终止               xlogo

			给进程发送信号
				kill [-signal] PID...
				常用信号
					编号	名字	含义
					1    	HUP	 挂起（Hangup）。这是美好往昔的残留部分，
										 那时候终端机通过电话线和调制解调器连接到 远端的计算机。
										 这个信号被用来告诉程序，控制的终端机已经“挂断”。
										 通过关闭一个终端会话，可以展示这个信号的作用。
										 在当前终端运行的前台程序将会收到这个信号并终止。
										 许多守护进程也使用这个信号，来重新初始化。
										 这意味着，当一个守护进程收到这个信号后，
										 这个进程会重新启动，并且重新读取它的配置文件。
										 Apache 网络服务器守护进程就是一个例子。

					2   	INT	中断。实现和 Ctrl-c 一样的功能，由终端发送。通常，它会终止一个程序。
					9   	KILL	杀死。这个信号很特别。尽管程序可能会选择不同的方式来处理发送给它的 信号，其中也包含忽略信号，但是 KILL 信号从不被发送到目标程序。而是内核立即终止 这个进程。当一个进程以这种方式终止的时候，它没有机会去做些“清理”工作，或者是保存工作。 因为这个原因，把 KILL 信号看作最后一招，当其它终止信号失败后，再使用它。
					15  	TERM	终止。这是 kill 命令发送的默认信号。如果程序仍然“活着”，可以接受信号，那么 这个它会终止。
					18   	CONT	继续。在一个停止信号后，这个信号会恢复进程的运行。
					19  	STOP	停止。这个信号导致进程停止运行，而不是终止。像 KILL 信号，它不被 发送到目标进程，因此它不能被忽略。

				kill -l
					显示所有信号列表

					其它常用信号
						编号	名字	含义
						3   	QUIT	退出
						11	  SEGV	段错误(Segmentation Violation)。如果一个程序非法使用内存，
						            就会发送	这个信号。也就是说， 程序试图写入内存，
												而这个内存空间是不允许此程序写入的。
						20  	TSTP	终端停止(Terminal Stop)。当按下 Ctrl-z 组合键后，
					            	终端发送这个信号。不像 STOP 信号，
					             	TSTP 信号由目标进程接收，且可能被忽略。
						28  	WINCH	改变窗口大小(Window Change)。当改变窗口大小时，
						            系统会发送这个信号。 一些程序，像 top 和 less 程序会响应这个信号，
												按照新窗口的尺寸，刷新显示的内容。


		killall 给多个进程发送信号
			通过killall来碓特定程序或者用户名的多个进程发送信号
				killall [-u user] [-signal] name...
			kk@kk-VirtualBox:~$ xlogo &
			[5] 2643
			[4]   已终止               xlogo
			kk@kk-VirtualBox:~$ xlogo &
			[6] 2644
			kk@kk-VirtualBox:~$ xlogo &
			[7] 2645
			kk@kk-VirtualBox:~$ killall xlogo
			[5]   已终止               xlogo
			[6]-  已终止               xlogo
			[7]+  已终止               xlogo

			额kill一样你需要超级用户权限才能给不属于你的进程发送信号

		其它和进程相关的命令
		命令名	 命令描述
		pstree	输出一个树型结构的进程列表(processtree)，这个列表展示了进程间父/子关系。
		vmstat	输出一个系统资源使用快照，包括内存，交换分区和磁盘 I/O。 为了看到连续的显示结果，则在命令名后加上更新操作延时的时间（以秒为单位）。例如，“vmstat 5”。 ，按下 Ctrl-c 组合键, 终止输出。
		xload  	一个图形界面程序，可以画出系统负载随时间变化的图形。
		tload 	terminal load与 xload 程序相似，但是在终端中画出图形。使用 Ctrl-c，来终止输出。
