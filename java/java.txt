java开发基础

	windows操作系统当中常用的DOS命令：
		* 不使用UI界面，使用DOS命令可以完成所有的操作。

		* 在哪里执行DOS命令？
			- 在DOS命令窗口中可以执行DOS命令

		* 怎么打开DOS命令窗口呢？
			- 快捷键：win + r，打开运行窗口
			- 输入cmd回车

		常用命令
			* 查看IP配置：
				- ipconfig
				- ipconfig /all  可以查看更详细的IP信息，这种查看方式可以看到网卡的物理地址。
									物理地址具有全球唯一性。是在生产网卡的时候，嵌入的编号。
			* 清屏：
				cls

			* DOS窗口当中也可以设置字体和屏幕以及文字的颜色。
				color ？ 
				这个命令color和问号之间是有空格的
				color命令的帮助文档

			* 退出DOS命令窗口
				exit

			* 查看两台计算机之间是否可以正常通信：
				- ping 192.168.27.23   【发送和接收数据包4次】
				- ping 192.168.27.23 -t 【一直不停的发送和接收数据包】
				- ping www.baidu.com

			* 强行终止DOS命令窗口中正在运行的程序：ctrl + c

			* 打开DOS命令窗口默认所在的路径是：C:\Users\Administrator\???

			* 创建目录：mkdir abc【表示在当前所在目录下新建一个目录，起名abc】

			* 关于目录切换命令：cd

				- cd 命令的语法格式：

					cd 路径

				- 路径分为：

					- 绝对路径：
						C:\Users\Administrator
						D:\用户目录\收藏夹
						F:\tools\CamtasiaStudio-v6.00
						......

						从硬盘的根路径作为出发点。

					- 相对路径：
						从当前所在的位置作为起点的路径。
				
				- 自动补全：
					cd e 【然后按tab键，当前所在的目录下所有以e开始的目录自动补全路径，
						当这个自动补全的路径不是自己想要的路径，可以继续使用tab键】
				
				- 回到上级目录：cd .. 【..是一个路径，代表当前路径的上级路径】
						cd ../../../

				- 直接回到根路径：cd \

			* 查看当前目录下所有的子文件和子目录：
				dir

			* 不要把相关重要的资料放到桌面上，因为桌面是属于C盘系统盘。

			* 怎么切换盘符：【不需要使用cd命令】
				c: 回车
				d: 回车
				e: 回车 
				f: 回车

	什么是JDK？
		* Java Development Kits
		* Java开发工具箱【Java开发必备】
		* 可以从Oracle的官网上下载。http://www.oracle.com
		* 下载JDK的时候需要注意：JDK的版本，不同的操作系统需要安装不同版本的JDK。

	Java分三大块：1999年

		* J2SE【Java的标准版本】：

			基础，无论是以后走EE还是ME，SE是必须要精通的。
			J2SE是SUN公司为java程序员准备的一套“基础类库”，这套基础类库学习之后，可以完成最基本的操作，
			例如，文件的读写、线程的控制....

		* J2EE【Java的企业版本】：

			这是SUN公司为程序员专门准备的一套“类库”，这套类库可以协助程序员完成企业级软件的开发
			企业级软件：OA办公系统、进销存系统、超市系统.......

		* J2ME【Java的微型版本】
			
			这是SUN公司为java程序员专门准备的另一套“类库”，这套类库可以协助程序员完成微型设备的嵌入式开发，
			Java最初就是做微型设备嵌入式开发的。

	Java语言特性：

		* 跨平台/可移植 
			-说白了就是在linux上面写的程序，不需要任何改动也可以在windows上运行，这就是可移植性或者说跨平台。
			- 有一种特殊的机制：JVM
			- Java程序并没有和底层的操作系统直接交互，java程序实际上运行在jvm当中，JVM屏蔽了操作系统之间的差异。
			- 但是有一个前提：不同的操作系统中必须安装不同版本的JVM。
			- 在可移植性方面表现非常好，一次编译，到处运行。
			- 但是为了达到可移植，必须提前在操作系统中安装JRE，JRE有了之后才会有JVM。【JVM不能单独安装】
			这方面体验不是特别好。

		* Java号称：开源、免费、跨平台、纯面向对象。

			- 开源：开发源代码，SUN公司编写的java类库的源代码普通程序员能看到。众人拾柴火焰高。
			这样java程序会很健壮。很少的BUG【漏洞/陷阱】

			- 免费

			- 跨平台：依靠JVM机制【java程序不和操作系统交互，java程序运行在JVM中，JVM和操作系统交互。】
			不同的操作系统有不同版本的JVM。

			- 面向对象：人类在认识现实世界的时候多数是以面向对象的方式认知的。
		
		* 简单性：
			* 这里的简单说的是相对于C语言来说的。
			* 例如：C语言当中有指针，C++中多继承
			* java取消了指针的概念，取消了多继承，只支持单继承。
			* java 底层是用c++实现的
			
		
		* java支持多线程

		* java中还有一种特殊的机制：自动垃圾回收机制。GC机制。
			【java运行过程当中有一个“垃圾回收器”一直在守护者。】
			java在运行过程中产生的垃圾会自动回收，不需要程序员关心

	Java的加载与执行：一个完整的java程序
		
		* Java开发的整个生命周期，包括两个重要的阶段，分别是：编译阶段和运行阶段

		* 编译生成的程序被称为：字节码程序。编译生成的文件是：xxx.class文件

		* 编译和运行可以在不同的操作系统中完成。

		* 程序员在xxx.java文件中编写源代码，源代码必须符合java的语法，这些源代码就是高级语言。
		存放源代码的文件被称为源文件。

		* 过程：

			编译期：【在windows环境中完成】
				- 安装JDK，配置环境
				- 在硬盘的某个位置创建一个xxx.java源文件
				- 打开源文件，在该文件当中编写符合java语法的源程序，然后保存。
				- 使用JDK中自带的javac.exe命令对以上的java源程序进行编译。
					* 编译通过：说明语法没有问题
						- 在硬盘上生成一个或者多个字节码文件【xxx.class】
						- class 文件是最终执行的文件
					* 编译失败：说明源程序某个位置不符合java语法格式。
					* 编译的语法格式：打开DOS命令窗口，输入：javac 源文件路径

					注意：
						- 源文件路径可以是绝对路径，也可以是相对路径。
						- 编译之后，其实java源文件删除不会影响程序的执行。
						- 最好不要将java源文件删除，因为程序最终运行效果不是预期效果的时候，需要
						重新修改java源代码，然后进行重新编译生成全新的class字节码文件，再重新运行
						字节码程序。

			---------------------------------------------------------------------------

			运行期：【可以不在windows中完成，可以换一个操作系统，但前提是该操作系统中已经安装java的运行时环境】

				- 打开命令窗口，在命令窗口中使用java.exe命令运行java程序，语法格式：
					java 类名

					注意：java这个命令使用的时候，java命令后面不是文件的路径。必须是一个“类名”。
					例如：
						java Hello  
						java Student
						java User
						java Product
						不要写成 java hello.class 这个格式，直接写类名就行

				- 以上程序的执行原理：
					* java.exe命令执行会启动：JVM
					* JVM启动之后，马上启动“类加载器-Class Loader”
					* ClassLoader负责去硬盘的“某个位置”上搜索“类名.class”字节码文件。
					* 找不到这个.class文件，一定会出现程序异常现象。
					* 找到了这个.class文件之后将.class文件转换成"二进制"，操作系统可以直接识别二进制，
					操作系统执行二进制码和底层的硬件平台进行交互。
						
	开始第一个java程序的开发
		
		* JDK下载

		* JDK安装
			JDK包括JRE（运行环境）
		* JRE有单独软件安装
			包括JVM
		* 在硬盘的某个位置上新建一个java源文件：HelloWorld.java

		* 在HelloWorld.java文件中编写源代码

		* 打开命令窗口，使用javac命令进行编译： 
			javac 源文件路径

			出现以下错误：
				C:\Users\Administrator>javac
				'javac' 不是内部或外部命令，也不是可运行的程序
				或批处理文件。
			
			怎么解决？

				第一种方案：切换到javac.exe文件所在的目录，这个时候使用javac.exe不会出问题，但是这种方式比较麻烦。

				第二种方案：配置环境变量path
			
			原理：windows操作系统在查找某个命令的时候是怎么查找的？
				* 首先会从当前目录下找这个命令
				* 当前目录下不存在这个命令的话，会去环境变量path指定的路径当中查找该命令。
				* 还是找不到则出现错误提示信息。

				- path环境变量隶属于windows操作系统，和java无关，这个环境变量主要用来指定命令的搜索路径。
			
			环境变量怎么配置？

				计算机 --> 点击右键 --> 属性 --> 高级系统设置 --> 环境变量

			环境变量配置包括用户级别和系统级别

			任何一个环境变量都有变量名和变量值，例如path环境变量：
				变量名是:path
				值：路径【多个路径之间必须采用分号隔开，而且要求分号必须是半角分号】
				path=C:\Program Files (x86)\Java\jdk1.7.0_75\bin;otherpath;otherpath.....
		
			编译1【绝对路径】：D:\course\JavaProjects>javac D:\course\JavaProjects\02-JavaSE\day01\HelloWorld.java
			编译2【相对路径】：D:\course\JavaProjects>javac 02-JavaSE\day01\HelloWorld.java
			编译3【相对路径】：D:\course\JavaProjects\02-JavaSE\day01>javac HelloWorld.java

			修改完以后要重新开启dos窗口才能使用新设定的path

		* 运行：
			- 必须将路径切换到“D:\course\JavaProjects\02-JavaSE\day01”目录下
			- 执行：java HelloWorld

			- D:\course\JavaProjects\02-JavaSE\day01>java HelloWorld
				Hello World!
				
	打开DOS命令窗口，执行java HelloWorld，执行原理？
		* java.exe命令会启动JVM
		* JVM启动之后会启动类加载器ClassLoader
		* ClassLoader会在硬盘上的某个位置搜索HelloWorld.class字节码文件
		* 找到该文件则执行
		* 找不到该文件则报错

		疑问:ClassLoader是在哪个位置上搜索HelloWorld.class字节码文件的？
			* 默认情况下，ClassLoader从当前路径下加载xxx.class字节码文件
			* 当然，也可以让ClassLoader去某个指定的路径下加载字节码文件，这时需要配置环境变量classpath
			* classpath环境变量属于java语言中的环境变量，不属于windows操作系统【PATH环境变量属于操作系统】
			* classpath是给ClassLoader类加载器指路的。
			* 设置这样的环境变量：classpath=D:\course\JavaProjects\02-JavaSE\day02
				- 打开dos命令窗口在任意位置，都可以执行：java HelloWorld
			* classpath环境变量没有配置的话，类加载器默认从当前路径下找字节码文件，
			当classpath环境变量配置为某个指定的路径之后，类加载器只去指定的路径当中加载字节码文件。
			* 综上所述，环境变量classpath不再配置，这样类加载器会自动从当前路径下加载class字节码文件。
			所以，每一次执行.class程序的时候，需要在DOS命令窗口中先切换到.class字节码文件所在的路径下。
			然后运行。
			* 当然，classpath也可以这样配置：classpath=.

			注意：
				路径中“..”表示上级目录
				路径中“.”表示当前目录   
				
	关于java源程序当中的注释：
		
		* 什么是注释？注释的作用是什么？
			- 出现在java的源程序当中，对java源代码的解释说明
			- 注释不会被编译到.class字节码文件当中		    
			- 一个好的开发习惯应该是多编写注释，这样程序的可读性比较强。
		
		* java中的注释怎么写呢？
			- 单行注释
				//单行注释，只注释当前行

			- 多行注释
				/*
					多行注释
					多行注释
					多行注释
					多行注释
					多行注释
					.....
				*/

			- javadoc注释
				/**
				*	javadoc注释
				*	javadoc注释
				*	javadoc注释
				*	javadoc注释
				*	javadoc注释
				*	javadoc注释
				*/
				注意：这种注释是比较专业的注释，该注释信息会被javadoc.exe工具解析提取并生成帮助文档。
		
	对HelloWorld程序进行解释：
		//public 表示公开的
		//class表示定义一个类
		//HelloWorld表示一个类名
		public class HelloWorld{ //表示定义一个公开的类，起名HelloWorld
		//类体【记住】 里面的内容
		//类体不允许直接编写java语句，除声明变量外
		//System.out.println("xxxxxxx");这种java语句不允许在类体里编写
		/*
			public表示公开的
			static表示静态的
			void表示空
			main表示方法名是main
			(String[] args)表示main方法的形式参数列表
			需要记住的是：以下的方法是一个程序的“主方法” ，是程序的执行入口
			是sun公司规定的，固定编写方法
		*/
		public static void main(String[] args){   //表示定义一个公开的静态的主方法
			//方法体
			

			//java语句【java语句以分号“;“结尾，分号必须是半角的分号】
			//先记住，一下这样的代码的作用是向控制台输出一段消息
			//以下的双引号必须是半角的双引号【是java语法的一部分】
			//java中所有的字符串都使用双引号括起来。
			System.out.println("hello world");
			//再向控制台输出消息
			System.out.println("hello jackson!")
			//输出中文
			System.out.println("你好,杰克!")
			//输出文中
			System.out.println("我是一个程序员")

		}
		}

		需要记忆：
			* public
			* class
			* static
			* void
			* System.out.println(""); 向控制台输出消息
			* 类体
			* 方法体
			* 类体中不能直接编写java语句【除声明变量之外】
			* 一个java语句必须以“;”结束
			* 方法体中可以编写多条java语句
			* 主方法是程序的入口，固定写法，SUN规定的。  
			
	public class 和 class的区别：
		
		* 一个java源文件当中可以定义多个class	
			class A{}
			class B{}
			class C{}

		* 一个java源文件当中public的class不是必须的

		* 一个class会定义生成一个xxx.class字节码文件

		* 一个java源文件当中定义公开的类的话，只能有一个，并且该类名称必须和java源文件名称一致。

		* 每一个class当中都可以编写main方法，都可以设定程序的入口，想执行B.class中的main方法：java B，
		想执行X.class当中的main方法：java X

		* 注意：当在命令窗口中执行java Hello，那么要求Hello.class当中必须有主方法。没有主方法会出现运行
		阶段的错误：
			D:\course\JavaProjects\02-JavaSE\day02>java Hello
			错误: 在类 B 中找不到主方法, 请将主方法定义为:
				public static void main(String[] args)

	总结第一章需要掌握的内容：
		* 理解java的加载与执行
		* 能够自己搭建java的开发环境
		* 能够独立编写HelloWorld程序，编译并运行
		* 掌握环境变量path的原理以及如何配置
		* 掌握环境变量classpath的原理以及如何配置
		* java中的注释
		* public class 和 class 的区别
		
java语言基础

	关于java语言的标识符
		什么是标识符
			在java源程序中可以自己命名的单词都是标识符
			标识符在editplus中以黑色字体高亮显示
			标识符可以标识什么元素
				类名
				方法名
				变量名
				接口名
				常量名
				。。。

	标识符的命名规则 【不按照这个规则编译器会报错】（背）
		一个合法的标识符只能由数字、字母、下划线、美元符号组成
		不能以数字开头
		严格区分大小写
		关键字不能做标识符
		理论上无长度限制

	标识符命名规范 【只是一种规范，不属于语法，不遵守编译器不会报错】（背）
		最好见名知意
		遵守驼峰命名方式
			SystemService
			UserService
		类名、接口名：首字母大写，后面每个单词首字母大写
		变量名、方法名：首字母小写，后面每个单词首字母大写
		常量名：全部大写

	关键字
		java中关键字都是小写的

	字面值
		10、100
		3.14
		“abc”
		‘a'
		true、false
		字面值是数据
		
		数据在现实世界中是分门别类的，所以数据在计算机编程语言中也是有类型的【数据类型 】
			10		整数型字面值
			3.14		浮点型字面值
			true false	布尔型字面值
			"abc"		字符串型字面值
			'A'		字符型字面值
		java语言中字符串型字面值必须用双引号半角的括起来
		java语言中字符型字面值必须用单引号半角的括起来
		字面值会占据内存空间，两个相同的字面值内存空间不一样
		比如：
			System.out.println(123);
			System.out.println(123);
			两条语句里面的字面值是在不同的内存空间
		
	变量
		什么是变量
			变量本质上是内存中的一块空间，这个空间有数据类型、有名字、有字面值
			变量包含三部分：数据类型、字面值【数据】、名称
			变量是内存存储数据的最基本单元
		
		数据类型的作用
			不同的数据有不同的类型，不同的数据类型底层会分配不同大小的空间
			数据类型是知道程序在运行阶段应该分配多大的内存空间

		变量要求：变量中存储的数据必须和变量的数据类型必须一致

		声明/定义变量的语法格式：
			数据类型 变量名；
				数据类型
					int char float
				变量名
					只要是合法的标识符就行
			
			例如
				int i;
				int age;
				int size;

		变量名怎么赋值
			语法格式
				变量名 = 字面值；
			要求： 字面值的数据类型必须与变量名一致
			= 等号是个运算符，叫做赋值运算符，赋值运算符先运算等号右边的表达式，
			执行结束后的结果赋值给左边的变量
		
		声明和赋值可以放在一起
			int i = 10;

			int a ,b,c = 2; // 注意这里的a、b 没有赋值

			int a = 2,b,c = 2; // 这里b没有赋值
		
		变量在一行上可以声明多个
			int a, b, c；

		通常访问一个变量包括两种访问形式：
			第一种：读取变量中保存的具体数据
			第二种：修改变量中保存的具体数据
		
		变量必须先声明赋值后才能访问
			public class IdentifierTest01 
				{
					public static void main(String[] args) 
					{
						int i;//程序运行到这里，内存空间并没有开辟出来，变量i并没有初始化
						System.out.println(i);
					}
				}

			没有赋值直接使用会出现编译报错

			public class IdentifierTest01
			{
				public static void main(String[] args)
				{

					int a, b, c = 300;   //这里只有c被赋值了a、b是没有被赋值的
					System.out.println(a);
					System.out.println(b);
					System.out.println(c);
				}
			}
		
		方法体中的java代码，是遵守自上而下的顺序执行的（方法体）
			第一行；
			第二行；
			第三行；
			特点：第二行的代码必须完整结束后，第三行程序才能执行。

		在同一个作用域当中，变量名不能重名，同一个变量名不能重新声明，但可以重新赋值

			public class IdentifierTest01 //类名，可以改
			{
				public static void main(String[] args) //main方法名 args变量名
				{

					int a = 1;
					int b = 2;
					int c = 3;
					System.out.println(a);
					System.out.println(b);
					System.out.println(c);
					int a = 45;  //不能重复声明，会直接编译报错
					System.out.println(a);
				}

			}
		
		变量的作用域
			什么是作用域
				变量的作用域，器是描述的是变量的有效范围
				在什么范围之内是可以被访问的，只要出了这个范围该变量
				就无法访问了
			
			变量的作用域只要记住一句话：
				出了大括号就不认识了

				public class IdentifierTest01 
					{
						public static void main(String[] args) 
						{

							int a = 1;

						}
						public static void other(String[] args )
						{
							System.out.println(a);	//使用不了a，会编译错误
						}
					}

				public class IdentifierTest01 
					{
						static int k = 123;	 //这里的static不能去掉
											//k的作用域是在类体范围内
						public static void main(String[] args) 
						{

							
						}
						public static void other(String[] args )
						{
							System.out.println(k);
						}
					}
				
				public class IdentifierTest01 
					{
						public static void main(String[] args) 
						{

						for(int a=0;a<10;a++) //a变量的作用域是整个for循环，for循环结束之后，a变量的内存就释放了
							{
								
							}
						System.out.println(a);//不能访问
							
						}
					}
				
				public class IdentifierTest01 
				{
					public static void main(String[] args) 
					{
					int a; //这个作用域是main方法
					for( a=0;a<10;a++)
						{
							
						}
					System.out.println(a);//可以访问
						

					}
				}
		
		变量的分类
			根据变量声明的位置来分类：
				局部变量
					在方法体中声明的变量
				成员变量
					在方法体外类体之内的变量
		
		在不同的作用域当中，变量名是可以相同的

		在同一个作用域当中，变量名不能重名

		类体中不能写java语句，但可以声明变量
			public class IdentifierTest01 
				{
					static int k = 100;//成员变量
					
					public static void main(String[] args) 
					{
						int a = 3; //局部变量
						
						System.out.println(a);//java遵循就近原则，所以打印的是上面这个局部变量a
							

					}
					static int a= 2;//可以重名，因为不在同一个作用域中
					public static void other(String[] args)
					{ 
						System.out.println(a);

					}

				}
				   
	数据类型
		数据类型的作用
			数据类型的作用是指导JVM在运行程序的时候给该数据分配多大的内存空间
		
		java数据类型包括两种
			基本数据类型
				
			引用数据类型【后面讲】
				类
				接口
				数组
				
		基本数据类型
			包括四大类八小种
				第一类 整数型
					byte short int long
				第二类 浮点型
					float double
				第三类 布尔型
					boolean
				第四类 字符型
					char
					
			字符串不属于基本数据类型，属于引用数据类型，字符属于基本数据类型
				字符串用双引号 “zbcv”
				字符用单引号 ‘a’
			
			八种基本数据类型占用空间大小是多少
				基本数据类型		 占用空间 【单位：字节】	范围
				byte				1	   		-128 - 127
				short				2			-32768-32767
				int					4
				long				8
				float				4
				double				8
				boolean				1			 true,false
				char				2			 0-65535
				
				注意char和short表示的个数是相同的，只不过char没负数所以能表示更大的整数

			字节
				1 byte = 8 bit
				1 bit 1/0
				
			整数型当中的byte是1字节 8个比特位，它的范围
				byte类型的最大值是 01111111【1000000（二进制） -1】 = 127【2的七次方减1】，因为最左边是符号位
				byte类型的最小值是  -128
				byte取值范围 -128 到 127    ‘

			关于八种基本数据类型的默认值
				八种基本数据类型的默认值是一切向0看齐
				byte short int long	0
				float double		0.0
				boolean			false[true 1 false 0]
				char			\u00000
				
			成员变量只声明没有赋值，系统会默认赋值【局部变量不会】  
				特别说明
					引用数据类型会被赋值为null
				public class IdentifierTest01 
				{
					static byte a;//成员变量
					static short b;
					static int c;
					static long d;
					static float e;
					static double f;
					static boolean g;
					static char h;

					public static void main(String[] args) 
					{
					
					System.out.println(a);
					System.out.println(b);
					System.out.println(c);
					System.out.println(d);
					System.out.println(e);
					System.out.println(f);
					System.out.println(g);
					System.out.println(h);

						

					}


				}

				结果：
					0
					0
					0
					0
					0.0
					0.0
					false

		char类型
			char类型刚好可以存储一个中文
				public class IdentifierTest01 
				{

					public static void main(String[] args) 
					{
					char a = 'a';
					char b = '陈';
					System.out.println(a);
					System.out.println(b);
					}

				}
				
			字符串型不能存储一个字符型，类型不兼容
				public class IdentifierTest01 
					{

						public static void main(String[] args) 
						{
						char a = 'a';
						char b = '陈';
						char c = "b";
						System.out.println(a);
						System.out.println(b);
						System.out.println(c);
						}

					}

				编译结果：
					IdentifierTest01.java:40: 错误: 不兼容的类型: String无法转换为char
					char c = "b";
						^
					1 个错误
		
			转义字符
				\在java语言中具有转义功能
				
				System.out.println 输出自带换行，System.out.print输出不带有换行。
				
				\t 制表符	就是tab键
				\n 换行符	就是enter键
				两者ascII码不一样
				\\ 	
				\'
				\"
				\uxxxx unicode编码
				
				
				转义字符在特殊字符前，会把特殊字符转换成普通字符
					System.out.prinln('//');
						第一个反斜杠把第二个反斜杠转移成普通的反斜杠字符
					
					char a = '';
						在java中是不允许这样编写程序
					
					char a = ‘’‘;
					System.out.print(a);
						第一个单引号和第二个配对，最后一个单引号找不到配对的
						
					charf a = '\'';
					System.out.print(a);
						反斜杠具有转义功能，将第二个单引号转换成普通的单引号字符
						
					char a = '“”';
					System.out.print(a);
						编译成功
						
					System.out.print("\"\"");
						这样才能实现打印双引号
						
					char m = '\u4e2d';
						unicode编码
			
			char类型的默认值
				/u0000 代表什么都没有的东西
				
		整数型
			关于整数型字面值
				java语言中的整数型字面值被默认当作int类型处理，要让整数型字面值被当作long类型来处理的话
				需要在
				整数型字面值后面添加l/L，建议使用大写的L
				
			java语言中整数型字面值有三种方式
				十进制 是一种缺省默认的方式
				八进制 在编写八进制整数型字面值的时候需要以0开始
				十六进制 在编写十六进制整数型字面值的时候需要以0x开始
			
				int a = 10;
				int b = 010;
				int c = 0x10;
			
			long类型赋值int类型字面值存在类型转换
				int类型是小容量
				long是大容量
				小容量可以自动转换为大容量
				成为自动类型转换机制
				
				int d = 456;
				System.out.println(d);
				
							
				long d = 2147483648;
				System.out.println(d);
				这个字面值超出int类型的取值范围
				解决方法
					
				long d = 2147483648L;
				System.out.println(d);
				
			强制转换
				public class DateType{

					public static void main (String[] args){
					byte a = 100;
					byte b  = (byte)128; //(byte)这个就是强制类型转换符
					System.out.println(a);
					System.out.println(b);
					
					short c = 100;
					short d = 32767;// java对byte、short、chart有优待，
									//如果字面值没有超出范围，不需要加强制类型转换符，可以直接赋值
					
					short e = (short)32768;//如果超出范围使用强制类型转换符会导致丢失精度，
					比如说这个e最后打印显示是-32767
					System.out.println(d);
					System.out.println(e);
					
					/*
									
					强转机制
						int 强转 short 
						首先int 八字节，short 四字节
						所以32768在int在计算机是
							0000 0000 0000 0000 1000 0000 0000 0000(补码)
						强制转换就是砍一半
						比如32768从int转short是直接变为
							1000 0000 0000 0000(补码)
						这样变为short值就为-32768					
						
					*/
					
					char f = 100;
					char g = 65535;
					char h = (char)65536;
					System.out.print(g);
					System.out.print(h);

					}
				}
					
				结果
					C:\Users\kk\Desktop>java DateType.java
					100
					0
					32767
					-32768
					?
		
		浮点型数据类型
			float 单精度
			double 双精度
			
			关于精度
				double 精度太低不适用于财务软件，为了适用于这种高精度需求的业务
				sun公司提供了一种精度更高的数据类型，不过这种数据类型是引用数据类型：java.math.BigDcimal
			
			关于java的类库
				java提供了非常庞大的类库，需要知道的是java的se类库的字节码在哪？知道se类库的源码在哪？
				C:\Program Files\Java\jdk-13.0.1\lib
			
			关于浮点数字面值的默认类型
				java语言中浮点数字面值被当作double类型来处理
				如果想要当作float类型来处理需要在后面添加f/F
				
			关于float变量的赋值（两种方法）
					
				public class DateType{

				public static void main (String[] args){
				
				double a =  3.14;//变量类型和字面值类型一致，可以编译
				float b = 3.14f;//没有任何强转，字面值类型就是float类型
				float c = (float)3.14;//强转后的赋值
				System.out.println(a);
				System.out.println(b);
				System.out.println(c);

				}
			
			浮点数在二进制内部存储的都是近似值，因为在现实世界中有些数字是无限循环的
			
		布尔型
			在java语言中只有false和true没有其它值，不像c语言当中，0和1 可以表示假和真
			经常用于逻辑运算和条件判断
			
			public class DateType{

				public static void main (String[] args){
				
				boolean a = true;//boolean a = false;
				if(a){
					System.out.print("true");
				}
				else{
					System.out.print("false");
				}
				}
			}
			
		基本数据类型之间的互相转换 转换规则（背）
			1、八种数据类型当中除了布尔类型其它七种之间都可以互相转换
			2、小容量向大容量转换，称为自动类型转换，容量从小到大
				byte < short < int < long < float < double
						char <
				注：任何浮点类型不管占用多少个字节，都比整数类型大
					char和short可表示的种类数量相同，但是char可表示更大的正整数
			3、从大容量转换为小容量，叫做强制类型转换，需要强制类型转换符，程序才能编译通过，
			但是在运行阶段可能会损失精度，谨慎使用
			4、当整数字面值没有超过byte、short、char的取值范围，可以直接赋值给
				byte、short、char类型的变量
			5、byte、short、char混合运算的时候，各自先转换成int类型再做运算。
			6、多种数据类型，先转换为容量最大的类型再做运算
			注：byte a = (byte)(int)b/3;括号内 的优先级高，
				最后等号右边的编程byte/int 最后是int类型。
				大容量转换为小容量必须夹强制类型转换符。
					
		分析程序是否编译成功，不要参杂运行阶段
			public class TestDype{
				public static void main(String[] args){
					short a = 1;
					byte b = 2;
					short c = a + b ;
					System.out.println(a);
					
				}
			}
			分析这个程序，你不需要计算结果，你只需要判断语法是否符合java规范，
			因为a + b short类型和byte类型相加，所以全部转换为int类型，那么最后
			short c 就被赋值int类型的数据，int类型转换为short类型需要强制类型转换符
				
	运算符
		关于运算符优先级
			一个表达式有优先级，优先级不确定，使用()来提高优先级
			()内优先级最高。
		算术运算符
			+
			-
			*
			/
			% 求余【取模】
			++ 自加1
			-- 自减1
			
			关于++运算符和--运算符
				以下程序用++举例，--效果类似
				public class OperatorTest{
					public static void main(String[] args){
						int y=1;
						//++运算符可以出现在变量后面【单目运算符】
						y++;
						//++运算符可以出现在变量后面【单目运算符】
						++y;
						System.out.println(y);
					}
				}
				小结：
					++运算符可以出现在变量前后，结果都是对变量进行自加1
				
			++ 出现在变量后
				规则：先做赋值运算，再对变量进行自加1
			
				public class OperatorTest{
					public static void main(String[] args){
						int a = 1;
						int b = a ++;
						System.out.println(a);
						System.out.println(b);
					}
				}
				结果：
					C:\Users\pipi\Desktop>java OperatorTest.java
					2
					1
								
			++ 出现再变量前
				规则： 先做自加1，再赋值
				
				public class OperatorTest{
					public static void main(String[] args){
						int a = 1;
						int b = ++ a;
						System.out.println(a);
						System.out.println(b);
						} 
					}
				结果：
					C:\Users\pipi\Desktop>java OperatorTest.java
					2
					2
					
			变形
				public class OperatorTest{
					public static void main(String[] args){
						int a = 1;
						int b = a ++;
						System.out.println(a ++);
						System.out.println(b ++);
						} 
					}
					
				结果：
					C:\Users\pipi\Desktop>java OperatorTest.java
					2
					1
	
		关系运算符
			>
			>=
			<
			<=
			==
			!=
			
			=是赋值运算符，==是关系运算符
			关系运算符的运算结果一定是布尔类型： true/false
			
			public class OperatorTest{
				public static void main(String[] args){
					int a = 1;
					int b = 2;
					System.out.println(a <= b);

					} 
				}
			关系运算符计算的ab两个变量的值的大小关系

		逻辑运算符
			&   与
			|   或
			！  非
			^   异或  不同为true，相同为false
			
			&&  短路与
			||  短路或
			
			1、逻辑运算符要求两边的算子是布尔类型，并且逻辑运算符最终运算结果俄式一个布尔类型
			2、短路与（或）和逻辑与（或）最终的运算结果是相同的，只不过短路与（或）
				存在短路现象
			3、什么情况下发生短路现象
			4、什么情况下用短路与
				前一个表达式结果为false
			5、什么情况下用短路或
				前一个表达式结果为true
			
			public class OperatorTest{
				public static void main(String[] args){
					int x = 10;
					int y = 8;
					System.out.println(x < y & ++x < y);//与操作，会把表达式完整运行
					System.out.println(x);
					System.out.println(x < y && ++x < y);//短路与操作，因为x < y已经确定是false所以短路与后面的表达式不会运行
					System.out.println(x);
					/*
						从某种角度来说短路与更加智能,由于后面的表达式不执行，所以执行效率高
						所以这种方式在实际开发中使用较多，但是在某些特殊环境下需要执行后面表达式
						这种情况就得使用逻辑与
					*/
					} 
				}
				
			
		赋值类运算符
			两种
				基本赋值运算符
					=
				扩展类赋值运算符
					+=
					-=
					*=
					/=
					%=
					
			赋值类运算符优先级
				先执行等号右边的表达式，将执行结果赋值给左边的变量
				
			关于拓展类赋值运算符的实际替换
				public class OperatorTest{
					public static void main(String[] args){
						int a = 1;
						byte b = 0;
						//b = a + 5;
						//b = (byte)(a+55)
						b += 5;//这行语句实际上等于(byte)(b+5) 其实并不等于b = b + 5
						System.out.println(b);
						}   
					}
				结论：
					拓展类赋值运算符不改变结果类型
					拓展类赋值运算符会自动进行强转
			
		字符串连接运算符
			关于+
				加法求和
					+两边的数据是数字，一定进行加法运算
					
				字符串的连接运算
					+两边有一个是字符串，就一定会进行字符串连接运算，且连接运算的结果
					还是一个字符串类型
					
				在表示中出现多个+，在没有添加括号的前提下，
				遵循自左向右的顺序依次运算
				
				
				public class OperatorTest{
					public static void main(String[] args){
						int a = 10;
						int b = 40;
						int c = a + b;
						System.out.println(10+20);//求和
						System.out.println(a + " + " + b + " = " + c);//字符串连接
						System.out.println(10 + a + "20");
						System.out.println(10 + (a + "20" ));//与上者执行顺序不同执行
						} 
				}    
			
			关于String
				String是java当中提供的字符串类型
				String.class字节码文件
				
				public class OperatorTest{
					public static void main(String[] args){
						int i = 10;
						String username = "zhangsan";
						System.out.println("success login, welcome " + username + "!!!!!");
						} 
						
					}
				
				
		三元运算符/三元运算符/条件运算符
			语法规则：
				布尔表达式 ？ 表达式1 ： 表达式2
			
			执行原理
			布尔表达式为ture，把表达式1作为整个表达式的结果。
			布尔表达式为false，把表达式2作为整个表达式的结果。
			
			正确理解执行原理
			public class OperatorTest{
					public static void main(String[] args){
						//编译错误
						//10;
						//编译错误
						//'男'
						//不是一个完整的java语句
						
						boolean sex = true;
						//编译错误
						//sex ? '男' : '女';
						
						char c = sex ? '男' : '女';
						System.out.println(c);
						
						//语法问题，类型不兼容
						// char c1 = sex ? "男" : '女';
						
						//可以执行
						System.out.println(sex ? '男' : '女');
					
						} 
						
					}

	控制语句
		分类
			选择结构
				if if..else
				switch
			循环结构
				for
				while
				do..while
			控制循环的语句
				break
				continue
		
		选择结构
			if语句
				if语句的语法结构
					第一种
						if(布尔表达式){
							java语句;
							java语句;
							java语句;
							java语句;
							...
						}
						
					第二种
						if(布尔表达式){
							java语句; 
							java语句;
							java语句;
							java语句;
							...
						}else{
							java语句;
							java语句;
							java语句;
							java语句;
							...
						}
					
					第三种
						if(布尔表达式){
							java语句;
							java语句;
							java语句;
							java语句;
							...
						}else if(布尔表达式){
							java语句;
							java语句;
							java语句;
							java语句;
							...
						}else if(布尔表达式){
							java语句;
							java语句;
							java语句;
							java语句;
							...
						}
						
					第四种
						if(布尔表达式){
							java语句;
							java语句;
							java语句;
							java语句;
							...
						}else if(布尔表达式){
							java语句;
							java语句;
							java语句;
							java语句;
							...
						}else if(布尔表达式){
							java语句;
							java语句;
							java语句;
							java语句;
							...
						}else{
							java语句;
							java语句;
							java语句;
							java语句;
							...
						}
						
				重点：       
					对于java语句中的if语句来说，只要有一个分支执行，整个if语句全部结束
				
				注意：       
					以上带有else分支，这两种方式可以保证百分百有分支执行
				
				可以嵌套
					所有控制语句可以互相嵌套使用的，只要合理嵌套
					if(){
						if(){
						
						}
					}
					else{
						if(){
						
						}
						else{
						
						}
					}
					嵌套使用时，代码格式必须完美【该缩进就得缩进】，使用大括号包围的代码
					需要缩进
				
				if 语句的分支中只有一条java语句，大括号可以省略不写
					if(布尔语句){
						一条java语句;
					}
					//这种方式不推荐使用，别人这么写我能看懂就行
					if (布尔语句) 一条java语句；

					//以上两种方式相等，后面加多少java语句都不受if条件影响是否执行
					if (布尔语句) 
						一条java语句；
						一条java语句;//这里这个语句不被if语句影响是否执行
					if (布尔语句) 
						一条java语句；一条java语句;//这也是
					

					
			接受用户接盘输入
			
				public class InputContent{
				public static void main(String[] args){
					//第一步创建键盘扫描对象
					java.util.Scanner s = new java.util.Scanner(System.in);
					//第二部调用Scanner对象的next方法开始接收键盘输入
					String input_String = s.next();//接收以字符串形式的文本
					System.out.print(input_String);
					int input_Int = s.nextInt();//接收以整数型int的形式的数字
					System.out.println(input_Int);
				}
				}

			关于switch语句
				属于选择结构，也是分支语句
				语法结构
					switch(int或String类型的字面值或变量){
						case int或String类型的字面值或变量:
						//case后的值和switch括号里面的值去匹配，
						//如果匹配成2功执行case内容
							java语句;
							...
							/*
								break;没写break会直接执行下一个语句的内容，不管
								下一个情况条件是否匹配,这种情况叫做case穿透现象。
							*/
						case int或String类型的字面值或变量:
							java语句;
							...
							break;//遇到这个整个分支结束

						case int或String类型的字面值或变量:
							java语句;
							...
							break;

						case int或String类型的字面值或变量:
							java语句;
							...
							break;
						
						default ://所有数据匹配不上时，执行这个语句内容
							java语句;
							...

					}
					
				switch 执行原理
					switch 小括号里面的数据和case后面的数据匹配
					匹配成功执行case的内容，自上而下依次匹配

					匹配成功的分支执行，分支中最后有break语句的话，整个switch语句终止

					匹配成功的分支执行，分支中没有break语句的话，直接进入下一个分支（不进行匹配），
					这种现象被称为case穿透现象【break语句可以避免穿透】

					所有分支没有匹配成功，当有default的语句话，会执行default分支当中的程序
					
					swtich case后面只能是int 或者String（jdk6以上版本）类型的数据，不能是探测其它类型。
					当然byte、short、chart也可以直接写到switch和case后面，因为他们可以
					进行自动类型转换，byte、short、char可以自动转换成int类型。
					
					case合并
						int i = 10;
						switch (i){
							case 1: case 2: case 3:case 10:
							//1 2 3 10 都可以匹配，都可以执行这个case里面的内容
							System.out.prinln("123");
						}

		关于循环
			循环结构
				执行需要重复执行的代码的作用，循环体和计数器相互配合使用

			基本所有编程语言都支持循环包括三种
				for
				while
				do...while
			
			for循环
				语法结构
					for(初始化表达式; 布尔表达式; 更新表达式){
						java语句;
						...
					}
				for 循环的执行原理
					初始化表达式、布尔表达式、更新表达式都不是必须的！
					但两个分号必须写

					public class Test{
						public static void main(String[] args){
							for(;;){
							System.out.print(123);//会一直执行这个语句
							}
						}
					}

					初始化表达式最先执行，在for循环当中只执行一次

					布尔表达式只能是true/false不能是其他值

					for的执行过程
						先执行初始化表达式，并且表达式只执行一次
						
						判断布尔表达式的结果是true/false
							true
								执行循环体
								执行更新表达式
								判断布尔表达式的结果是true/false
									true
										执行循环体
										执行更新表达式
										判断....
									false
										循环退出

							false
								循环退出

				i 的作用域
					在for里面定义的i的作用域只在for循环里
					在for外面定义的i的作用域在main方法里
					public class Test{
						public static void main(String[] args){
							for(int i = 1; i <= 10;i++ ){

							System.out.println(123);
							}

							int i;
							for(i = 1; i <= 10;i++ ){

							System.out.println(123);
							}  
						}
						}

				for与if嵌套使用
				for与循环结构嵌套
				99乘法表
				10000以内的素数，每八个一行

			关于while循环语句
				语法结构
					while(布尔表达式){
						循环体;
					}
						
				while循环的执行原理
					先判断布尔表达式的结果：
						true
							执行循环体
							判断布尔表达式的结果：
								true
									判断...
									...
									
								false
									退出循环体
						false
							退出循环	

				while循环的循环次数
					0~N次
				
			do...while
				语法结构
					do{
						循环体；
					}while(布尔表达式);
				执行原理
					先执行循环体
					判断布尔表达式
						true
							执行循环体
							判断...
								...
						false
							退出循环
				执行次数
					1~N次
				


			控制循环的语句
				break
					是java语言的关键字，翻译为中断
					
					break;是一个完整的java语句

					break常用于循环语句中，用来终止循环

					终止哪个循环
						一般情况下break终止的是最近的循环
							public class Test01{
								public static void main(String[] args){
									for(int i = 3; i>0; i--){
										for(int j = 0; j<10; j++){
											if (j == 5){
												break;
											}
											System.out.println(j);
										}
									}
									
								}
							}
						
						指定循环终止
							指定某个循环可以直接终止该循环
								取名字 A:循环
								终止   break A;
							
							public class Test01{
								public static void main(String[] args){
									A:for(int i = 3; i>0; i--){
										B:for(int j = 0; j<10; j++){
											if (j == 5){
												break A;
											}
											System.out.println(j);
										}
									}
									
								}
							}

							public class Test01{
								public static void main(String[] args){
									int i = 0;
									int j = 0;
									A:do{
										j++;
									B: do{
										i++  ;
										if(i == 5){
											break A;
											
										}
										System.out.println(i);
										
										}while(i<10);
										System.out.println("++++++++++++++++++++");

									}while(i<10);

								}
							}

				continue
					continue;是一个完整的java语句

					主要用于循环中，控制循环

					break和continue的区别
						break 终止循环
						continue 终止本次循环，直接进入下一个循环
								continue后面的语句不执行
					
					//输出奇数
						public class Test01{
							public static void main(String[] args){ 
								for(int i = 0; i<100; i++){
									if(i%2 == 0){
										continue;
									}
									System.out.println(i);
								}

							}
						}
					
					指定循环continue
						//break语法一样
						//当i 为偶数时continue只输出i(奇数)j
						public class Test01{
							public static void main(String[] args){ 
								A:for(int i = 0; i<10; i++){
									
									for(int j =0; j<10; j++){
										if(i%2 == 0){
											continue A;
										}
										System.out.print(i);
										System.out.println(j);
									}
										
									System.out.println("======================");
								
								}

							}
						}

	方法
		方法是什么,有什么用？
			方法是一段实现某些特定功能、可以重复利用的代码片段
			方法可以重复使用，定义方法可以重复使用该段代码

			public class Test{
				public static void main(String[] args){
					sum_Num(1,2);
					sum_Num(1,3);
					sum_Num(1,4);
					sum_Num(1,5);
					//一直重复利用，相同功能的程序使用方法是最便捷的
					
				}
				public static int sum_Num(int a, int b){//a和b是局部变量，方法结束后会自动释放内存空间
					System.out.println(a + "+" + (b + "=") + (a + b));
					return a+b;    
				}	
			}

		main方法和定义的方法
			main方法是jvm自动调用的，其它自定义的方法必须手动调用，方法不调用是不会自动执行的。
			同时需要注意的是，方法体的代码是自上而下依次执行的。
				public class Test{
					public static void main(String[] args){
						sum_Num(1,2);//这就是手动调用，没有这个就不会调用
						sum_Num(1,3);//上行代码执行完才能执行下行代码
						sum_Num(1,4);
						sum_Num(1,5);				
					}
					public static int sum_Num(int a, int b){
						System.out.println(a + "+" + (b + "=") + (a + b));
						return a+b;  
					}	
				}

		方法怎么定义，语法机制是什么？
			[修饰符列表]  返回值类型 方法名(形式参数列表){
				方法体；
			}
			注意：
				[] 中括号中的内容不是必须的，是可选的。
				方法体由java语句构成。
			
			修饰符列表
				现在统一写成pulic static 

			什么是返回值
				返回值是一个方法的执行结果,一般是数据,叫返回值.
				方法结束后的返回值是给调用者了
				public class Test{
					public static void main(String[] args){
						a();// a方法的返回值最后给了main方法
					}
				}

			返回值类型
				可以是任何java合法数据类型，包括基本数据类型和引用数据类型. 

			void关键字
				方法不返回任何值的时候使用,返回值类型不能空白所以写上void关键字

			return
				没有void时,必须使用"return 返回值; "这样的语句,返回值的类型和方法定义的类型一致.
				
				return代表一个方法的结束

				如果一个方法返回值类型是void,不能使用"return 值;"这样的语句,但是可以写"return ;"s
					public static void hanhan(){
						return;
					}

			方法名
				方法名需要见名知意
				符合标识符的命名规则和命名规范就可以

			形式参数列表
				形参列表中每个参数都是局部变量,方法结束后内存释放, 数量是0到N个.

				形参有多个需要逗号隔开
					public static int sum_Num(int a, int b){
						System.out.println(a + "+" + b + "=" + (a + b));
						return a+b;  
					}
			
			方法体
				由java语句构成
				完成特定功能
				自上而下依次执行
				执行时需要数据,数据来源就是形参

			方法调用
				类名.方法名(实际参数列表);

				实参和形参的类型和个数必须一一对应

			返回值接收 
				定义相同类型的变量接收
				也可以不接收

					public class Test{
						public static void main(String[] args){
							sum_Num(1,2);//这个是不接收
							int a = sum_Num(1, 4);这个是接收
						}
						public static int sum_Num(int a, int b){
							System.out.println(a + "+" + (b + "=") + (a + b));
							return a+b;  
						}

						public static void hanhan(){
							return;
						}
					}
			
			实际参数列表中的自动类型转换
		
				public class Test{
					public static void main(String[] args){
						sum_Num(1,2);//这个是不接收
						int a = sum_Num(1, 4);
						byte b = 10;
						byte c = 11;
						a = sum_Num(b,c); 
						//虽然赋值的不是int类型是byte，但是小容量可以自动转换为大容量，自动类型转换。

		
					}
					public static int sum_Num(int a, int b){
						System.out.println(a + "+" + b + "=" + (a + b));
						return a+b;  
					}

					public static void hanhan(){
						return;
					}
				}
				
			实际参数列表中的强制类型转换
				
				public class Test{
					public static void main(String[] args) {
						A.a((byte)123);
						}

				}
				class A{
					public static void a(byte a1){
						System.out.println(a1);

					}
				}

			调用方法是时类名什么时候省略

				省略的前提是此方法和你需要调用的方法是否在一个类中，不在同一个类就不能省略，
				在同一个就可以省略
				//类1
				public class Class1{
					public static void main(String[] args){
						Class1.p1();
						Class1.p2();//这个是之前的调用
						p1();//此方法和需要调用的方法是同一个类可以省略
						p2();
						Class2.p1();//方法和不需要调用的方法是不同类的不能省略
						Class2.p2();

					}
					public static void p1(){
						System.out.println("class1 p1");
					}
					public static void p2(){
						System.out.println("class1 p2");
					}
				}

				//类2
				class Class2{
					public static void p1(){
						System.out.println("class2 p1");
					}
					public static void p2(){
						System.out.println("class2 p2");
					}
				}
			
			方法调用方法（不把main方法特殊化）
				上面代码把调用语句调换顺序,使用方法调用方法，注意方法体自上而下的顺序。
				Class1.main 调用 Class1.p1
				Class1.p1 调用 Class1.p2
				Class1.p2 调用 Class2.p1
				Class2.p1 调用 Class2.p2

				public class Class1{
					public static void main(String[] args){
						p1();//在同一个类，调用Class1.p1。
					}
					public static void p1(){
						System.out.println("class1 p1");
						p2();//在同一个类，调用Class1.p2。
					}
					public static void p2(){
						System.out.println("class1 p2");
						Class2.p1();//不在同一个类，调用Class2.p1
					}
				}

				class Class2{
					public static void p1(){
						System.out.println("class2 p1");
						p2();//在同一个类，调用Class2.p2。
					}
					public static void p2(){
						System.out.println("class2 p2");
					}
				}

			break 和 return 区别
				break 结束的是一个循环
				return结束的是一个方法

				public class Class1{
					public static void main(String[] args){
						for(int a = 1; a < 10; a++){
							if(a == 5){
								break;//结束离它最近的循环
							}
							System.out.println(a);
							
						}
						System.out.println("Class1 over");
					}

				}
				
				结果
					1
					2
					3
					4
					Class1 over
				
				public class Class1{
					public static void main(String[] args){
						for(int a = 1; a < 10; a++){
							if(a == 5){
								//break;
								return;
								/*结束理它最近的方法，
									后面还有一个"System.out.println("Class1 over");"语句没有机会执行
								*/
							}
							System.out.println(a);
							
						}
						System.out.println("Class1 over");
					}

				}
				
				结果
					1
					2
					3
					4

			缺少返回语句
				编译器不执行代码，只判断语法正确与否

				public class Class1{
					public static void main(String[] args){
					m();  
							
					}
					public static int m(){
						boolean flag = true;
						if (flag){//编译器不执行代码，不知道里面的值
							return 1;//编译器不确定这个代码一定执行
						}
		
					}	
				}
				/*
					会报错的原因是编译器无法确定是否一定会有一个return返回值，所以需要再加一个return
					
				*/

				//return 语句同一个域下面不能再编写代码，编译器会报错
				
				public class Class1{
					public static void main(String[] args){
					m();  
							
					}
					public static int m(){
						boolean flag = true;
						if (flag){//编译器不执行代码，不知道里面的值
							return 1;
							//System.out.println(1); 站在编译器的角度，这里的语句一定不执行，编译器会报错
						}
						//System.out.println(1);  站在编译器的角度，这里的语句可能执行，不会报错

						return 0;
						//System.out.println(1);  站在编译器的角度，这里的语句一定不执行，编译器会报错
					}	
				}

			使用三目运算符来简化代码
				public class Class1{
					public static void main(String[] args){
					m();  					
					}
					public static int m(){
						boolean flag = true;
						return flag ? 1: 0;
					}
						
				}

		jvm内存结构
			看图片
		
		方法重载
			什么是方法重载
				相似方法可以命名相同，然后使用不同类型的形参来区分
					
					public class Test{
						public static void main(String[] arg){
							System.out.println(sumInt(1,2));
							System.out.println(sumLong(1,2));
							//上面是没有使用方法重载机制，这样会使相似功能的方法名增多
							//完全可以命名相同，然后用形参来区分

							System.out.println(sum(1,2));
							System.out.println(sum(1L,2L));
							System.out.println(sum(1L,2));//经过测试是使用形参是long方法
						}
						public static int sumInt(int a, int b){
							return a + b;
						}
						public static long sumLong(long a, long b){
							return a + b;
						}
						public static int sum(int a, int b){
							System.out.println("sum(int a, int b)");
							return a + b;
						}
						public static long sum(long a, long b){
							System.out.println("sum(long a, long b)");

							return a + b;
						}


					}

			java语言怎么对方法进行区分
				首先通过方法名区分
				允许相同的方法名
				相同方法名通过方法的参数类型来区分

			什么时候代码考虑使用方法重载？
				在同一个类中，两个方法功能相似可以使用方法重载，这样会使
				相似方法名字相同，方便记忆使用

			什么时候代码发生方法重载？（背）
				同一个类
				方法名相同
				参数列表不同
					参数类型不同
					参数顺序不同
					参数个数不同
				
				只要满足以上三点，就可以认定方法之间发生了重载机制

			方法重载和返回值类型无关，和修饰符列表无关
				public static int sum(){
					
					return 1.0;
				}

				public static int sum(){
					
					return 1;
				}
				这同个类的方法不能构成方法重载，只能说方法重复

		方法递归
			什么是递归
				方法自己调用自己

			当递归没有结束条件时
				会出现栈内存溢出错误
					原因是一直压栈没有弹栈，栈内存不够
				所以递归需要结束条件

	对象和类
		面向对象的三大特征
			封装
			继承
			多态

		几个概念
			类
				总结的一个模板

			对象
				实际存在的个体

			实例 
				对象还有另一个名字叫实例

			实例化
				通过类这个模板创建对象的过程叫实例化

			抽象
				多个对象具有的共同特征，进行思考总结抽取共同特征的过程

			
			类 ---【实例化】---》 对象（实例）
			对象 --【抽象】---》 类

			类 = 属性 + 方法

			属性来源于： 状态  就是我们的定义的 int a = 1；
			方法来源于： 动作  就是我们定义的方法 public static void fangfa(){}

		类的定义
			怎么定义一个类，语法格式是什么
				[修饰符列表] class 类名 {
					//类体 = 属性+方法
					//属性在代码上以变量的形式存在（描述状态）
					//方法描述行为

				}

		为什么属性是以变量的形式存在？
			是因为属性对应的是数据，数据用变量存储

		对象的创建
			语法
				new 类名();
				new是个运算符，用于创建对象we

				类名 变量名 = new 类名();
					public class Test{
						public static void main(String[] args){
							Student student1 = new Student();//student1 这种保存对象内存地址的叫做引用
							// 前后的类名是相同的
							// Student 是变量student1的数据类型（引用数据类型）
							// java 中类都是引用数据类型
							// new Student();   这是个对象

						}  
					}
					class Student{
						int num;we
						boolean sex;
						String name;//引用数据类型在没有赋值时，系统会自动赋值null

					}

		实例变量
			对象被称为实例，实例变量就是对象级别的变量

			public class A{
				double height;//这就是实例变量
				//这种变量被称为对象级别的变量，属于实例变量
			}

		引用
			public class Test{
				public static void main(String[] args){
					Student student1 = new Student();//student1 这种保存对象内存地址的叫做引用
				}  
			}
			class Student{
				int num;
				boolean sex;
				String name;//引用数据类型在没有赋值时，系统会自动赋值null

			}
		
		对象和引用的区别
			对象是通过 new出来的，在堆内存存储
			引用是：但凡是变量，且这个变量中保存了对象的内存地址的（看图片）
		
		怎么访问实例变量
			引用.实例变量名
				public class Test{
					public static void main(String[] args){
						Student student1 = new Student();
						System.out.println(student1.sex);//这个student1.sex就是访问实例变量
					}  
				}

		改变实例变量的数据
			重新赋值就可以了

			public class Test{
				public static void main(String[] args){
					Student student1 = new Student();
					System.out.println(student1.sex);//这个student1.sex就是访问实例变量
					student1.sex = ture;
					student1.num = 1111;//重新赋值就行
				}  
			}

		内存图
			不填写代码，只要数据
			根据程序执行顺序来画图

		空指针异常
			“空引用”访问实例【对象】相关的数据时会出现空指针异常

		什么时候会被gc回收
			java中的gc主要针对堆内存中的数据
			没有任何引用指向该对象的时候

		方法在调用的时候参数如何传递？
			只是把“值”传递过去，可能是数字，可能是对象的内存地址

		java变量赋值的原理是什么
			永远是把值复制过去，引用里面的值是对象内存地址

		构造方法
			什么是构造方法，有什么用?
				通过构造方法可以完成对象的创建，以及实例变量的初始化，
				换句话来说：构造方法是用来创建对象，并且
				同时给对象的属性赋值
			
			缺省构造器
				当一个一个类没有提供一个构造方法，
				系统会自动提供一个无参数的构造方法，
				这个方法被称为缺省构造器

				当一个类中有构造方法时，系统不会再提供
			
			调用构造方法怎么调用
				使用new  来调用构造方法

				语法是
					new 构造方法名(实际参数列表)

			构造方法的语法结构
				[修饰符列表] 构造方法名（形式参数列表）{
					构造方法体；
					//构造方法体中通常给属性赋值，完成属性的初始化
				}

				注意：
					修饰符列表必须是 public ，不要写public static，以后解释

					构造方法名和类名一致

					构造方法不需要指定返回类型，也不能写void，写上void就是普通方法，就不是构造方法

					建议写上无参构造方法，比较保险

				public class User{
					int id ;
					String username ;

					
					public User(){
						//虽然这里什么都没有写，但是实际上有两行代码
						// id = 0；
						// username = “”；
					}
					public User(int idNum, String usernameString){
						id = idNum;
						username = usernameString;
					}
					
					public User(){}

			构造方法支持方法重载
				
				public class User{
					int id ;
					String username;
					Address addr;

					public User(){
						
					}
					public User(int idNume, String usernameString){
						id = idNume;
						username = usernameString;
					}
					/*
					public User(int id, String username){
						id = id;
						username = username;
						//直接这样不能正确赋值
					}*/
				}

			实例变量没有手动赋值的时候，实际上系统会默认赋值，
			但是这个默认赋值操作实在什么时间进行的？
			是在类加载的时候给这些实例变量赋值吗？
				不是，实例变量时在构造方法执行的过程中完成赋值的，创建对象的时候

		封装
			什么是封装？ 有什么用？
				封装的作用
					保证内部结构安全
					屏蔽复杂，暴露简单
				
				代码级别上的封装
					当一个类当中的数据，假设封装后，对于调用人员来说不需要关心如何实现，
					只需要通过见的入口来访问就行了
					另外，类体中安全级别较高的数据封装起来，外部人员不能随意访问，
					来保证数据的安全性
		
			代码实现封装
				首先 使用private 修饰属性
				其次 提供入口来访问修改属性

					public class Person{
						private int age;
						public  int getAge(){
							return age;
						}
						public  void setAge(int ageNum){
							age = ageNum;
						}
						
					}

					public class Test_Private{
						public static void main(String[] args){
							Person p1 = new Person();
							System.out.println(p1.getAge());
							p1.setAge(123);
							System.out.println(p1.getAge());
								
						}
					}

				接口规范写法
					规范编写代码，你好我也好
					get
						public 返回值类型 get+属性名字(){
							return xxxx;
						}
					set
						public 返回值类型 set+属性名字(一个参数){
							xxx = 一个参数；
						}
		
			带有static的方法和不带static的方法怎么调用？
				带static，如之前所学，直接 类名.方法名  同一类可以省略
				不带有static 的方法被称为实例方法，实例方法必须先实例化对象后，使用 引用.方法名()来访问

					public class Static{
						publi static void main(String[] args){
							Static.a();
							a();
							//这是之前学的
							
							Static s = new Static();
							s.b();//实例方法只能通过先实例化对象后使用 引用.方法名()来调用
							new Static().b(); //这个视频没有解释，是以python学到的来尝试，可以使用

						}
						public static void a(){
							System.out.println("a");
						}
						public  void b(){
							//这种不带static被称为实例方法（对象方法，对象级别的方法）
							//
							System.out.println("b");

						}
					}
						
			实例对象里的实例变量和实例方法
				实例变量和实例方法必须实例化对象后直接 引用.变量名或者 引用.方法名()来调用

			实例方法导致的空指针异常
				和实例变量类似，都是空引用调用对象相关的方法时出现的错误
				
				其实空引用调用对象相关的数据时就会发生空指针异常，这里的相关的数据包括
				实例变量和实例方法
					
					public class Test{
						public static void main(String[] args){        
							User u1 = new User();
							u1 = null;//空引用了
							u1.a();//出现空指针引用
							

						}
					}

					public class User{
						int id ;
						String username ;


						
						public void a(){

						}
						
					}
										
		static关键字
			翻译成静态的
			所有static关键字都是用来修饰类相关的，类级别的
			所有static修饰的，都是采用"类名."的方式来访问的
			static修饰的变量是静态变量
			static修饰的方法是静态方法

		变量的分类
			局部变量：方法体内的
			成员变量：类体内方法体外的

			成员变量又可以分为
				实例变量
				静态变量	


			public class Test{
				int a ;//实例变量
				static int b;//静态变量
				public void c(){}//实例方法
				public static void d{}//静态方法
				public static void main(String[] args){        

				}
			}
		
		什么时候变量声明为实例的什么时候是静态的？
			当这个变量不是具体某个对象的属性，而是整个类的属性时就可以直接定义为静态变量
			简单来说就是这个类每个对象这个属性都是一样的就是静态变量
			这个类每个对象这个属性不一定相同的就是实例变量

			public class Chinese{
				
				String id;
				String xinming;//姓名数据实例级别的属性
				static String guoji = "zhonguo";//国籍属于类级别的特征
				//静态变量再类加载时初始化不需要new对象，直接就有默认值，存储在方法区
				public Chinese( String id, String xinming){
					
					this.id = id;
					this.xinming = xinming;
				}

			}

			public class Test{

				public static void main(String[] args){    
					Chinese c1 = new Chinese("123","lisi ");
					Chinese c2 = new Chinese("456","zhangsan");
					System.out.println(c1.id);
					System.out.println(c1.xinming);
					System.out.println(Chinese.guoji);//你可以这样直接访问
					System.out.println(c1.guoji);//也可以引用.访问
					System.out.println(c2.id);
					System.out.println(c2.xinming);
					System.out.println(Chinese.guoji);
					System.out.println(c1.guoji);



				}
			}

		静态变量加载时间
			当方法区加载类时，发现静态变量会直接加载在方法区里

		空引用访问静态不会空指针异常
			明确一点是静态变量可以通过引用访问，但是不建议，因为会让人误以为这是实例变量

			还有一点是，如果把引用赋值为空时，再访问静态变量，会访问成功。
			但这个实际上是“类名.”来访问的

			public class Test{
				public static void main(String[] args){    
					Chinese c1 = new Chinese("123","lisi ");
					Chinese c2 = new Chinese("456","zhangsan");
					System.out.println(c1.id);
					System.out.println(c1.xinming);
					System.out.println("类名.访问静态变量："+Chinese.guoji);//你可以这样直接访问

					System.out.println("引用访问静态变量："+c1.guoji);//也可以引用.访问
					c1 = null;
					System.out.println("赋值为null："+c1.guoji);//也可以引用.访问,但实际上是类名.访问的
				}
			}

			public class Chinese{
		
				String id;
				String xinming;//姓名数据实例级别的属性
				static String guoji = "zhonguo";//国籍属于类级别的特征
				//静态变量再类加载时初始化不需要new对象，直接就有默认值，存储在方法区
				public Chinese( String id, String xinming){
					
					this.id = id;
					this.xinming = xinming;
				}

			}

			结果：
				123
				lisi
				类名.访问静态变量：zhonguo
				引用访问静态变量：zhonguo
				赋值为null：zhonguo

		
			和静态量类似，也可以用"引用."来访问，但是不推荐，会让人以为是实例方法
			还有就是不会出现空指针异常

				public class Test{

					public static void main(String[] args){    
						Chinese c1 = new Chinese("123","lisi ");
						Chinese c2 = new Chinese("456","zhangsan");
						c1.a(); // 不推荐使用这种方式访问静态方法，会被人误以为是实例方法
						c1.b(); //通常实例方法的访问方式
						Chinese.a();//通常静态方法的访问方式
						c1 = null;
						c1.a();//不会出现空指针 异常，最终执行时会变为Chinese.a();这个代码
					}
				}

				public class Chinese{
		
					String id;
					String xinming;//姓名数据实例级别的属性
					static String guoji = "zhonguo";//国籍属于类级别的特征
					//静态变量再类加载时初始化不需要new对象，直接就有默认值，存储在方法区
					public Chinese( String id, String xinming){
						
						this.id = id;
						this.xinming = xinming;
					}
					public static void a(){
						System.out.println("a");
					}
					
					public void b(){
						System.out.println("b");
					}

				}

		什么定义为实例方法，什么时候定义为静态方法？
			当这个方法体中访问了实例变量那么它一定是实例方法
			工具类一般是静态方法，因为可以直接使用 "类名."访问

		静态代码块
			使用static 关键字可以定义：静态代码块
			什么是静态代码块，语法是什么
				static{
					java语句；
					java语句；
				}

			static静态代码块再什么时候执行?执行特点
				类加载时执行，只执行一次，
				并且在main方法执行前执行，
				按照自上而下顺序执行。

				public class Static{
					static {
						System.out.println("A");				
					}
					public static void main(String[] args){

						System.out.println("main");

					}
					static {
						System.out.println("B");
						
					}
					static {
						System.out.println("C");
					}

				}
				
				结果
					A
					B
					C
					main

			静态代码块有什么作用？
				不常用，不是每个类都要写
				这是sun公司给程序员提供的时机，叫类加载时机

		jvm内存的总结	（背）	
			堆
				方法只要执行，就会压栈（局部变量）
			栈
				new出来的对象都在堆中，垃圾回收器主要针对（实例变量）
			方法区
				类的信息，字节码信息，代码片段（静态变量）

			方法的代码片段放在方法区，但是方法执行过程中需要的内存在栈中
		
		实例语句块
			语法
				{
					java语句；
					java语句；
				}
			
			特点
				类加载不执行
				在构造方法执行前执行
				这也是sun公司给程序员提供的特殊时机，对象构建时机
					public class Test{

						public static void main(String[] args){    
							System.out.println("main方法");
							new Test();
							new Test();
							new Test(123);
							new Test(123);

						}

						{//实例语句块1
							System.out.println("实例语句块begin1");


						}
						public  Test(){
							System.out.println("无参构造");
						}
						public Test(int i){
							System.out.println("有参构造");
						}
						{//实例语句块2
							System.out.println("实例语句块begin2");
							//这个实例语句块，虽然在构造方法后面，但是执行比它们先


						}
					}

					结果
						main方法
						实例语句块begin1
						实例语句块begin2
						无参构造
						实例语句块begin1
						实例语句块begin2
						无参构造
						实例语句块begin1
						实例语句块begin2
						有参构造	

		程序执行小例子
			public class Test{
				static {
					System.out.println("A");
				}
				public static void main(String[] args){    
					System.out.println("Y");
					new Test();
					System.out.println("Z");

				}


				public  Test(){
					System.out.println("B");
					
				}

				{//实例语句块
					
					System.out.println("C");

				}
				static {
					System.out.println("x");
				}
			}
			
			结果
				A
				x
				Y
				C
				b
				Z

		this
			一个关键字

			是什么？内存细节
				一个对象一个this

				this是一个变量，是一个引用。 this保存当前对象的内存地址，指向自身。
				this存储在堆内存当中对象的内部

				只能使用在实例方法中，
				哪个对象调用实例方法，
				this就是指向它，
				this代表当前对象

			this 是可以省略的
				在同一个对象中可以省略
				public class Test{
					int i = 10; //实例变量
					static int k = 10; //静态变量
					public static void main(String[] args){
						//这是静态方法，访问实例变量必须先new一个对象

						Test a = new Test();
						System.out.println(a.i);//然后用“类名点”的方式去访问实例变量
						System.out.println(k);
						//因为是静态变量，又是同一个类，可以直接变量名访问，
						//但实际上k = this.k   
						
					}
					
				}
			
			为什么this不能使用在静态方法中？
				this代表当前对象，静态方法中不存在当前对象

			this什么时候不能省略（背）
				在构造方法或者实例方法中，发生局部变量名和实例变量名相同时，不能省略，必须写
				不然jvm只会遵循就近原则

				public class Test{

					public static void main(String[] args){
							A a = new A(1,2,3);
							System.out.println(a.get_a());
					
							a.set_a(100);
							System.out.println(a.get_a());
						
						}

						
					}

				class A{
					private int a;
					private int b;
					private int c;
					public A(){};
					public A(int a, int b, int c){
						this.a = a; 
						//如果不写this,jvm会自动人为下面的a、b、c是形式参数这里的abc
						//因为jvm是就近原则的
						this.b = b;
						this.c = c;
					}
					public void set_a(int a){
						this.a = a;//同样的道理
					}
					public int get_a(){
						return this.a;
					}
				}

			this可以用于构造方法和实例方法
				首先可以“this.变量名”来指代对象的实例变量
				也可以直接在构造方法中调用别的构造方法
					用法是this(参数列表);

				this()这个只能在构造器中第一行，不然会报错,而且只能出现一次

				public class Test{

					public static void main(String[] args){
						A a = new A();
						System.out.println(a.get_a());
				
						a.set_a(100);
						System.out.println(a.get_a());
					
					}

					
				}

				class A{
					private int a;
					private int b;
					private int c;
					public A(){
						this(1,2,3);
					};
					public A(int a, int b, int c){
						this.a = a; 
						//如果不写this,jvm会自动人为下面的a、b、c是形式参数这里的abc
						//因为jvm是就近原则的
						this.b = b;
						this.c = c;
					}
					public void set_a(int a){
						this.a = a;//同样的道理
					}
					public int get_a(){
						return this.a;
					}
				}

		总结所有的变量和方法的访问，和说过的东西
			类体{
				实例变量； 
				实例方法；
				//实例就是不带static 修饰的，调用时必须"引用."的方式来访问，有时候这个引用是“this”
				//所以可以用"this."来访问，在一个类中可以省略这个“this.”
				//实例变量可以私有化，private来修饰，但是记得要在后面添加实例方法get和set
				
				静态变量；
				静态方法；
				//带static 修饰的,调用时用“类名.”的方式来访问，在同一类中可以省略这个“类名.”

				构造方法；
				//没有返回值的方法，方法名和类名一样，可以重载，可以用this();调用其它构造方法
				

				静态代码块；
				//发生在类加载阶段
				
				实例语句块；
				//发生在对象生成阶段

				方法（）{
					局部变量; 
				}
			}
		
		继承
			什么是继承，有什么用？
				子类继承父类的属性和方法（除了构造方法），而且还可以再此基础上添加属性和方法

				子类继承父类，代码可以得到复用
				而且因为有了继承，才有了后期的方法覆盖和多态机制

			继承的相关特性
				1
					b类继承a类，a类为超类、父类、基类
					b类为子类、派生类、扩展类

						class A{}
						class B extends A{}

				2
					只支持单继承，不支持多继承
						class B extends A, C{}不支持这样的语法

				3
					虽然不支持多继承，但是可以产生间接继承的效果
						class A{}  
						class B extends A{} 
						class C extend B{}

				4
					java中规定，子类继承父类，除了构造方法外，
					都可以继承，但是私有的属性无法在子类中访问(可以通过间接的方式访问)
						public class Test{

							public static void main(String[] args){
								A a = new A();
								B b = new B();
								System.out.println(b.geta());    
							}   
						}

						class A{
							private int  a;
							public A(){
								this.a = 1;
							}
							public int geta(){
								return this.a;
							}
							
						}
						class B extends A{

						}

				5
					java中没有显示的继承任何类，则默认继承Object类，这个是根类

				6
					类的继承耦合度高，父类修改会影响子类

			满足什么条件可以使用继承。
				凡是采用 “is a”能描述的，都可以继承
				如Cat is a Animal

				
				如果以后有一个A类和B类，A和B确实有重复代码，是否继承？
					不一定，要看两者之间是否可以用A is a B 来描述

					class Custmoer{
						String name;
						
					}
					class Product{
						String name;
					}

					class product extends Custmoer{}
					
					以上继承就不能，Product is a Customer是有违伦理的

			没有明显显示继承任何类，默认继承Object类，那么Object提供了什么方法呢？？
				toString()方法
					会自动打印对象信息

					public class Test{
						public static void main(String[] args){
							A a = new A();
							System.out.println(a.toString());
							System.out.println(a);
							//两行输出一摸一样，说明println方法直接打印对象，会默认调用对象的toString()方法
						
						}   
					}

					class A{//没有写继承那个类，默认继承Object类
					
					}


					结果
						A@7382f612//@后面的数字是内存地址经过哈希算法算出的十六进制数
						A@7382f612

		方法覆盖
			什么是方法覆盖	
				别称：方法重写

			什么时候使用方法覆盖
				子类继承父类后，继承过来的方法不能满足子类的业务需求
				子类有权对该方法进行重新编写，有必要进行“方法覆盖”

			什么时候构成代码覆盖（背）
				两个类必须有继承关系
				
				重写之后的方法相同的返回值类型、方法名、参数列表

				访问权限不可以更低，可以更高
					public
					
				重写之后的方法不能比之前的代码抛出更多的异常
				
			注意事项（背）
				1	方法覆盖只针对方法，和属性无关
				2	私有方法无法覆盖
					public class Test{
						public static void main(String[] args){
							Test b = new B();
							b.a();

							/*
								结果：
									Test的a

								结论：
									私有方法没有方法覆盖
							*/   
						}
						private  void a(){
							System.out.println("Test的a");
						}
					}


					class B extends Test{
						public  void a(){
							System.out.println("B的a");

						}
					}
		
				3	构造方法不能被继承，所以无法覆盖
				4	方法覆盖只是针对实例方法，静态方法覆盖没有意义
					public class Test{
						public static void main(String[] args){
							A b = new B();
							b.a();//虽然实际上是B类但是会调用A类的静态方法
							B c = new B();
							c.a();//只有B类才能调用B类的方法
							/*
							结果：
								A的a
								B的a

							结论：
								虽然能实现方法覆盖
								但是没有意义，所以静态方法不存在方法覆盖
							*/   
						}
					}


					class A{
						public static void a(){
							System.out.println("A的a");

						}
					}

					class B extends A{
						public static void a(){
							System.out.println("B的a");

						}
					}
						
				5	写方法覆盖的时候，把父类的方法复制粘贴，这样避免出错

			方法覆盖案例
				public class Test{
					public static void main(String[] args){
						/*
						Chinese c = new Chinese("韩寒");
						American a = new American("jeak");
						以上的错误原因是因为，我在下面Chinese和American类是
						继承People类，但是没有继承构造方法。
						我也没有写构造方法，所以不能使用有参数的构造方法
						*/

						Chinese c = new Chinese();
						American a = new American();
						c.setName("瀚瀚");
						a.setName("jack");
						c.speak();
						a.speak();
						/*
							这里直接使用系统默认给的无参数构造方法
							使用setName方法赋值name属性，所以是可以的。
						*/

					}
				}

				class People{
					private String name;
					public People(){}
					public People(String name){
						this.name = name;
					}
					public void setName(String name){
						this.name = name;
					}
					public String getName(){
						return this.name;
					}
					public void speak(){
						System.out.println(name + "....");
					}

				}

				class Chinese extends People{
					public void speak(){//父类方法复制粘贴！！！！！！！！！！！！
						System.out.println(this.getName()+ " 说中国话");
						//这里是方法覆盖，把speak方法重写
					}
				}


				class American extends People{
					public void speak(){//父类方法复制粘贴！！！！！！！！！！！！
						System.out.println(this.getName()+ " speak english");
						//这里是方法覆盖，把speak方法重写
					}
				}

		多态	
			基础语法
				学习多态之前，先学习两个概念
					第一个
						向上转型：
							子转父(自动类型转换)
					第二个
						向下转型：
							父转子（强制类型转换，需要加强制类型转换符）
					注意
						java支持向下向上转型，无论是哪一种，
						
						两种类型之间必须有继承关系，否则编译器报错。

						自转和强转只是方便了理解的类比，但是实际工作中不能这样说，要专业
						说也只能说向上向下转型。

					例子
						public class Test{
							public static void main(String[] args){						
								//向上转型
								People p1 = new Chinese();
								People p2 = new American();
								p1.speak();
								p2.speak();
								/*  
									运行结果：
										null 说中国话
										null speak english

									什么是多态？
										多种形态，多种状态

									分析p1.speak();
										编译阶段
											对于编译器来说，编译器只知道p1的类型是Peopel，
											所以检查语法的时候，会去people.class 找speak()方法
											找到了绑定上speak（）
											编译通过，静态绑定成功。（编译阶段属于静态绑定）
										运行阶段
											运行的时候，实际上堆内存里面的对象是Chinese，
											所以在speak的时候，真正参与的speak的对象是Chinese
											所以运行阶段会动态执行Chinese对象的speak（）方法
											这个过程属于运行阶段绑定（运行阶段绑定属于动态绑定）
										
										多态表示多种形态
											编译的时候一种形态
											运行的时候另一种形态
								*/
								

							}
						}

						class People{
							private String name;
							public People(){}
							public People(String name){
								this.name = name;
							}
							public void setName(String name){
								this.name = name;
							}
							public String getName(){
								return this.name;
							}
							public void speak(){
								System.out.println(name + "....");
							}


						}

						class Chinese extends People{
							public void speak(){
								System.out.println(this.getName()+ " 说中国话");
							}
						}


						class American extends People{
							public void speak(){
								System.out.println(this.getName()+ " speak english");
							}
						}

				多态实际意义
					父类型指向子类型对象
					包括编译阶段和运行阶段
					编译阶段：绑定父类方法
					运行阶段：绑定子类型方法
					多种形态

				什么时候使用向下转型
					如果你想访问方法是子类特有的，父类没有的时候

					public class Test{
						public static void main(String[] args){
					
							//向上转型
							People p1 = new Chinese();
							People p2 = new American();
							p1.speak();
							p2.speak();
							//p1.gongfu();
							//不能编译通过，编译阶段静态绑定只会找People类里面的gongfu方法
							//但是People没有这个方法所以不能编译

							//如果我非要调用怎么办？
							//必须使用强制类型转换了
							Chinese a = (Chinese)p1;
							a.gongfu();
							//这时候因为有继承关系，可以使用强制类型转换


							

						}
					}

					class People{
						private String name;
						public People(){}
						public People(String name){
							this.name = name;
						}
						public void setName(String name){
							this.name = name;
						}
						public String getName(){
							return this.name;
						}
						public void speak(){
							System.out.println(name + "....");
						}


					}

					class Chinese extends People{
						public void speak(){
							System.out.println(this.getName()+ " 说中国话");
						}
						public void gongfu(){
							System.out.println("我会功夫");
						}
					}


					class American extends People{
						public void speak(){
							System.out.println(this.getName()+ " speak english");
						}
					}

				向下转型的风险
					类型转换错误
					public class Test{
						public static void main(String[] args){
					
							//向上转型
							People p1 = new American();
							Chinese a1 = (Chinese)p1;
							a1.gongfu();

							/*
								编译阶段，首先new出来的p1对象编译器认为是People类型
								然后People和Chinese是有继承关系的
								可以强制类型转换
								然后就能找到gongfu这个方法

								但是
								运行阶段
								看的是实际上堆内存里面实际的对象是哪个
								运行阶段p1实际上是American类和Chinese类是没有继承关系的
								强制类型转换会失败
							*/


						}
					}

					class People{
						private String name;
						public People(){}
						public People(String name){
							this.name = name;
						}
						public void setName(String name){
							this.name = name;
						}
						public String getName(){
							return this.name;
						}
						public void speak(){
							System.out.println(name + "....");
						}


					}

					class Chinese extends People{
						public void speak(){
							System.out.println(this.getName()+ " 说中国话");
						}
						public void gongfu(){
							System.out.println("我会功夫");
						}
					}


					class American extends People{
						public void speak(){
							System.out.println(this.getName()+ " speak english");
						}
					}

				如何避免？ instanceof（背）
					instanceof
						1 可以在运行阶段动态判断引用指向的对象类型
						2 语法
							（引用 instanceof 类型）
						3 instanceof运算符的运算结果只能是： true/false
						4 	c是引用，c变量保存了内存地址指向堆中的对象
							假设(c instance of Chinese) 为true表示什么？
								c引用指向堆内存的对象是Chinese
							假设(c instance of Chinese) 为false表示什么？
								c引用指向堆内存的对象不是Chinese
						5 程序员在使用向下转型的时候，需要使用instanceof来判断，这是个好习惯

						public class Test{
							public static void main(String[] args){
						
								//向上转型
								
								People p1 = new American();

								//解决方法
								if(p1 instanceof Chinese){
									Chinese a1 = (Chinese)p1;
									a1.gongfu();
								}
								else{
									System.out.println("不是Chinese类型");
								}


								


							}
						}

						class People{
							private String name;
							public People(){}
							public People(String name){
								this.name = name;
							}
							public void setName(String name){
								this.name = name;
							}
							public String getName(){
								return this.name;
							}
							public void speak(){
								System.out.println(name + "....");
							}


						}

						class Chinese extends People{
							public void speak(){
								System.out.println(this.getName()+ " 说中国话");
							}
							public void gongfu(){
								System.out.println("我会功夫");
							}
						}


						class American extends People{
							public void speak(){
								System.out.println(this.getName()+ " speak english");
							}
						}

				为什么使用instnaceof？
					public class Test{
						public static void main(String[] args){
					
							//向上转型
							People p1 = new American();//American可能是程序员A写的
							People p2 = new Chinese();//Chinese可能是程序员B写的
							testInstanceof(p1);
							testInstanceof(p2);
						
						}
						public static void testInstanceof(People p1){//这个可能是程序员C写的
							if(p1 instanceof Chinese){
								Chinese c1 = (Chinese)p1;
								c1.gongfu();
							}
							else if(p1 instanceof American){
								American a1 = (American)p1;
								a1.singEnglishSong();

						
							//以上的我们可以通过肉眼观察到
							//但是如果上面说的类型是别人写的，你就不可能知道这个类型的具体内容
							//所以避免出现问题需要使用instanceof方法
							
							}

						


						


						}
					}

					class People{
						private String name;
						public People(){}
						public People(String name){
							this.name = name;
						}
						public void setName(String name){
							this.name = name;
						}
						public String getName(){
							return this.name;
						}
						public void speak(){
							System.out.println(name + "....");
						}


					}

					class Chinese extends People{
						public void speak(){
							System.out.println(this.getName()+ " 说中国话");
						}
						public void gongfu(){
							System.out.println("我会功夫");
						}
					}


					class American extends People{
						public void speak(){
							System.out.println(this.getName()+ " speak english");
						}

						public void singEnglishSong(){
							System.out.println("Sing english song");
						}
					}

			开发中的作用	
				面向父类编程，不面向具体子类编程，这样的扩展性能最好

				降低程序的耦合度，提高程序的拓展力

				public class Master {
					/*
					public void feed(Dog d){}
					public void feed(Cat c){}
					这样的程序太过具体，以后要拓展其它宠物类不好拓展
					*/
					public void feed(Pet p1){//这样子对父类Pet编程，就算以后再添加其它宠物也是可以使用的
				
						p1.eat();
						
				
					}
				}
			
			关于开发的几个原则
				ocp
					对拓展开放，对修改关闭
					这样降低程序的耦合度，提高程序的拓展力

				面向抽象编程，不建议面向具体编程

		super	
			super()
				表示通过子类的构造方法调用父类的构造方法，
				模拟现实世界中有儿子必须先有父亲

			重要结论
				当一个构造方法既没有this（）也没有super（）会默认有一个super（）
				会自动调用父类的无参构造方法，所以必须保证父类有一个无参构造方法

				this() 和super()不能共存，它们都是只能出现在构造方法的第一行
			

			super(实参)的使用
				从父类继承的实例属性一般都是私有的，不能直接调用赋值
				所以使用super(实参)；通过调用父类的构造方法来赋值

				public class Test{
					public static void main(String[] args){
					B b = new B();

					}
				}

				class A{
					private int a1;
					
					
					public A(){
					
					}
					public A(int a1){
						this.a1 = a1;
					}
					
					public void seta1(int a1){
						this.a1 = a1;
					}
					public int geta1(){
						return this.a1;
					}
				}

				class B extends A{
					private int b1;
					public B(){
						/*
						this.a1 = 1;
						因为a1在A类中是私有的，所以只能换一种方式赋值
						通过super来调用父类有参数的构造方法来赋值也是不错
						*/
						super(1);
						this.b1 = 1;
						
						
					}

				}

			super（实参）的作用
				初始化当前对象父类型的特征
				并不是创建对象

			super 关键字代表是什么
				代表当前对象父类型特征
		
			super.什么时候不能省略
				当子类和父类都有相同名字的特征，想在子中访问父类继承的属性
				可以看下，截图“super.什么时候不能省略.png”

				public class Test{
					static int aaa;
					public static void main(String[] args){
					B b = new B();
					b.printa();

					}
				}

				class A{
					int a1;
					
					public A(){
					
					}
					public A(int a1){
						this.a1 = a1;
					}
				}


				class B extends A{
					private int a1;
					
					public B(){
						super(1);
						
					}
					public void printa(){
						System.out.println(this.a1);//这个是子类型自己的a1特征
						System.out.println(super.a1);//这里访问的是继承的父类型特征a1
						System.out.println(a1);//这个实际上是this.a1，也是子类型自己的特征

					}

				}
					
			java靠什么来区分父类和子类的同名属性
				this.name;//当前对象 name属性
				super.name;//当前对象父类型特征中的name属性
			
			super和this对比
				this
					出现在实例方法和构造方法中
						this.
						this()
					不能使用在静态方法中
					大部分情况下可以省略
					在区分实例变量和局部变量时不能省略
					this()只能出现在构造方法第一行，目的是方法复用

				super
					出现在实例方法和构造方法中
						super.
						super()
					不能使用在静态方法中
					大部分情况下可以省略
					在区分父类变量和子类变量的时候不能省略
					super()只能出现在构造方法第一行，目的是在创建子类对象的时候，先调用父类的构造方法，
					目的是：创建子类对象时，先初始化父类特征

			super和this的不同
				this可以单独使用，super不能
				this是引用，super不是
				super只是指向对象父类型的特征
					
		final关键字
			
			关键字
		
			表示最终的不可变的
		
			可以修饰变量以及方法，还有类等

			修饰变量
				修饰的变量只能赋一次值
					public class Test{
						public static void main(String[] args) {
							final int a = 1;
							a = 2;

						}
					}
					结果：
						Error:(4, 9) java: 无法为最终变量a分配值
				
				修饰引用会怎么样
					其实是一样的也无法重新赋值内存地址

					该引用只能指向该对象，并且它只能永远指向该对象

					但是该对象内部的数据可以被修改

						public class Test{
							public static void main(String[] args) {
								final A a = new A();
								a = new A();

							}
						}
						class A{ }


						结果：
							Error:(4, 9) java: 无法为最终变量a分配值

				修饰实例变量
					系统不管赋默认值，要求程序员手动赋值，要求程序员必须手动赋值
					这个手动赋值，在变量后面赋值还是在构造方法中赋值。

					public class Test{
						public static void main(String[] args) {
							final A a = new A();


						}
					}

					class A{
						//public final int a;
						//public final int a = 1; 在变量后面直接赋值
						/*
						public final int a;
						public A(){
							this.a = 1; 在构造方法中赋值
						}
						*/
					}

					结果：
						Error:(10, 22) java: 变量 a 未在默认构造器中初始化
				常量
					static final 修饰的变量称为常量，常量全部大写，和静态方法一样存储在方法区，
					在类加载时初始化
					区别在于
					常量不能变。
					常量一般是公开的

					class A{
						public static final A_A = 1;
					}

		
			修饰方法
				修饰的方法无法被覆盖

					class A{
						public final void a(){

						}

					}

					class B extends A{
						public void a(){

						}

					}

					结果：
						Error:(15, 17) java: B中的a()无法覆盖A中的a()
						被覆盖的方法为final





			修饰类
				修饰的类无法继承
					public final Test{
						public static void main(String[] args) {

						}
					}

					final class A{

					}


		抽象类
			什么是抽象类
				类和类之间具有共同特征，将这些共同特征提取出来，就是抽象类
				这种类本身是不存在的，所以抽象类无法创建对象，无法实例化

			抽象类属于什么类型
				抽象类也属于引用数据类型

			抽象类怎么定义
				[修饰符列表] abstract class 类名{
					类体；
				}

			抽象类无法实例化，所以只能用于继承
				abstract class Account{

				}

				class CrediAccoune extends Account{}

			final 和 abstract 不能联合使用，这两个是对立的
				final abstract class Account{

				}

				abstract class CrediAccoune extends Account{}

			结果：
				Error:(12, 16) java: 非法的修饰符组合: abstract和final
				Error:(16, 37) java: 无法从最终Account进行继承

			抽象类的子类可以是抽象类（老千层饼？）
				
				abstract class Account{

				}

				abstract class CrediAccoune extends Account{}

			抽象类有构造方法，是用于子类初始化父类特征（super（））

			抽象方法
				什么是抽象方法
					没有实现的方法，没有方法体的方法	
					public abstract void dosome();
					
				特点
					没有方法体，以分号结尾
					前面修饰符列表有abstract
			
				抽象类中不一定有抽象方法，抽象方法必须出现在抽象类中
				非抽象类继承抽象类需重写抽象方法(重要)

		接口
			基础语法
				引用数据类型，编译后也是class字节码文件

				完全抽象的（抽象类是完全抽象），可以说是特殊的抽象类
				
				接口定义
					[修饰符列表] interface 接口名{}

				接口支持多继承，一个接口可以继承多个接口
					interface A{}

					interface B{
					}

					interface C extends A, B{}
				
				接口只包含两个
					抽象方法
					常量
				
				接口中所有都是public修饰的

				接口中的方法可以省略public abstract

				接口中的常量可以省略public static final

				类和类叫继承，类和接口之间叫实现，可以将实现看作“继承”
				
				实现使用 implements

				接口被非抽象类实现，必须把所有的方法实现（覆盖）

				类可以实现多个接口

				继承和实现都存在怎么写
					extends 在前， implements在后

				接口提取的是行为动作

				接口可以使用多态（父类型引用指向子类型对象）

			开发中的作用

				降低程序的耦合度，提高程序的拓展力

				接口的使用离不开多态机制

			类型和类型之间的关系
				is a
					继承关系
					cat is a animal

					A extends B;
				
				has a
					关联关系
					以属性形式存在
				
					i has a pen

					A{
						B b;
					}
				
				like a
					实现关系
					cooker like a foodmenu
					实现关系通常是类实现接口

					A implements B
			
		抽象类和接口的区别
			抽象类半抽象
			接口完全抽象

			抽象类有构造方法
			接口没有构造方法

			接口和接口多继承
			类和类单继承

			一个类实现多个接口
			一个抽象类继承一个类

			接口只允许有常量和抽象方法

	package和import
		package
			怎么用？
				package [包名]

				只允许出现在第一行
			
			包名命名规范
				一般采用公司域名倒叙的方式
				公司域名倒序 + 项目名 + 模块名 + 功能名

			编译
				java -d . Test.java
				可以直接生成带目录的类

			运行
					java com.java.Test  
		
		import 
			什么时候使用
				A B 同一目录不用import
				A B 不同目录用import

				java.lang不需要
				


			怎么用
				package 之下  类定义之上

				import com.java.Test;
				import com.java.*;
		
	访问控制权限
		private 私有
			只能本类中访问

		protected 受保护的
			本类、同包、子类


		public 公开的
			任何位置都可以访问

			默认的
			本类、同包下访问


		访问控制修饰符			本类	同包	子类	任意位置
		public 					1		1		1		1
		protected				1		1		1		0
		默认  					1		1		0		0
		private					1		0		0		0

		可以修饰什么
			属性方法都可以用
			类和接口只有public和默认能用

	object
		常用方法
			protected Object clone()	
				Creates and returns a copy of this object.

			boolean	equals​(Object obj)	
				Indicates whether some other object is "equal to" this one.
				
				一般需要重写

				A a = new A();
				A b = a;
				System.out.println(a.equals(b));
				
				这里是判断对象的内存地址是否相等

				什么时候用equals什么时候用==
					基本数据类型用==
					引用数据类型用equals

			int	hashCode()	
				Returns a hash code value for the object.

				native 修饰，底层调用C++程序
				返回内存地址经过哈希算法得出的值

			String	toString()	
				Returns a string representation of the object.
				一般需要重写
				可以直接打印对象，会自动调用toString()
					
			protected void	finalize()	
				Deprecated.
				The finalization mechanism is inherently problematic.

				源码方法体没有代码

				不需要手动调用，jvm自动调用

				执行时机：对象被垃圾回收机制回收的时候，调用

				这个是垃圾销毁时机

				java的gc机制不是轻易启动的，垃圾太少或者时间没到都有可能不启动

				可以建议启动
					System.gc();

	匿名内部类
		什么是内部类
			在类的内部又定义新的类

		分类
			静态内部类  类似静态变量
			实例内部类	类似实例变量
			局部内部类	类似于局部变量
		
		可读性差，了解即可

		匿名内部类
			是局部内部类的一种，而且没有名字所以叫匿名内部类

			用于快速实现接口

				一般我们实现接口是写一个实现类
					
					public class Test{

						public static void main(String[] args) {
							int result = new MyMath().mySum(new Computeimpl(), 1, 2);
							System.out.println(result);

						
						}
					}
					interface Compute{
						int sum(int a, int b);
					}

					class Computeimpl implements Compute{//实现类
						public int sum(int a, int b){
							return a+ b;
						}
					}

					class MyMath{
						public int mySum(Compute compute, int a, int b){
							return compute.sum(a,b);


						}
					}

				使用匿名内部类可以不写这个实现类，可以直接实现
					
					public class Test{

						public static void main(String[] args) {
					//      int result = new MyMath().mySum(new Computeimpl(), 1, 2); 实现类的写法

					// 		以下是匿名内部类的写法
							int result  = new MyMath().mySum(new Compute(){
								public int sum(int a, int b) {
									return a + b;
								}
							},1,2);

							
							System.out.println(result);

						
						}
					}
					interface Compute{
						int sum(int a, int b);
					}

					//class Computeimpl implements Compute{
					//    public int sum(int a, int b){
					//        return a+ b;
					//    }
					//}

					class MyMath{
						public int mySum(Compute compute, int a, int b){
							return compute.sum(a,b);


						}
					}

			不建议这样写，因为这个无法重复利用，且代码可读性差
			只要能看懂这种代码即可，写法还是要按照实现类的方法写

数组
	引用数据类型
	
	多种数据的容器，可以存储基本数据类型也可以引用数据类型

	数组对象存储在堆内存中

	数组里是对象的化，是对象的引用（内存地址）
	
	数组一但创建，长度无法改变

	数组分类
		一维数组
		二维数组
		多维数组

	数组又length 来获取数组个数

	数组中的元素必须是一种类型

	数组在元素内存地址是连续的

	数组首元素的内存地址，是整个数组的内存地址

	数组每个元素都是有下标，从0开始，以1递增，最后一个元素的下标是length-1

	数组的优缺点
		优点：查询元素快
			为什么
				每个元素内存地址是连续的
				每个元素类型相同占用空间大小相同
				知道第一个元素的内存地址，可以快速算出某个元素的内存地址
				数组的检索效率最高

		缺点：
			由于内存地址连续，需要删除增添元素效率低
				因为删增元素会使一连串的元素地址向前改变或者向后

				特别的对于最后一个元素增删是没有效率影响的

			不能存储大数据量
				很难在内存空间上，找到特别大的连续的内存空间
	
	一维数组

		定义一维数组
			int[] array1;
			double[] array2;
			object[] array3;
		
		初始化
			静态初始化
				int[] array = {100,200,300}；
			动态初始化
				int[] array  = new int[5];
				5代表初始化五个长度的int类型数组，每个元素默认值为0

				String[] names = new String[6];
				初始化6个长度的String类型的数组，每个元素默认值为null

			怎么区分两种使用
				静态是确定了要存储哪些数据
				动态是不确定要存储哪些数据

			C++的写法也是行的
				int array[] = {100,200,300}；了解即可
				
		读
			a1[1];

		改
			a1[1] = 1;

		遍历数组
			for

		方法参数是数组
			主要记得静态初始化数组作为参数的写法
			
			public class Test{

				public static void main(String[] args) {
					int a[] = new int[5];
					int b[] = {1,2,3};
					printarry(a);
					printarry(b);
					//上面是一般写法
					printarry(new int[5]);//直接将动态初始化的作为参数
					printarry(new int[] {1,2,3});//静态初始化作为参数的写法

				}

				public static  void printarry(int[] a ){
					for (int i = 0; i < a.length; i++) {
						System.out.println("下标是"+ i + "的元素: " + a[i] );

					}
				}
			}

		main方法的String[] args 有什么用?
			用于控制台用户输入参数会自动转换为String数组（以空格来分开元素）

			public class Test{

				public static void main(String[] args) {
					print_stringarry(args);

				}

				public static void print_stringarry(String[] args){
					for (int i = 0; i <args.length ; i++) {
						System.out.println(args[i]);

					}
				}
			}	


			java Test.java fsadfasdf asdfasdfsadf
			后面这两个以空格分开
			
			C:\Users\hanhan\Desktop\Test\src>java Test.java fsadfasdf asdfasdfsadf
			fsadfasdf
			asdfasdfsadf

		数组扩容
			因为数组大小是确定的，想要存储更多，新建大容量的数组，把旧数组的元素拷贝到新数组里
			效率低，所以一开始就准确定义

			使用 System.arraycopy()
				public class Test{

					public static void main(String[] args) {
						int [] a = {1,2,3,4,5};
						int [] b = new int[20];
						System.arraycopy(a,2,b,4,3);
						//参数 源数组 从哪里拷贝 目标数组 从哪里粘贴 拷贝几个元素
						printArray(b);


					}
					public static void printArray(int[] a){
						for (int i = 0; i < a.length; i++) {
							System.out.println(a[i]);

						}
					}


				}

	二维数组
		特殊的一维数组，一维数组的每个元素是一维数组

		初始化
			静态初始化
				int[][] array = {{},{},{},{}}
			动态初始化
				int[][] array = new int[][];

		.length
			指有几个一维数组
		[0].length
			指二维里面的一维数组的长度


		读
			array[][];
		
		改
			array[][] = 12312;

		二维数组的遍历
			for
				for

			重点在第二个for里面循环条件的写法

			public class Test{

				public static void main(String[] args) {


					int [][] a = {{1,2,3,4},{1,2,3,4},{1,2,3,4},{1,2,3,4}};
					int [][][] b = new int[5][5][5];
					int [][] c = {
							{1,3,4},
							{123,3123,3123,123,1,23,123},
							{13,1,3,123,32,13,12,3,123,21,23,12,3,12},
							{13,123123,123,123,12,312,3,123,12}
					};

					for(int i=0; i<c.length; i++){
						for(int z=0; z<c[i].length; z++){
							System.out.print(c[i][z]+" ");

						}
						System.out.println();
					}

				}
				public static void printArray(int[] a){
					for (int i = 0; i < a.length; i++) {
						System.out.println(a[i]);

					}
				}


			}

		方法参数是二维数组
			和一维数组差不多注意静态初始化要直接写入需要写成
			int[][] {{},{},{}}
		
			public class Test{

				public static void main(String[] args) {



					int [][] c = {
							{1,3,4},
							{123,3123,3123,123,1,23,123},
							{13,1,3,123,32,13,12,3,123,21,23,12,3,12},
							{13,123123,123,123,12,312,3,123,12}
					};
					printArray(c);


				}
				public static void printArray(int[][] a){
					for(int i = 0; i < a.length; i++) {
						for (int j = 0; j <a[i].length ; j++) {
							System.out.print(a[i][j]+" ");

						}
						System.out.println("");



					}
				}



			}








			







	

	

	
















	

	


			




		

		




	









		
		
		















		

		
		
		



			




	







	

	

		
			
			
					

		

			


		



    
        
        
        
        
            
        
        
                
                
    
                

	
		
		